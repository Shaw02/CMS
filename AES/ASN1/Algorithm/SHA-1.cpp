#include "StdAfx.h"
#include "SHA-1.h"

//==============================================================
//			コンストラクタ
//--------------------------------------------------------------
//	●引数
//			無し
//	●返値
//			無し
//==============================================================
SHA1::SHA1(void)
{
}
//==============================================================
//			デストラクタ
//--------------------------------------------------------------
//	●引数
//			無し
//	●返値
//			無し
//==============================================================
SHA1::~SHA1(void)
{
}
//==============================================================
//			初期化
//--------------------------------------------------------------
//	●引数
//			無し
//	●返値
//			無し
//==============================================================
void	SHA1::init(void)
{
	iCountBlock = 0;
	H[0] = 0x67452301;
	H[1] = 0xefcdab89;
	H[2] = 0x98badcfe;
	H[3] = 0x10325476;
	H[4] = 0xc3d2e1f0;

}
//==============================================================
//			１ブロック（64Byte）計算
//--------------------------------------------------------------
//	●引数
//			void *data	計算する１ブロックのポインタ（64Byte）
//	●返値
//			無し
//==============================================================
void	SHA1::calc(void *data)
{

	unsigned int*	iData = (unsigned int*)data;
	unsigned char	t=0;

	__m128i	_m[4];

	__declspec(align(8))	unsigned int	w[80];
	__declspec(align(16))	unsigned int	X[5];
							unsigned int	T;

#define	a	X[0]
#define	b	X[1]
#define	c	X[2]
#define	d	X[3]
#define	e	X[4]
	
	//----------------------------
	//入力データの拡張
	do{
		T = iData[t];
		w[t] = ((T>>24)&0xFF | ((T>>16)&0xFF)<<8 | ((T>>8)&0xFF)<<16 | (T&0xFF)<<24);
		t ++;
	} while(t<16);

	do{
		_m[0] = _mm_loadl_epi64((__m128i*)&w[t-3]);
		_m[1] = _mm_loadl_epi64((__m128i*)&w[t-8]);
		_m[2] = _mm_loadl_epi64((__m128i*)&w[t-14]);
		_m[3] = _mm_loadl_epi64((__m128i*)&w[t-16]);

		_mm_storel_epi64((__m128i*)&w[t], _mm_ROTLD(1, _mm_xor_si128(_mm_xor_si128(_m[0],_m[1]), _mm_xor_si128(_m[2],_m[3]))));
		t += 2;
	} while(t<80);



	//----------------------------
	//ハッシュ計算

//	メモリに入るので、逆に遅くなる。
//	memcpy(X,H,sizeof(H));

//	こうすると、まずはレジスターに入る。
	a = H[0];
	b = H[1];
	c = H[2];
	d = H[3];
	e = H[4];

	t=0;
	do{
		T = ROTL(5,a) + Ch(b,c,d) + e + 0x5a827999 + w[t];
//		SIMD化すると、メモリに入るので、逆に遅い模様。
//		_mm_storeu_si128((__m128i*)&b, _mm_loadu_si128((__m128i*)&a));
//		c = ROTL(30,c);

//		メモリに入れないで、汎用レジスターで計算してくれる。
		e = d;
		d = c;
		c = ROTL(30,b);
		b = a;
		a = T;
		t++;
	} while(t<20);

	do{
		T = ROTL(5,a) + Parity(b,c,d) + e + 0x6ed9eba1 + w[t];
		e = d;
		d = c;
		c = ROTL(30,b);
		b = a;
		a = T;
		t++;
	} while(t<40);

	do{
		T = ROTL(5,a) + Maj(b,c,d) + e + 0x8f1bbcdc + w[t];
		e = d;
		d = c;
		c = ROTL(30,b);
		b = a;
		a = T;
		t++;
	} while(t<60);

	do{
		T = ROTL(5,a) + Parity(b,c,d) + e + 0xca62c1d6 + w[t];
		e = d;
		d = c;
		c = ROTL(30,b);
		b = a;
		a = T;
		t++;
	} while(t<80);

	//でも、加算はSIMD化しておく。
	_mm_storeu_si128((__m128i*)&H ,_mm_add_epi32(_mm_loadu_si128((__m128i*)&H), _mm_load_si128((__m128i*)&X)));

//	H[0] += a;
//	H[1] += b;
//	H[2] += c;
//	H[3] += d;
	H[4] += e;

}
//==============================================================
//			ハッシュ値取得
//--------------------------------------------------------------
//	●引数
//			void *result	ハッシュ値を格納するアドレス（160bit）
//	●返値
//			無し
//==============================================================
void	SHA1::getHash(void *result)
{
	memcpy(result,H,SHA1_HashSize);
}

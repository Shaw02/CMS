#include "StdAfx.h"
#include "SHA-256.h"

//==============================================================
//			コンストラクタ
//--------------------------------------------------------------
//	●引数
//			無し
//	●返値
//			無し
//==============================================================
SHA256::SHA256(void)
{
}
//==============================================================
//			デストラクタ
//--------------------------------------------------------------
//	●引数
//			無し
//	●返値
//			無し
//==============================================================
SHA256::~SHA256(void)
{
}
//==============================================================
//			初期化
//--------------------------------------------------------------
//	●引数
//			無し
//	●返値
//			無し
//==============================================================
void	SHA256::init(void)
{
	iCountBlock = 0;
	H[0] = 0x6A09E667;
	H[1] = 0xBB67AE85;
	H[2] = 0x3C6EF372;
	H[3] = 0xA54FF53A;
	H[4] = 0x510E527F;
	H[5] = 0x9B05688C;
	H[6] = 0x1F83D9AB;
	H[7] = 0x5BE0CD19;
}
//==============================================================
//			１ブロック（64Byte）計算
//--------------------------------------------------------------
//	●引数
//			void *data	計算する１ブロックのポインタ（64Byte）
//	●返値
//			無し
//==============================================================
void	SHA256::calc(void *data)
{
	static	const unsigned	int	k[64]={
		0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
		0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
		0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
		0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
		0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
		0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
		0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
		0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
};

	unsigned int*	iData = (unsigned int*)data;
	unsigned char	t=0;

	__m128i	_m[4];

	__declspec(align(8))	unsigned int	w[64];
	__declspec(align(16))	unsigned int	X[8];
							unsigned int	T1;
							unsigned int	T2;

#define	a	X[0]
#define	b	X[1]
#define	c	X[2]
#define	d	X[3]
#define	e	X[4]
#define	f	X[5]
#define	g	X[6]
#define	h	X[7]
#define	T	T1

	//----------------------------
	//入力データの拡張
	do{
		T = iData[t];
		w[t] = ((T>>24)&0xFF | ((T>>16)&0xFF)<<8 | ((T>>8)&0xFF)<<16 | (T&0xFF)<<24);
		t ++;
	} while(t<16);

	do{
		_m[0] = _mm_A1_256(	_mm_loadl_epi64((__m128i*)&w[t-2]));
		_m[1] =				_mm_loadl_epi64((__m128i*)&w[t-7]);
		_m[2] = _mm_A0_256(	_mm_loadl_epi64((__m128i*)&w[t-15]));
		_m[3] =				_mm_loadl_epi64((__m128i*)&w[t-16]);

		_mm_storel_epi64((__m128i*)&w[t], _mm_add_epi32(_mm_add_epi32(_m[0],_m[1]), _mm_add_epi32(_m[2],_m[3])));

		t += 2;
	} while(t<64);



	//----------------------------
	//ハッシュ計算

//	メモリに入るので、逆に遅くなる。
//	memcpy(X,H,sizeof(H));

//	こうすると、まずはレジスターに入る。
	a = H[0];
	b = H[1];
	c = H[2];
	d = H[3];
	e = H[4];
	f = H[5];
	g = H[6];
	h = H[7];

	t=0;
	do{
		T1 = h + S256_1(e) + Ch(e,f,g) + k[t] + w[t];
		T2 = S256_0(a) + Maj(a,b,c);

		h  = g;
		g  = f;
		f  = e;
		e  = d + T1;
		d  = c;
		c  = b;
		b  = a;
		a  = T1 + T2;

		t++;
	} while(t<64);

	_mm_storeu_si128((__m128i*)&H[0] ,_mm_add_epi32(_mm_loadu_si128((__m128i*)&H[0]), _mm_load_si128((__m128i*)&X[0])));
	_mm_storeu_si128((__m128i*)&H[4] ,_mm_add_epi32(_mm_loadu_si128((__m128i*)&H[4]), _mm_load_si128((__m128i*)&X[4])));

}
//==============================================================
//			ハッシュ値取得
//--------------------------------------------------------------
//	●引数
//			void *result	ハッシュ値を格納するアドレス（256bit）
//	●返値
//			無し
//==============================================================
void	SHA256::getHash(void *result)
{
	memcpy(result,H,SHA256_HashSize);
}

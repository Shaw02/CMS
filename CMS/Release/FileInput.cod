; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\?n????j\My Project\CMS\CMS\FileInput.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4?$codecvt@DDH@std@@6B@			; std::codecvt<char,char,int>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$codecvt@DDH@std@@8			; std::codecvt<char,char,int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$codecvt@DDH@std@@8			; std::codecvt<char,char,int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$codecvt@DDH@std@@8		; std::codecvt<char,char,int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$codecvt@DDH@std@@@8			; std::codecvt<char,char,int> `RTTI Type Descriptor'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R4codecvt_base@std@@6B@			; std::codecvt_base::`RTTI Complete Object Locator'
PUBLIC	??_R3codecvt_base@std@@8			; std::codecvt_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2codecvt_base@std@@8			; std::codecvt_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@codecvt_base@std@@8		; std::codecvt_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVcodecvt_base@std@@@8			; std::codecvt_base `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4FileInput@@6B@				; FileInput::`RTTI Complete Object Locator'
PUBLIC	??_R3FileInput@@8				; FileInput::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FileInput@@8				; FileInput::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R13A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (4,0,4,64)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@FileInput@@8			; FileInput::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVFileInput@@@8				; FileInput `RTTI Type Descriptor'
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
PUBLIC	?clear@ios_base@std@@QAEXH@Z			; std::ios_base::clear
PUBLIC	?_Init@ios_base@std@@IAEXXZ			; std::ios_base::_Init
PUBLIC	?widen@?$ctype@D@std@@QBEDD@Z			; std::ctype<char>::widen
PUBLIC	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
PUBLIC	?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init
PUBLIC	??0ios_base@std@@IAE@XZ				; std::ios_base::ios_base
PUBLIC	??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
PUBLIC	??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >
PUBLIC	??0locale@std@@QAE@XZ				; std::locale::locale
PUBLIC	??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
PUBLIC	??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
PUBLIC	??_Glocale@std@@QAEPAXI@Z			; std::locale::`scalar deleting destructor'
PUBLIC	?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::uflow
PUBLIC	?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_streambuf<char,std::char_traits<char> >::imbue
PUBLIC	??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
PUBLIC	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
PUBLIC	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::gbump
PUBLIC	?_Xsgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADIH@Z ; std::basic_streambuf<char,std::char_traits<char> >::_Xsgetn_s
PUBLIC	?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbump
PUBLIC	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
PUBLIC	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
PUBLIC	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
PUBLIC	??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z		; std::_Fputc<char>
PUBLIC	?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::out
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?not_eof@?$char_traits@D@std@@SAHABH@Z		; std::char_traits<char>::not_eof
PUBLIC	?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::eback
PUBLIC	?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gndec
PUBLIC	??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z		; std::_Ungetc<char>
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::egptr
PUBLIC	??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z		; std::_Fgetc<char>
PUBLIC	?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::in
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	??0?$fpos@H@std@@QAE@H_J@Z			; std::fpos<int>::fpos<int>
PUBLIC	?state@?$fpos@H@std@@QBEHXZ			; std::fpos<int>::state
PUBLIC	?seekpos@?$fpos@H@std@@QBE_JXZ			; std::fpos<int>::seekpos
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PADH@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0_Iterator_base_secure@std@@QAE@XZ		; std::_Iterator_base_secure::_Iterator_base_secure
PUBLIC	??0?$_Ranit_base@DHPBDABDV_Iterator_base_secure@std@@@std@@QAE@XZ ; std::_Ranit_base<char,int,char const *,char const &,std::_Iterator_base_secure>::_Ranit_base<char,int,char const *,char const &,std::_Iterator_base_secure>
PUBLIC	??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBV_Container_base_secure@1@@Z ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBV_Container_base_secure@1@@Z ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_iterator<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z	; std::codecvt<char,char,int>::unshift
PUBLIC	?_Has_container@_Iterator_base_secure@std@@QBE_NXZ ; std::_Iterator_base_secure::_Has_container
PUBLIC	??D?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
PUBLIC	??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
PUBLIC	?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ifstream<char,std::char_traits<char> >::close
PUBLIC	??_GFileInput@@UAEPAXI@Z			; FileInput::`scalar deleting destructor'
PUBLIC	?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ ; std::basic_streambuf<char,std::char_traits<char> >::getloc
PUBLIC	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z ; std::basic_streambuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
PUBLIC	?always_noconv@codecvt_base@std@@QBE_NXZ	; std::codecvt_base::always_noconv
PUBLIC	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg
PUBLIC	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp
PUBLIC	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAV?$codecvt@DDH@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
PUBLIC	??0codecvt_base@std@@QAE@I@Z			; std::codecvt_base::codecvt_base
PUBLIC	?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z	; std::codecvt<char,char,int>::_Init
PUBLIC	?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::do_in
PUBLIC	?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::do_out
PUBLIC	?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z ; std::codecvt<char,char,int>::do_unshift
PUBLIC	?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z	; std::codecvt<char,char,int>::do_length
PUBLIC	?do_always_noconv@codecvt_base@std@@MBE_NXZ	; std::codecvt_base::do_always_noconv
PUBLIC	?do_max_length@codecvt_base@std@@MBEHXZ		; std::codecvt_base::do_max_length
PUBLIC	?do_encoding@codecvt_base@std@@MBEHXZ		; std::codecvt_base::do_encoding
PUBLIC	??_Gcodecvt_base@std@@UAEPAXI@Z			; std::codecvt_base::`scalar deleting destructor'
PUBLIC	??1codecvt_base@std@@UAE@XZ			; std::codecvt_base::~codecvt_base
PUBLIC	??1?$codecvt@DDH@std@@MAE@XZ			; std::codecvt<char,char,int>::~codecvt<char,char,int>
PUBLIC	??_G?$codecvt@DDH@std@@MAEPAXI@Z		; std::codecvt<char,char,int>::`scalar deleting destructor'
PUBLIC	??0?$codecvt@DDH@std@@QAE@ABV_Locinfo@1@I@Z	; std::codecvt<char,char,int>::codecvt<char,char,int>
PUBLIC	?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::codecvt<char,char,int>::_Getcat
PUBLIC	??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,int> >
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::open
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?is@?$ctype@D@std@@QBE_NFD@Z			; std::ctype<char>::is
PUBLIC	??0ctype_base@std@@QAE@I@Z			; std::ctype_base::ctype_base
PUBLIC	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
PUBLIC	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z	; std::ctype<char>::_Init
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?_Do_widen_s@?$ctype@D@std@@MBEPBDPBD0PADI@Z	; std::ctype<char>::_Do_widen_s
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	?_Do_narrow_s@?$ctype@D@std@@MBEPBDPBD0DPADI@Z	; std::ctype<char>::_Do_narrow_s
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z		; std::ctype<char>::ctype<char>
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
PUBLIC	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
PUBLIC	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
PUBLIC	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
PUBLIC	?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
PUBLIC	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
PUBLIC	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
PUBLIC	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	?_Sgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPADIH@Z ; std::basic_streambuf<char,std::char_traits<char> >::_Sgetn_s
PUBLIC	?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z ; std::basic_istream<char,std::char_traits<char> >::_Read_s
PUBLIC	?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z ; std::basic_istream<char,std::char_traits<char> >::read
PUBLIC	?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@JH@Z ; std::basic_istream<char,std::char_traits<char> >::seekg
PUBLIC	?pubseekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@H@2@JHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pubseekoff
PUBLIC	??0?$fpos@H@std@@QAE@J@Z			; std::fpos<int>::fpos<int>
PUBLIC	?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@H@2@XZ ; std::basic_istream<char,std::char_traits<char> >::tellg
PUBLIC	??B?$fpos@H@std@@QBEJXZ				; std::fpos<int>::operator long
PUBLIC	??_7FileInput@@6B@				; FileInput::`vftable'
PUBLIC	??_8FileInput@@7B@				; FileInput::`vbtable'
PUBLIC	?_Stz@?$fpos@H@std@@0HB				; std::fpos<int>::_Stz
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
PUBLIC	??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_istream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_7codecvt_base@std@@6B@			; std::codecvt_base::`vftable'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7?$codecvt@DDH@std@@6B@			; std::codecvt<char,char,int>::`vftable'
EXTRN	?_Addstd@ios_base@std@@SAXPAV12@@Z:PROC		; std::ios_base::_Addstd
EXTRN	??0_Mutex@std@@QAE@XZ:PROC			; std::_Mutex::_Mutex
EXTRN	?_Init@locale@std@@CAPAV_Locimp@12@XZ:PROC	; std::locale::_Init
EXTRN	??_E?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??1_Mutex@std@@QAE@XZ:PROC			; std::_Mutex::~_Mutex
EXTRN	??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	_fputc:PROC
EXTRN	_ungetc:PROC
EXTRN	_fgetc:PROC
EXTRN	_fgetpos:PROC
EXTRN	_fsetpos:PROC
EXTRN	_fseek:PROC
EXTRN	_setvbuf:PROC
EXTRN	_fflush:PROC
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	_fclose:PROC
EXTRN	_fwrite:PROC
EXTRN	??_EFileInput@@UAEPAXI@Z:PROC			; FileInput::`vector deleting destructor'
EXTRN	_perror:PROC
EXTRN	?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z:PROC		; std::_Fiopen
EXTRN	??_Ecodecvt_base@std@@UAEPAXI@Z:PROC		; std::codecvt_base::`vector deleting destructor'
EXTRN	??_E?$codecvt@DDH@std@@MAEPAXI@Z:PROC		; std::codecvt<char,char,int>::`vector deleting destructor'
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	__Getctype:PROC
EXTRN	__Tolower:PROC
EXTRN	__Toupper:PROC
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	_free:PROC
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	?_BADOFF@std@@3JB:DWORD				; std::_BADOFF
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA DD 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
;	COMDAT ??_7?$codecvt@DDH@std@@6B@
CONST	SEGMENT
??_7?$codecvt@DDH@std@@6B@ DD FLAT:??_R4?$codecvt@DDH@std@@6B@ ; std::codecvt<char,char,int>::`vftable'
	DD	FLAT:??_E?$codecvt@DDH@std@@MAEPAXI@Z
	DD	FLAT:?do_always_noconv@codecvt_base@std@@MBE_NXZ
	DD	FLAT:?do_max_length@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_encoding@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
	DD	FLAT:?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
	DD	FLAT:?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z
	DD	FLAT:?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z
CONST	ENDS
;	COMDAT ??_R4?$codecvt@DDH@std@@6B@
rdata$r	SEGMENT
??_R4?$codecvt@DDH@std@@6B@ DD 00H			; std::codecvt<char,char,int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$codecvt@DDH@std@@@8
	DD	FLAT:??_R3?$codecvt@DDH@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$codecvt@DDH@std@@8
rdata$r	SEGMENT
??_R3?$codecvt@DDH@std@@8 DD 00H			; std::codecvt<char,char,int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$codecvt@DDH@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$codecvt@DDH@std@@8
rdata$r	SEGMENT
??_R2?$codecvt@DDH@std@@8 DD FLAT:??_R1A@?0A@EA@?$codecvt@DDH@std@@8 ; std::codecvt<char,char,int>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@codecvt_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$codecvt@DDH@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$codecvt@DDH@std@@8 DD FLAT:??_R0?AV?$codecvt@DDH@std@@@8 ; std::codecvt<char,char,int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$codecvt@DDH@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$codecvt@DDH@std@@@8
_DATA	SEGMENT
??_R0?AV?$codecvt@DDH@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::codecvt<char,char,int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$codecvt@DDH@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?_Do_widen_s@?$ctype@D@std@@MBEPBDPBD0PADI@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
	DD	FLAT:?_Do_narrow_s@?$ctype@D@std@@MBEPBDPBD0DPADI@Z
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7codecvt_base@std@@6B@
CONST	SEGMENT
??_7codecvt_base@std@@6B@ DD FLAT:??_R4codecvt_base@std@@6B@ ; std::codecvt_base::`vftable'
	DD	FLAT:??_Ecodecvt_base@std@@UAEPAXI@Z
	DD	FLAT:?do_always_noconv@codecvt_base@std@@MBE_NXZ
	DD	FLAT:?do_max_length@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_encoding@codecvt_base@std@@MBEHXZ
CONST	ENDS
;	COMDAT ??_R4codecvt_base@std@@6B@
rdata$r	SEGMENT
??_R4codecvt_base@std@@6B@ DD 00H			; std::codecvt_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVcodecvt_base@std@@@8
	DD	FLAT:??_R3codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3codecvt_base@std@@8
rdata$r	SEGMENT
??_R3codecvt_base@std@@8 DD 00H				; std::codecvt_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2codecvt_base@std@@8
rdata$r	SEGMENT
??_R2codecvt_base@std@@8 DD FLAT:??_R1A@?0A@EA@codecvt_base@std@@8 ; std::codecvt_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@codecvt_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@codecvt_base@std@@8 DD FLAT:??_R0?AVcodecvt_base@std@@@8 ; std::codecvt_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVcodecvt_base@std@@@8
_DATA	SEGMENT
??_R0?AVcodecvt_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::codecvt_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVcodecvt_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
	DD	058H
CONST	ENDS
;	COMDAT ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	058H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z
	DD	FLAT:?_Xsgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADIH@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z
	DD	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
	DD	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PADH@Z
	DD	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_istream<char,std::char_traits<char> >::`vbtable'
	DD	08H
CONST	ENDS
;	COMDAT ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	08H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z
	DD	FLAT:?_Xsgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADIH@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z
	DD	FLAT:?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
	DD	FLAT:?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ?_Stz@?$fpos@H@std@@0HB
CONST	SEGMENT
?_Stz@?$fpos@H@std@@0HB DD 00H				; std::fpos<int>::_Stz
CONST	ENDS
;	COMDAT ??_8FileInput@@7B@
CONST	SEGMENT
??_8FileInput@@7B@ DD 00H				; FileInput::`vbtable'
	DD	058H
CONST	ENDS
;	COMDAT ??_7FileInput@@6B@
CONST	SEGMENT
??_7FileInput@@6B@ DD FLAT:??_R4FileInput@@6B@		; FileInput::`vftable'
	DD	FLAT:??_EFileInput@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4FileInput@@6B@
rdata$r	SEGMENT
??_R4FileInput@@6B@ DD 00H				; FileInput::`RTTI Complete Object Locator'
	DD	058H
	DD	00H
	DD	FLAT:??_R0?AVFileInput@@@8
	DD	FLAT:??_R3FileInput@@8
rdata$r	ENDS
;	COMDAT ??_R3FileInput@@8
rdata$r	SEGMENT
??_R3FileInput@@8 DD 00H				; FileInput::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	06H
	DD	FLAT:??_R2FileInput@@8
rdata$r	ENDS
;	COMDAT ??_R2FileInput@@8
rdata$r	SEGMENT
??_R2FileInput@@8 DD FLAT:??_R1A@?0A@EA@FileInput@@8	; FileInput::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R13A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R13A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R13A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R13A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R13A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (4,0,4,64)'
	DD	00H
	DD	04H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@FileInput@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FileInput@@8 DD FLAT:??_R0?AVFileInput@@@8 ; FileInput::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FileInput@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFileInput@@@8
_DATA	SEGMENT
??_R0?AVFileInput@@@8 DD FLAT:??_7type_info@@6B@	; FileInput `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFileInput@@', 00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
;	COMDAT ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z
_TEXT	SEGMENT
__Gf$ = 8						; size = 4
__Gn$ = 12						; size = 4
__Gc$ = 16						; size = 4
__Pf$ = 20						; size = 4
__Pn$ = 24						; size = 4
__Pc$ = 28						; size = 4
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 291  : 		_IGfirst = _Gf, _IPfirst = _Pf;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Gf$[esp-4]
  00004	8b 54 24 10	 mov	 edx, DWORD PTR __Pf$[esp-4]
  00008	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 292  : 		_IGnext = _Gn, _IPnext = _Pn;

  0000b	8b 44 24 08	 mov	 eax, DWORD PTR __Gn$[esp-4]
  0000f	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  00012	8b 54 24 14	 mov	 edx, DWORD PTR __Pn$[esp-4]
  00016	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 293  : 		_IGcount = _Gc, _IPcount = _Pc;

  00019	8b 44 24 0c	 mov	 eax, DWORD PTR __Gc$[esp-4]
  0001d	89 51 24	 mov	 DWORD PTR [ecx+36], edx
  00020	8b 54 24 18	 mov	 edx, DWORD PTR __Pc$[esp-4]
  00024	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  00027	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 294  : 		}

  0002a	c2 18 00	 ret	 24			; 00000018H
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Init
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Next$ = 12						; size = 4
__Last$ = 16						; size = 4
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setg, COMDAT
; _this$ = ecx

; 216  : 		*_IGfirst = _First;

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	8b 54 24 04	 mov	 edx, DWORD PTR __First$[esp-4]
  00007	89 10		 mov	 DWORD PTR [eax], edx

; 217  : 		*_IGnext = _Next;

  00009	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0000c	8b 44 24 08	 mov	 eax, DWORD PTR __Next$[esp-4]
  00010	89 02		 mov	 DWORD PTR [edx], eax

; 218  : 		*_IGcount = (int)(_Last - _Next);

  00012	8b 54 24 0c	 mov	 edx, DWORD PTR __Last$[esp-4]
  00016	2b d0		 sub	 edx, eax
  00018	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0001b	89 10		 mov	 DWORD PTR [eax], edx

; 219  : 		}

  0001d	c2 0c 00	 ret	 12			; 0000000cH
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setg
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setp, COMDAT
; _this$ = ecx

; 257  : 		*_IPfirst = _First;

  00000	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00007	89 02		 mov	 DWORD PTR [edx], eax

; 258  : 		*_IPnext = _First;

  00009	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0000c	89 02		 mov	 DWORD PTR [edx], eax

; 259  : 		*_IPcount = (int)(_Last - _First);

  0000e	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00012	2b d0		 sub	 edx, eax
  00014	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00017	89 10		 mov	 DWORD PTR [eax], edx

; 260  : 		}

  00019	c2 08 00	 ret	 8
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setp
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Iterator_base_secure@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iterator_base_secure@std@@QAE@XZ PROC		; std::_Iterator_base_secure::_Iterator_base_secure, COMDAT
; _this$ = ecx

; 567  : 		{

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 568  : 		}

  00008	c3		 ret	 0
??0_Iterator_base_secure@std@@QAE@XZ ENDP		; std::_Iterator_base_secure::_Iterator_base_secure
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Has_container@_Iterator_base_secure@std@@QBE_NXZ
_TEXT	SEGMENT
?_Has_container@_Iterator_base_secure@std@@QBE_NXZ PROC	; std::_Iterator_base_secure::_Has_container, COMDAT
; _this$ = ecx

; 582  : 		return _Mycont != 0;

  00000	33 c0		 xor	 eax, eax
  00002	39 01		 cmp	 DWORD PTR [ecx], eax
  00004	0f 95 c0	 setne	 al

; 583  : 		}

  00007	c3		 ret	 0
?_Has_container@_Iterator_base_secure@std@@QBE_NXZ ENDP	; std::_Iterator_base_secure::_Has_container
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__First2$ = 12						; size = 4
__Last2$ = 16						; size = 4
__Mid2$ = 20						; size = 4
?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z PROC	; std::codecvt<char,char,int>::unshift, COMDAT
; _this$ = ecx

; 756  : 		return (do_unshift(_State, _First2, _Last2, _Mid2));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00005	ff e0		 jmp	 eax
?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z ENDP	; std::codecvt<char,char,int>::unshift
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First2$ = 12						; size = 4
___formal$ = 16						; size = 4
__Mid2$ = 20						; size = 4
?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z PROC	; std::codecvt<char,char,int>::do_unshift, COMDAT
; _this$ = ecx

; 819  : 		_Mid2 = _First2;

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Mid2$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __First2$[esp-4]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 820  : 		return (noconv);	// convert nothing

  0000a	b8 03 00 00 00	 mov	 eax, 3

; 821  : 		}

  0000f	c2 10 00	 ret	 16			; 00000010H
?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z ENDP	; std::codecvt<char,char,int>::do_unshift
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\fstream
_TEXT	ENDS
;	COMDAT ??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
__File$ = 12						; size = 4
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z PROC		; std::_Fputc<char>, COMDAT

; 67   : 	return (fputc(_Byte, _File) != EOF);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __File$[esp-4]
  00004	0f be 4c 24 04	 movsx	 ecx, BYTE PTR __Byte$[esp-4]
  00009	50		 push	 eax
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _fputc
  00010	33 d2		 xor	 edx, edx
  00012	83 c4 08	 add	 esp, 8
  00015	83 f8 ff	 cmp	 eax, -1
  00018	0f 95 c2	 setne	 dl
  0001b	8a c2		 mov	 al, dl

; 68   : 	}

  0001d	c3		 ret	 0
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z ENDP		; std::_Fputc<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
__Last2$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC ; std::codecvt<char,char,int>::out, COMDAT
; _this$ = ecx

; 749  : 		return (do_out(_State,
; 750  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00005	ff e0		 jmp	 eax
?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP ; std::codecvt<char,char,int>::out
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
___formal$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
___formal$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC ; std::codecvt<char,char,int>::do_out, COMDAT
; _this$ = ecx

; 812  : 		_Mid1 = _First1, _Mid2 = _First2;

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Mid1$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __First1$[esp-4]
  00008	8b 54 24 1c	 mov	 edx, DWORD PTR __Mid2$[esp-4]
  0000c	89 08		 mov	 DWORD PTR [eax], ecx
  0000e	8b 44 24 14	 mov	 eax, DWORD PTR __First2$[esp-4]
  00012	89 02		 mov	 DWORD PTR [edx], eax

; 813  : 		return (noconv);	// convert nothing

  00014	b8 03 00 00 00	 mov	 eax, 3

; 814  : 		}

  00019	c2 1c 00	 ret	 28			; 0000001cH
?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP ; std::codecvt<char,char,int>::do_out
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT

; 501  : 		return ((_Elem)_Meta);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Meta$[esp-4]
  00004	8a 00		 mov	 al, BYTE PTR [eax]

; 502  : 		}

  00006	c3		 ret	 0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::epptr, COMDAT
; _this$ = ecx

; 223  : 		return (*_IPnext + *_IPcount);

  00000	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00003	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	03 01		 add	 eax, DWORD PTR [ecx]

; 224  : 		}

  0000a	c3		 ret	 0
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::epptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pptr, COMDAT
; _this$ = ecx

; 200  : 		return (*_IPnext);

  00000	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 201  : 		}

  00005	c3		 ret	 0
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 414  : 		}

  00000	c2 04 00	 ret	 4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::imbue
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 409  : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 410  : 		}

  00002	c3		 ret	 0
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sync
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 403  : 		{	// offer buffer to external agent (do nothing)

  00000	8b c1		 mov	 eax, ecx

; 404  : 		return (this);
; 405  : 		}

  00002	c2 08 00	 ret	 8
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@J@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??0?$fpos@H@std@@QAE@J@Z PROC				; std::fpos<int>::fpos<int>, COMDAT
; _this$ = ecx

; 54   : 		{	// construct with stream offset

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
  00008	33 c9		 xor	 ecx, ecx
  0000a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00010	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 55   : 		}

  00013	c2 04 00	 ret	 4
??0?$fpos@H@std@@QAE@J@Z ENDP				; std::fpos<int>::fpos<int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 393  : 		return (streampos(_BADOFF));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00004	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3JB ; std::_BADOFF
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	33 c9		 xor	 ecx, ecx
  0000e	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00011	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00014	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 394  : 		}

  00017	c2 10 00	 ret	 16			; 00000010H
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbump, COMDAT
; _this$ = ecx

; 251  : 		*_IPcount -= _Off;

  00000	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00003	8b 54 24 04	 mov	 edx, DWORD PTR __Off$[esp-4]
  00007	29 10		 sub	 DWORD PTR [eax], edx

; 252  : 		*_IPnext += _Off;

  00009	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  0000c	01 11		 add	 DWORD PTR [ecx], edx

; 253  : 		}

  0000e	c2 04 00	 ret	 4
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbump
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc, COMDAT
; _this$ = ecx

; 234  : 		--*_IGcount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 235  : 		return ((*_IGnext)++);

  00005	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00008	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000d	89 11		 mov	 DWORD PTR [ecx], edx

; 236  : 		}

  0000f	c3		 ret	 0
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::gbump, COMDAT
; _this$ = ecx

; 210  : 		*_IGcount -= _Off;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	8b 54 24 04	 mov	 edx, DWORD PTR __Off$[esp-4]
  00007	29 10		 sub	 DWORD PTR [eax], edx

; 211  : 		*_IGnext += _Off;

  00009	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0000c	01 11		 add	 DWORD PTR [ecx], edx

; 212  : 		}

  0000e	c2 04 00	 ret	 4
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gbump
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::gptr, COMDAT
; _this$ = ecx

; 190  : 		return (*_IGnext);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 191  : 		}

  00005	c3		 ret	 0
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ
_TEXT	SEGMENT
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail, COMDAT
; _this$ = ecx

; 246  : 		return (*_IGnext != 0 ? *_IGcount : 0);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 06		 je	 SHORT $LN3@Gnavail
  00008	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  0000b	8b 01		 mov	 eax, DWORD PTR [ecx]

; 247  : 		}

  0000d	c3		 ret	 0
$LN3@Gnavail:

; 246  : 		return (*_IGnext != 0 ? *_IGcount : 0);

  0000e	33 c0		 xor	 eax, eax

; 247  : 		}

  00010	c3		 ret	 0
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn, COMDAT
; _this$ = ecx

; 326  : 		// assume the destination buffer is large enough
; 327  : 		return _Xsgetn_s(_Ptr, (size_t)-1, _Count);

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Count$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]
  00006	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00009	52		 push	 edx
  0000a	8b 54 24 08	 mov	 edx, DWORD PTR __Ptr$[esp]
  0000e	6a ff		 push	 -1
  00010	52		 push	 edx
  00011	ff d0		 call	 eax

; 328  : 		}

  00013	c2 08 00	 ret	 8
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc, COMDAT
; _this$ = ecx

; 308  : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 309  : 		}

  00002	c3		 ret	 0
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z PROC	; std::codecvt<char,char,int>::_Init, COMDAT
; _this$ = ecx

; 798  : 		}

  00000	c2 04 00	 ret	 4
?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z ENDP	; std::codecvt<char,char,int>::_Init
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Count$ = 20						; size = 4
?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z PROC	; std::codecvt<char,char,int>::do_length, COMDAT
; _this$ = ecx

; 826  : 		return ((int)(_Count < (size_t)(_Last1 - _First1)
; 827  : 			? _Count : _Last1 - _First1));	// assume 1-to-1 conversion

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Last1$[esp-4]
  00004	2b 44 24 08	 sub	 eax, DWORD PTR __First1$[esp-4]
  00008	8b 4c 24 10	 mov	 ecx, DWORD PTR __Count$[esp-4]
  0000c	3b c8		 cmp	 ecx, eax
  0000e	73 02		 jae	 SHORT $LN4@do_length
  00010	8b c1		 mov	 eax, ecx
$LN4@do_length:

; 828  : 		}

  00012	c2 10 00	 ret	 16			; 00000010H
?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z ENDP	; std::codecvt<char,char,int>::do_length
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
___formal$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
___formal$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC ; std::codecvt<char,char,int>::do_in, COMDAT
; _this$ = ecx

; 804  : 		_Mid1 = _First1, _Mid2 = _First2;

  00000	8b 44 24 10	 mov	 eax, DWORD PTR __Mid1$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __First1$[esp-4]
  00008	8b 54 24 1c	 mov	 edx, DWORD PTR __Mid2$[esp-4]
  0000c	89 08		 mov	 DWORD PTR [eax], ecx
  0000e	8b 44 24 14	 mov	 eax, DWORD PTR __First2$[esp-4]
  00012	89 02		 mov	 DWORD PTR [edx], eax

; 805  : 		return (noconv);	// convert nothing

  00014	b8 03 00 00 00	 mov	 eax, 3

; 806  : 		}

  00019	c2 1c 00	 ret	 28			; 0000001cH
?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP ; std::codecvt<char,char,int>::do_in
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_encoding@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT
?do_encoding@codecvt_base@std@@MBEHXZ PROC		; std::codecvt_base::do_encoding, COMDAT
; _this$ = ecx

; 720  : 		return (1);	// -1 ==> state dependent, 0 ==> varying length

  00000	b8 01 00 00 00	 mov	 eax, 1

; 721  : 		}

  00005	c3		 ret	 0
?do_encoding@codecvt_base@std@@MBEHXZ ENDP		; std::codecvt_base::do_encoding
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_max_length@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT
?do_max_length@codecvt_base@std@@MBEHXZ PROC		; std::codecvt_base::do_max_length, COMDAT
; _this$ = ecx

; 715  : 		return (1);

  00000	b8 01 00 00 00	 mov	 eax, 1

; 716  : 		}

  00005	c3		 ret	 0
?do_max_length@codecvt_base@std@@MBEHXZ ENDP		; std::codecvt_base::do_max_length
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_always_noconv@codecvt_base@std@@MBE_NXZ
_TEXT	SEGMENT
?do_always_noconv@codecvt_base@std@@MBE_NXZ PROC	; std::codecvt_base::do_always_noconv, COMDAT
; _this$ = ecx

; 710  : 		return (true);

  00000	b0 01		 mov	 al, 1

; 711  : 		}

  00002	c3		 ret	 0
?do_always_noconv@codecvt_base@std@@MBE_NXZ ENDP	; std::codecvt_base::do_always_noconv
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?always_noconv@codecvt_base@std@@QBE_NXZ
_TEXT	SEGMENT
?always_noconv@codecvt_base@std@@QBE_NXZ PROC		; std::codecvt_base::always_noconv, COMDAT
; _this$ = ecx

; 690  : 		return (do_always_noconv());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00005	ff e2		 jmp	 edx
?always_noconv@codecvt_base@std@@QBE_NXZ ENDP		; std::codecvt_base::always_noconv
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@H_J@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Fileposition$ = 12					; size = 8
??0?$fpos@H@std@@QAE@H_J@Z PROC				; std::fpos<int>::fpos<int>, COMDAT
; _this$ = ecx

; 59   : 		{	// construct with conversion state and C file position

  00000	8b 54 24 0c	 mov	 edx, DWORD PTR __Fileposition$[esp]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 08	 mov	 ecx, DWORD PTR __Fileposition$[esp-4]
  0000a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000d	8b 4c 24 04	 mov	 ecx, DWORD PTR __State$[esp-4]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00017	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0001a	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 60   : 		}

  0001d	c2 0c 00	 ret	 12			; 0000000cH
??0?$fpos@H@std@@QAE@H_J@Z ENDP				; std::fpos<int>::fpos<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@std@@QBEHXZ
_TEXT	SEGMENT
?state@?$fpos@H@std@@QBEHXZ PROC			; std::fpos<int>::state, COMDAT
; _this$ = ecx

; 64   : 		return (_Mystate);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 65   : 		}

  00003	c3		 ret	 0
?state@?$fpos@H@std@@QBEHXZ ENDP			; std::fpos<int>::state
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@std@@QBEJXZ
_TEXT	SEGMENT
??B?$fpos@H@std@@QBEJXZ PROC				; std::fpos<int>::operator long, COMDAT
; _this$ = ecx

; 79   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	03 01		 add	 eax, DWORD PTR [ecx]

; 80   : 		}

  00005	c3		 ret	 0
??B?$fpos@H@std@@QBEJXZ ENDP				; std::fpos<int>::operator long
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?seekpos@?$fpos@H@std@@QBE_JXZ
_TEXT	SEGMENT
?seekpos@?$fpos@H@std@@QBE_JXZ PROC			; std::fpos<int>::seekpos, COMDAT
; _this$ = ecx

; 74   : 		return (_Fpos);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]

; 75   : 		}

  00006	c3		 ret	 0
?seekpos@?$fpos@H@std@@QBE_JXZ ENDP			; std::fpos<int>::seekpos
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
__Last2$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC	; std::codecvt<char,char,int>::in, COMDAT
; _this$ = ecx

; 741  : 		return (do_in(_State,
; 742  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00005	ff e0		 jmp	 eax
?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP	; std::codecvt<char,char,int>::in
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\fstream
_TEXT	ENDS
;	COMDAT ??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 4
__File$ = 12						; size = 4
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z PROC		; std::_Fgetc<char>, COMDAT

; 35   : 	int _Meta;
; 36   : 	if ((_Meta = fgetc(_File)) == EOF)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __File$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 _fgetc
  0000a	83 c4 04	 add	 esp, 4
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	75 03		 jne	 SHORT $LN2@Fgetc

; 37   : 		return (false);

  00012	32 c0		 xor	 al, al

; 42   : 		}
; 43   : 	}

  00014	c3		 ret	 0
$LN2@Fgetc:

; 38   : 	else
; 39   : 		{	// got one, convert to char
; 40   : 		_Byte = (char)_Meta;

  00015	8b 4c 24 04	 mov	 ecx, DWORD PTR __Byte$[esp-4]
  00019	88 01		 mov	 BYTE PTR [ecx], al

; 41   : 		return (true);

  0001b	b0 01		 mov	 al, 1

; 42   : 		}
; 43   : 	}

  0001d	c3		 ret	 0
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z ENDP		; std::_Fgetc<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::egptr, COMDAT
; _this$ = ecx

; 205  : 		return (*_IGnext + *_IGcount);

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	03 01		 add	 eax, DWORD PTR [ecx]

; 206  : 		}

  0000a	c3		 ret	 0
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::egptr
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\fstream
_TEXT	ENDS
;	COMDAT ??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 4
__File$ = 12						; size = 4
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z PROC		; std::_Ungetc<char>, COMDAT

; 85   : 	return (ungetc((unsigned char)_Byte, _File) != EOF);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __Byte$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __File$[esp-4]
  00008	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0000b	50		 push	 eax
  0000c	52		 push	 edx
  0000d	e8 00 00 00 00	 call	 _ungetc
  00012	33 c9		 xor	 ecx, ecx
  00014	83 c4 08	 add	 esp, 8
  00017	83 f8 ff	 cmp	 eax, -1
  0001a	0f 95 c1	 setne	 cl
  0001d	8a c1		 mov	 al, cl

; 86   : 	}

  0001f	c3		 ret	 0
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z ENDP		; std::_Ungetc<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gndec, COMDAT
; _this$ = ecx

; 228  : 		++*_IGcount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	ff 00		 inc	 DWORD PTR [eax]

; 229  : 		return (--*_IGnext);

  00005	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00008	ff 08		 dec	 DWORD PTR [eax]
  0000a	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]

; 230  : 		}

  0000f	c3		 ret	 0
?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gndec
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::eback, COMDAT
; _this$ = ecx

; 185  : 		return (*_IGfirst);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 186  : 		}

  00005	c3		 ret	 0
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::eback
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\istream
_TEXT	ENDS
;	COMDAT ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 42   : 		{	// destroy the object

  00000	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00003	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00006	c7 44 0a f8 00
	00 00 00	 mov	 DWORD PTR [edx+ecx-8], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@

; 43   : 		}

  0000e	c3		 ret	 0
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ??0ios_base@std@@IAE@XZ
_TEXT	SEGMENT
??0ios_base@std@@IAE@XZ PROC				; std::ios_base::ios_base, COMDAT
; _this$ = ecx

; 510  : 	__CLR_OR_THIS_CALL ios_base()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@

; 511  : 		{	// default constructor
; 512  : 		}

  00008	c3		 ret	 0
??0ios_base@std@@IAE@XZ ENDP				; std::ios_base::ios_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT
?is@?$ctype@D@std@@QBE_NFD@Z PROC			; std::ctype<char>::is, COMDAT
; _this$ = ecx
; __Ch$ = eax

; 1663 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);

  00000	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00003	0f b6 c0	 movzx	 eax, al
  00006	f6 04 42 48	 test	 BYTE PTR [edx+eax*2], 72 ; 00000048H
  0000a	b8 00 00 00 00	 mov	 eax, 0
  0000f	0f 95 c0	 setne	 al

; 1664 : 		}

  00012	c3		 ret	 0
?is@?$ctype@D@std@@QBE_NFD@Z ENDP			; std::ctype<char>::is
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc, COMDAT
; _this$ = eax

; 240  : 		--*_IGcount;

  00000	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00003	ff 09		 dec	 DWORD PTR [ecx]

; 241  : 		return (++(*_IGnext));

  00005	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00008	ff 01		 inc	 DWORD PTR [ecx]
  0000a	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]

; 242  : 		}

  0000f	c3		 ret	 0
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocinfo
_TEXT	ENDS
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T50191 = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 123  : 		{	// return ctype stuff

  00000	83 ec 10	 sub	 esp, 16			; 00000010H

; 124  : 		return (::_Getctype());

  00003	8d 04 24	 lea	 eax, DWORD PTR $T50191[esp+16]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 __Getctype
  0000c	8b 4c 24 18	 mov	 ecx, DWORD PTR ___$ReturnUdt$[esp+16]
  00010	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00014	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00018	f3 0f 7e 40 08	 movq	 xmm0, QWORD PTR [eax+8]
  0001d	66 0f d6 41 08	 movq	 QWORD PTR [ecx+8], xmm0
  00022	8b c1		 mov	 eax, ecx

; 125  : 		}

  00024	83 c4 14	 add	 esp, 20			; 00000014H
  00027	c2 04 00	 ret	 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ?_Do_narrow_s@?$ctype@D@std@@MBEPBDPBD0DPADI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
__Dest_size$ = 24					; size = 4
?_Do_narrow_s@?$ctype@D@std@@MBEPBDPBD0DPADI@Z PROC	; std::ctype<char>::_Do_narrow_s, COMDAT
; _this$ = ecx

; 1887 : 		{	// narrow elements in [_First, _Last) to chars

  00000	53		 push	 ebx

; 1888 : 		_DEBUG_RANGE(_First, _Last);
; 1889 : 		_DEBUG_POINTER(_Dest);
; 1890 : 		_SCL_SECURE_ALWAYS_VALIDATE_RANGE(_Dest_size >= (size_t)(_Last - _First));

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR __First$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 1c	 mov	 ebp, DWORD PTR __Dest_size$[esp+4]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7c 24 18	 mov	 edi, DWORD PTR __Last$[esp+12]
  00010	8b f7		 mov	 esi, edi
  00012	2b f3		 sub	 esi, ebx
  00014	3b ee		 cmp	 ebp, esi
  00016	73 05		 jae	 SHORT $LN1@Do_narrow_
  00018	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1@Do_narrow_:

; 1891 : 		_CRT_SECURE_MEMCPY(_Dest, _Dest_size, _First, _Last - _First);

  0001d	8b 44 24 20	 mov	 eax, DWORD PTR __Dest$[esp+12]
  00021	56		 push	 esi
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _memcpy_s
  0002a	83 c4 10	 add	 esp, 16			; 00000010H

; 1892 : 		return (_Last);

  0002d	8b c7		 mov	 eax, edi
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5d		 pop	 ebp
  00032	5b		 pop	 ebx

; 1893 : 		}

  00033	c2 14 00	 ret	 20			; 00000014H
?_Do_narrow_s@?$ctype@D@std@@MBEPBDPBD0DPADI@Z ENDP	; std::ctype<char>::_Do_narrow_s
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 1872 : 		return (_Ch);

  00000	8a 44 24 04	 mov	 al, BYTE PTR __Ch$[esp-4]

; 1873 : 		}

  00004	c2 08 00	 ret	 8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dflt$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 1880 : 		// assume there is enough space in _Dest
; 1881 : 		return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR __First$[esp-4]
  00008	56		 push	 esi
  00009	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000b	57		 push	 edi
  0000c	8b f8		 mov	 edi, eax
  0000e	2b fa		 sub	 edi, edx
  00010	57		 push	 edi
  00011	8b 7c 24 1c	 mov	 edi, DWORD PTR __Dest$[esp+8]
  00015	57		 push	 edi
  00016	8b 7c 24 1c	 mov	 edi, DWORD PTR __Dflt$[esp+12]
  0001a	57		 push	 edi
  0001b	50		 push	 eax
  0001c	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0001f	52		 push	 edx
  00020	ff d0		 call	 eax
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 1882 : 		}

  00024	c2 10 00	 ret	 16			; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Do_widen_s@?$ctype@D@std@@MBEPBDPBD0PADI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Dest_size$ = 20					; size = 4
?_Do_widen_s@?$ctype@D@std@@MBEPBDPBD0PADI@Z PROC	; std::ctype<char>::_Do_widen_s, COMDAT
; _this$ = ecx

; 1862 : 		{	// widen chars in [_First, _Last)

  00000	53		 push	 ebx

; 1863 : 		_DEBUG_RANGE(_First, _Last);
; 1864 : 		_DEBUG_POINTER(_Dest);
; 1865 : 		_SCL_SECURE_ALWAYS_VALIDATE_RANGE(_Dest_size >= (size_t)(_Last - _First));

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR __First$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 18	 mov	 ebp, DWORD PTR __Dest_size$[esp+4]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7c 24 18	 mov	 edi, DWORD PTR __Last$[esp+12]
  00010	8b f7		 mov	 esi, edi
  00012	2b f3		 sub	 esi, ebx
  00014	3b ee		 cmp	 ebp, esi
  00016	73 05		 jae	 SHORT $LN1@Do_widen_s
  00018	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1@Do_widen_s:

; 1866 : 		_CRT_SECURE_MEMCPY(_Dest, _Dest_size, _First, _Last - _First);

  0001d	8b 44 24 1c	 mov	 eax, DWORD PTR __Dest$[esp+12]
  00021	56		 push	 esi
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _memcpy_s
  0002a	83 c4 10	 add	 esp, 16			; 00000010H

; 1867 : 		return (_Last);

  0002d	8b c7		 mov	 eax, edi
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5d		 pop	 ebp
  00032	5b		 pop	 ebx

; 1868 : 		}

  00033	c2 10 00	 ret	 16			; 00000010H
?_Do_widen_s@?$ctype@D@std@@MBEPBDPBD0PADI@Z ENDP	; std::ctype<char>::_Do_widen_s
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 1849 : 		return (_Byte);

  00000	8a 44 24 04	 mov	 al, BYTE PTR __Byte$[esp-4]

; 1850 : 		}

  00004	c2 04 00	 ret	 4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 1856 : 		// assume there is enough space in _Dest
; 1857 : 		return _Do_widen_s(_First, _Last, _Dest, _Last - _First);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR __First$[esp-4]
  00008	56		 push	 esi
  00009	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000b	57		 push	 edi
  0000c	8b f8		 mov	 edi, eax
  0000e	2b fa		 sub	 edi, edx
  00010	57		 push	 edi
  00011	8b 7c 24 18	 mov	 edi, DWORD PTR __Dest$[esp+8]
  00015	57		 push	 edi
  00016	50		 push	 eax
  00017	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0001a	52		 push	 edx
  0001b	ff d0		 call	 eax
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi

; 1858 : 		}

  0001f	c2 0c 00	 ret	 12			; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 1835 : 		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));

  00000	0f b6 44 24 04	 movzx	 eax, BYTE PTR __Ch$[esp-4]
  00005	83 c1 08	 add	 ecx, 8
  00008	51		 push	 ecx
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __Toupper
  0000f	83 c4 08	 add	 esp, 8

; 1836 : 		}

  00012	c2 04 00	 ret	 4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 1840 : 		{	// convert [_First, _Last) in place to upper case

  00000	53		 push	 ebx

; 1841 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 1842 : 		for (; _First != _Last; ++_First)

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR __Last$[esp]
  00005	56		 push	 esi
  00006	8b 74 24 0c	 mov	 esi, DWORD PTR __First$[esp+4]
  0000a	3b f3		 cmp	 esi, ebx
  0000c	74 19		 je	 SHORT $LN8@do_toupper
  0000e	57		 push	 edi
  0000f	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]
$LL3@do_toupper:

; 1843 : 			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);

  00012	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00015	57		 push	 edi
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __Toupper
  0001c	88 06		 mov	 BYTE PTR [esi], al
  0001e	46		 inc	 esi
  0001f	83 c4 08	 add	 esp, 8
  00022	3b f3		 cmp	 esi, ebx
  00024	75 ec		 jne	 SHORT $LL3@do_toupper
  00026	5f		 pop	 edi
$LN8@do_toupper:

; 1844 : 		return ((const _Elem *)_First);

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx

; 1845 : 		}

  0002b	c2 08 00	 ret	 8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 1821 : 		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));

  00000	0f b6 44 24 04	 movzx	 eax, BYTE PTR __Ch$[esp-4]
  00005	83 c1 08	 add	 ecx, 8
  00008	51		 push	 ecx
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __Tolower
  0000f	83 c4 08	 add	 esp, 8

; 1822 : 		}

  00012	c2 04 00	 ret	 4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 1826 : 		{	// convert [_First, _Last) in place to lower case

  00000	53		 push	 ebx

; 1827 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 1828 : 		for (; _First != _Last; ++_First)

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR __Last$[esp]
  00005	56		 push	 esi
  00006	8b 74 24 0c	 mov	 esi, DWORD PTR __First$[esp+4]
  0000a	3b f3		 cmp	 esi, ebx
  0000c	74 19		 je	 SHORT $LN8@do_tolower
  0000e	57		 push	 edi
  0000f	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]
$LL3@do_tolower:

; 1829 : 			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);

  00012	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00015	57		 push	 edi
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __Tolower
  0001c	88 06		 mov	 BYTE PTR [esi], al
  0001e	46		 inc	 esi
  0001f	83 c4 08	 add	 esp, 8
  00022	3b f3		 cmp	 esi, ebx
  00024	75 ec		 jne	 SHORT $LL3@do_tolower
  00026	5f		 pop	 edi
$LN8@do_tolower:

; 1830 : 		return ((const _Elem *)_First);

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx

; 1831 : 		}

  0002b	c2 08 00	 ret	 8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 1813 : 		if (0 < _Ctype._Delfl)

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	85 c0		 test	 eax, eax
  00005	7e 0d		 jle	 SHORT $LN6@Tidy@4

; 1814 : 			free((void *)_Ctype._Table);

  00007	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _free
  00010	83 c4 04	 add	 esp, 4

; 1817 : 		}

  00013	c3		 ret	 0
$LN6@Tidy@4:

; 1815 : 		else if (_Ctype._Delfl < 0)

  00014	7d 0a		 jge	 SHORT $LN1@Tidy@4

; 1816 : 			delete[] (void *)_Ctype._Table;

  00016	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0001f	59		 pop	 ecx
$LN1@Tidy@4:

; 1817 : 		}

  00020	c3		 ret	 0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\istream
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = eax

; 81   : 			return (_Ok);

  00000	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 82   : 			}

  00003	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ?widen@?$ctype@D@std@@QBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?widen@?$ctype@D@std@@QBEDD@Z PROC			; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 1716 : 		return (do_widen(_Byte));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00005	ff e0		 jmp	 eax
?widen@?$ctype@D@std@@QBEDD@Z ENDP			; std::ctype<char>::widen
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?_Sgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPADIH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Sgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPADIH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Sgetn_s, COMDAT
; _this$ = ecx
; __Count$ = edx

; 117  : 		return _Xsgetn_s(_Ptr, _Ptr_size, _Count);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00005	52		 push	 edx
  00006	8b 54 24 08	 mov	 edx, DWORD PTR __Ptr$[esp]
  0000a	6a ff		 push	 -1
  0000c	52		 push	 edx
  0000d	ff d0		 call	 eax

; 118  : 		}

  0000f	c2 04 00	 ret	 4
?_Sgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPADIH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Sgetn_s
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pubseekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?pubseekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@H@2@JHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubseekoff, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi
; __Way$ = edx

; 53   : 		return (seekoff(_Off, _Way, _Mode));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00005	6a 01		 push	 1
  00007	52		 push	 edx
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Off$[esp+4]
  0000c	52		 push	 edx
  0000d	56		 push	 esi
  0000e	ff d0		 call	 eax
  00010	8b c6		 mov	 eax, esi

; 54   : 		}

  00012	c2 04 00	 ret	 4
?pubseekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@H@2@JHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubseekoff
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 282  : 		_IGfirst = &_Gfirst, _IPfirst = &_Pfirst;
; 283  : 		_IGnext = &_Gnext, _IPnext = &_Pnext;

  00000	8d 51 18	 lea	 edx, DWORD PTR [ecx+24]
  00003	89 51 20	 mov	 DWORD PTR [ecx+32], edx
  00006	8d 51 1c	 lea	 edx, DWORD PTR [ecx+28]
  00009	89 51 24	 mov	 DWORD PTR [ecx+36], edx
  0000c	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  0000f	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 284  : 		_IGcount = &_Gcount, _IPcount = &_Pcount;

  00012	8d 51 28	 lea	 edx, DWORD PTR [ecx+40]
  00015	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  00018	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  0001b	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0001e	8d 51 2c	 lea	 edx, DWORD PTR [ecx+44]
  00021	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 285  : 		setp(0, 0), setg(0, 0, 0);

  00024	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002a	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00033	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00036	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0003c	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00045	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00048	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0004e	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 286  : 		}

  00057	c3		 ret	 0
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Init
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit_base@DHPBDABDV_Iterator_base_secure@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit_base@DHPBDABDV_Iterator_base_secure@std@@@std@@QAE@XZ PROC ; std::_Ranit_base<char,int,char const *,char const &,std::_Iterator_base_secure>::_Ranit_base<char,int,char const *,char const &,std::_Iterator_base_secure>, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00008	c3		 ret	 0
??0?$_Ranit_base@DHPBDABDV_Iterator_base_secure@std@@@std@@QAE@XZ ENDP ; std::_Ranit_base<char,int,char const *,char const &,std::_Iterator_base_secure>::_Ranit_base<char,int,char const *,char const &,std::_Iterator_base_secure>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??D?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ PROC ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*, COMDAT
; _this$ = ecx

; 104  : 		{	// return designated object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 105  : 
; 106  :  #if _HAS_ITERATOR_DEBUGGING
; 107  : 		if (this->_Mycont == 0 || _Myptr == 0
; 108  : 			|| _Myptr < ((_Mystring *)this->_Mycont)->_Myptr()
; 109  : 			|| ((_Mystring *)this->_Mycont)->_Myptr()
; 110  : 				+ ((_Mystring *)this->_Mycont)->_Mysize <= _Myptr)
; 111  : 			{
; 112  : 			_DEBUG_ERROR("string iterator not dereferencable");
; 113  : 			_SCL_SECURE_OUT_OF_RANGE;
; 114  : 			}
; 115  : 		__analysis_assume(_Myptr != 0);
; 116  :  #else
; 117  : 		if (this->_Mycont != _IGNORE_MYCONT)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	83 f8 fc	 cmp	 eax, -4			; fffffffcH
  00008	74 28		 je	 SHORT $LN13@operator@16

; 118  : 		{
; 119  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

  0000a	85 c0		 test	 eax, eax
  0000c	75 05		 jne	 SHORT $LN2@operator@16
  0000e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN2@operator@16:

; 120  : 			_SCL_SECURE_VALIDATE_RANGE(_Myptr < (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)(this->_Mycont))->_Mysize));

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00019	72 05		 jb	 SHORT $LN10@operator@16
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	eb 03		 jmp	 SHORT $LN11@operator@16
$LN10@operator@16:
  00020	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
$LN11@operator@16:
  00023	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00026	03 c1		 add	 eax, ecx
  00028	39 46 04	 cmp	 DWORD PTR [esi+4], eax
  0002b	72 05		 jb	 SHORT $LN13@operator@16
  0002d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN13@operator@16:

; 121  : 		}
; 122  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 123  : 
; 124  : 		return (*_Myptr);

  00032	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00035	5e		 pop	 esi

; 125  : 		}

  00036	c3		 ret	 0
??D?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?not_eof@?$char_traits@D@std@@SAHABH@Z PROC		; std::char_traits<char>::not_eof, COMDAT

; 522  : 		return (_Meta != eof() ? _Meta : !eof());

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Meta$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8b c1		 mov	 eax, ecx
  00008	40		 inc	 eax
  00009	f7 d8		 neg	 eax
  0000b	1b c0		 sbb	 eax, eax
  0000d	23 c1		 and	 eax, ecx

; 523  : 		}

  0000f	c3		 ret	 0
?not_eof@?$char_traits@D@std@@SAHABH@Z ENDP		; std::char_traits<char>::not_eof
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 399  : 		return (streampos(_BADOFF));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00004	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3JB ; std::_BADOFF
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	33 c9		 xor	 ecx, ecx
  0000e	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00011	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00014	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 400  : 		}

  00017	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 298  : 		return (_Traits::eof());

  00000	83 c8 ff	 or	 eax, -1

; 299  : 		}

  00003	c2 04 00	 ret	 4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::overflow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 317  : 		{	// get a character from stream, point past it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 318  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())
; 319  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00008	ff d2		 call	 edx
  0000a	83 f8 ff	 cmp	 eax, -1
  0000d	75 04		 jne	 SHORT $LN3@uflow
  0000f	0b c0		 or	 eax, eax
  00011	5e		 pop	 esi

; 320  : 		}

  00012	c3		 ret	 0
$LN3@uflow:

; 318  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())
; 319  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));

  00013	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00016	ff 08		 dec	 DWORD PTR [eax]
  00018	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00020	89 10		 mov	 DWORD PTR [eax], edx
  00022	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00025	5e		 pop	 esi

; 320  : 		}

  00026	c3		 ret	 0
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::uflow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 313  : 		return (_Traits::eof());

  00000	83 c8 ff	 or	 eax, -1

; 314  : 		}

  00003	c3		 ret	 0
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::underflow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 303  : 		return (_Traits::eof());

  00000	83 c8 ff	 or	 eax, -1

; 304  : 		}

  00003	c2 04 00	 ret	 4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ??1codecvt_base@std@@UAE@XZ
_TEXT	SEGMENT
??1codecvt_base@std@@UAE@XZ PROC			; std::codecvt_base::~codecvt_base, COMDAT
; _this$ = ecx

; 705  : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
  00006	c3		 ret	 0
??1codecvt_base@std@@UAE@XZ ENDP			; std::codecvt_base::~codecvt_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gcodecvt_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gcodecvt_base@std@@UAEPAXI@Z PROC			; std::codecvt_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	f6 44 24 04 01	 test	 BYTE PTR ___flags$[esp-4], 1
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  0000e	74 09		 je	 SHORT $LN8@scalar@3
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$LN8@scalar@3:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 04 00	 ret	 4
??_Gcodecvt_base@std@@UAEPAXI@Z ENDP			; std::codecvt_base::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0codecvt_base@std@@QAE@I@Z
_TEXT	SEGMENT
__Refs$ = 8						; size = 4
??0codecvt_base@std@@QAE@I@Z PROC			; std::codecvt_base::codecvt_base, COMDAT
; _this$ = ecx

; 685  : 		{	// default constructor

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Refs$[esp-4]
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7codecvt_base@std@@6B@

; 686  : 		}

  0000f	c2 04 00	 ret	 4
??0codecvt_base@std@@QAE@I@Z ENDP			; std::codecvt_base::codecvt_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\fstream
_TEXT	ENDS
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAV?$codecvt@DDH@2@@Z
_TEXT	SEGMENT
__Newpcvt$ = 8						; size = 4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAV?$codecvt@DDH@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT
; _this$ = ecx

; 531  : 		{	// initialize codecvt pointer

  00000	56		 push	 esi
  00001	57		 push	 edi

; 532  : 		if (_Newpcvt->always_noconv())

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR __Newpcvt$[esp+4]
  00006	8b 07		 mov	 eax, DWORD PTR [edi]
  00008	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b cf		 mov	 ecx, edi
  0000f	ff d2		 call	 edx
  00011	84 c0		 test	 al, al
  00013	74 0c		 je	 SHORT $LN2@Initcvt
  00015	5f		 pop	 edi

; 533  : 			_Pcvt = 0;	// nothing to do

  00016	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
  0001d	5e		 pop	 esi

; 538  : 			}
; 539  : 		}

  0001e	c2 04 00	 ret	 4
$LN2@Initcvt:

; 534  : 		else
; 535  : 			{	// set up for nontrivial codecvt facet
; 536  : 			_Pcvt = _Newpcvt;
; 537  : 			_Mysb::_Init();	// reset any buffering

  00021	8b ce		 mov	 ecx, esi
  00023	89 7e 3c	 mov	 DWORD PTR [esi+60], edi
  00026	e8 00 00 00 00	 call	 ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi

; 538  : 			}
; 539  : 		}

  0002d	c2 04 00	 ret	 4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAV?$codecvt@DDH@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 447  : 		{	// synchronize C stream with external file

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 448  : 		return (_Myfile == 0
; 449  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 450  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);

  00003	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00007	74 23		 je	 SHORT $LN3@sync
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0000e	6a ff		 push	 -1
  00010	ff d2		 call	 edx
  00012	83 f8 ff	 cmp	 eax, -1
  00015	74 15		 je	 SHORT $LN3@sync
  00017	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _fflush
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax
  00025	7d 05		 jge	 SHORT $LN3@sync
  00027	83 c8 ff	 or	 eax, -1
  0002a	5e		 pop	 esi

; 451  : 		}

  0002b	c3		 ret	 0
$LN3@sync:

; 448  : 		return (_Myfile == 0
; 449  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 450  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);

  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 451  : 		}

  0002f	c3		 ret	 0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 310  : 		{	// get an element from stream, but don't point past it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 311  : 		int_type _Meta;
; 312  : 		if (_Mysb::gptr() != 0
; 313  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00003	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	85 c9		 test	 ecx, ecx
  0000a	74 14		 je	 SHORT $LN4@underflow
  0000c	8b d0		 mov	 edx, eax
  0000e	8b 02		 mov	 eax, DWORD PTR [edx]
  00010	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00013	8b 12		 mov	 edx, DWORD PTR [edx]
  00015	03 d0		 add	 edx, eax
  00017	3b c2		 cmp	 eax, edx
  00019	73 05		 jae	 SHORT $LN4@underflow

; 314  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered

  0001b	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  0001e	5e		 pop	 esi

; 321  : 			}
; 322  : 		}

  0001f	c3		 ret	 0
$LN4@underflow:

; 315  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00025	57		 push	 edi
  00026	8b ce		 mov	 ecx, esi
  00028	ff d2		 call	 edx
  0002a	8b f8		 mov	 edi, eax
  0002c	83 ff ff	 cmp	 edi, -1
  0002f	75 05		 jne	 SHORT $LN2@underflow
  00031	5f		 pop	 edi

; 316  : 			return (_Meta);	// uflow failed, return EOF

  00032	0b c0		 or	 eax, eax
  00034	5e		 pop	 esi

; 321  : 			}
; 322  : 		}

  00035	c3		 ret	 0
$LN2@underflow:

; 317  : 		else
; 318  : 			{	// get a char, don't point past it
; 319  : 			pbackfail(_Meta);

  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003b	57		 push	 edi
  0003c	8b ce		 mov	 ecx, esi
  0003e	ff d2		 call	 edx

; 320  : 			return (_Meta);

  00040	8b c7		 mov	 eax, edi
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi

; 321  : 			}
; 322  : 		}

  00044	c3		 ret	 0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 282  : 		if (_Mysb::gptr() != 0
; 283  : 			&& _Mysb::eback() < _Mysb::gptr()
; 284  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)
; 285  : 			|| _Traits::eq_int_type(_Traits::to_int_type(_Mysb::gptr()[-1]),
; 286  : 				_Meta)))

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]
  00005	53		 push	 ebx
  00006	8b 5c 24 08	 mov	 ebx, DWORD PTR __Meta$[esp]
  0000a	85 c0		 test	 eax, eax
  0000c	74 2b		 je	 SHORT $LN10@pbackfail
  0000e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00011	39 02		 cmp	 DWORD PTR [edx], eax
  00013	73 24		 jae	 SHORT $LN10@pbackfail
  00015	83 fb ff	 cmp	 ebx, -1
  00018	74 08		 je	 SHORT $LN9@pbackfail
  0001a	0f b6 40 ff	 movzx	 eax, BYTE PTR [eax-1]
  0001e	3b c3		 cmp	 eax, ebx
  00020	75 17		 jne	 SHORT $LN10@pbackfail
$LN9@pbackfail:

; 287  : 			{	// just back up position
; 288  : 			_Mysb::_Gndec();

  00022	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00025	ff 00		 inc	 DWORD PTR [eax]
  00027	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0002a	ff 09		 dec	 DWORD PTR [ecx]

; 289  : 			return (_Traits::not_eof(_Meta));

  0002c	8b c3		 mov	 eax, ebx
  0002e	40		 inc	 eax
  0002f	f7 d8		 neg	 eax
  00031	1b c0		 sbb	 eax, eax
  00033	23 c3		 and	 eax, ebx
  00035	5b		 pop	 ebx

; 295  : #pragma warning(push)
; 296  : #pragma warning(disable: 6237 6239)
; 297  : 		/* prefast noise VSW 489858 */
; 298  : 		else if (1 < sizeof (_Elem) && _Mysb::gptr() != &_Mychar)
; 299  : #pragma warning(pop)
; 300  : 			{	// putback to _Mychar
; 301  : 			_Mychar = _Traits::to_char_type(_Meta);
; 302  : 			_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
; 303  : 			return (_Meta);
; 304  : 			}
; 305  : 		else
; 306  : 			return (_Traits::eof());	// nowhere to put back
; 307  : 		}

  00036	c2 04 00	 ret	 4
$LN10@pbackfail:

; 290  : 			}
; 291  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))

  00039	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0003c	85 c0		 test	 eax, eax
  0003e	74 23		 je	 SHORT $LN6@pbackfail
  00040	83 fb ff	 cmp	 ebx, -1
  00043	74 1e		 je	 SHORT $LN6@pbackfail

; 293  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

  00045	83 79 3c 00	 cmp	 DWORD PTR [ecx+60], 0
  00049	75 18		 jne	 SHORT $LN6@pbackfail
  0004b	0f b6 cb	 movzx	 ecx, bl
  0004e	50		 push	 eax
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 _ungetc
  00055	83 c4 08	 add	 esp, 8
  00058	83 f8 ff	 cmp	 eax, -1
  0005b	74 06		 je	 SHORT $LN6@pbackfail

; 294  : 			return (_Meta);	// no facet and unget succeeded, return

  0005d	8b c3		 mov	 eax, ebx
  0005f	5b		 pop	 ebx

; 295  : #pragma warning(push)
; 296  : #pragma warning(disable: 6237 6239)
; 297  : 		/* prefast noise VSW 489858 */
; 298  : 		else if (1 < sizeof (_Elem) && _Mysb::gptr() != &_Mychar)
; 299  : #pragma warning(pop)
; 300  : 			{	// putback to _Mychar
; 301  : 			_Mychar = _Traits::to_char_type(_Meta);
; 302  : 			_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
; 303  : 			return (_Meta);
; 304  : 			}
; 305  : 		else
; 306  : 			return (_Traits::eof());	// nowhere to put back
; 307  : 		}

  00060	c2 04 00	 ret	 4
$LN6@pbackfail:

; 292  : 			return (_Traits::eof());	// no open C stream or EOF, fail

  00063	83 c8 ff	 or	 eax, -1
  00066	5b		 pop	 ebx

; 295  : #pragma warning(push)
; 296  : #pragma warning(disable: 6237 6239)
; 297  : 		/* prefast noise VSW 489858 */
; 298  : 		else if (1 < sizeof (_Elem) && _Mysb::gptr() != &_Mychar)
; 299  : #pragma warning(pop)
; 300  : 			{	// putback to _Mychar
; 301  : 			_Mychar = _Traits::to_char_type(_Meta);
; 302  : 			_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
; 303  : 			return (_Meta);
; 304  : 			}
; 305  : 		else
; 306  : 			return (_Traits::eof());	// nowhere to put back
; 307  : 		}

  00067	c2 04 00	 ret	 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sgetc, COMDAT
; _this$ = ecx

; 111  : 		return (0 < _Gnavail()
; 112  : 			? _Traits::to_int_type(*gptr()) : underflow());

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 0e		 je	 SHORT $LN3@sgetc
  00008	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0000b	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0000e	7e 06		 jle	 SHORT $LN3@sgetc
  00010	8b 00		 mov	 eax, DWORD PTR [eax]
  00012	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 113  : 		}

  00015	c3		 ret	 0
$LN3@sgetc:

; 111  : 		return (0 < _Gnavail()
; 112  : 			? _Traits::to_int_type(*gptr()) : underflow());

  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0001b	ff e0		 jmp	 eax
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc, COMDAT
; _this$ = ecx

; 105  : 		return (0 < _Gnavail()
; 106  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 1a		 je	 SHORT $LN3@sbumpc
  00008	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0000b	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0000e	7e 12		 jle	 SHORT $LN3@sbumpc
  00010	8b c2		 mov	 eax, edx
  00012	ff 08		 dec	 DWORD PTR [eax]
  00014	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00017	8b 01		 mov	 eax, DWORD PTR [ecx]
  00019	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0001c	89 11		 mov	 DWORD PTR [ecx], edx
  0001e	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 107  : 		}

  00021	c3		 ret	 0
$LN3@sbumpc:

; 105  : 		return (0 < _Gnavail()
; 106  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00027	ff e2		 jmp	 edx
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T56179 = -16						; size = 16
__Lobj$ = 8						; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC		; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 1807 : 		{	// initialize from _Lobj

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	56		 push	 esi

; 1808 : 		_Ctype = _Lobj._Getctype();

  00004	8d 44 24 08	 lea	 eax, DWORD PTR $T56179[esp+24]
  00008	50		 push	 eax
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 __Getctype
  00010	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00014	66 0f d6 46 08	 movq	 QWORD PTR [esi+8], xmm0
  00019	f3 0f 7e 40 08	 movq	 xmm0, QWORD PTR [eax+8]
  0001e	83 c4 04	 add	 esp, 4
  00021	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0

; 1809 : 		}

  00026	5e		 pop	 esi
  00027	83 c4 14	 add	 esp, 20			; 00000014H
  0002a	c2 04 00	 ret	 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx

; 1363 : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
  00006	c3		 ret	 0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	f6 44 24 04 01	 test	 BYTE PTR ___flags$[esp-4], 1
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  0000e	74 09		 je	 SHORT $LN8@scalar@4
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$LN8@scalar@4:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 04 00	 ret	 4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 1358 : 		{	// default constructor

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Refs$[esp-4]
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@

; 1359 : 		}

  0000f	c2 04 00	 ret	 4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\istream
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = eax

; 62   : 			if (_Myistr.rdbuf() != 0)

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  0000b	85 c0		 test	 eax, eax
  0000d	74 08		 je	 SHORT $LN8@Sentry_bas

; 63   : 				_Myistr.rdbuf()->_Unlock();

  0000f	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00012	e9 00 00 00 00	 jmp	 ?_Unlock@_Mutex@std@@QAEXXZ ; std::_Mutex::_Unlock
$LN8@Sentry_bas:

; 64   : 			}

  00017	c3		 ret	 0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = esi
; __Istr$ = eax

; 55   : 			{	// lock the stream buffer, if there

  00000	89 06		 mov	 DWORD PTR [esi], eax

; 56   : 			if (_Myistr.rdbuf() != 0)

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  0000b	85 c0		 test	 eax, eax
  0000d	74 08		 je	 SHORT $LN10@Sentry_bas@2

; 57   : 				_Myistr.rdbuf()->_Lock();

  0000f	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00012	e8 00 00 00 00	 call	 ?_Lock@_Mutex@std@@QAEXXZ ; std::_Mutex::_Lock
$LN10@Sentry_bas@2:

; 58   : 			}

  00017	8b c6		 mov	 eax, esi
  00019	c3		 ret	 0
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = eax
  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  0000b	85 c0		 test	 eax, eax
  0000d	74 08		 je	 SHORT $LN11@sentry
  0000f	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00012	e9 00 00 00 00	 jmp	 ?_Unlock@_Mutex@std@@QAEXXZ ; std::_Mutex::_Unlock
$LN11@sentry:
  00017	c3		 ret	 0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ??0locale@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$56265 = -4					; size = 4
??0locale@std@@QAE@XZ PROC				; std::locale::locale, COMDAT
; _this$ = ecx

; 324  : 		{	// construct from current locale

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Init
  0000a	89 07		 mov	 DWORD PTR [edi], eax

; 325  : 		_Getgloballocale()->_Incref();

  0000c	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  00011	6a 00		 push	 0
  00013	8d 4c 24 0c	 lea	 ecx, DWORD PTR __Lock$56265[esp+16]
  00017	8b f0		 mov	 esi, eax
  00019	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  0001e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00021	83 f8 ff	 cmp	 eax, -1
  00024	73 04		 jae	 SHORT $LN3@locale
  00026	40		 inc	 eax
  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN3@locale:
  0002a	8d 4c 24 08	 lea	 ecx, DWORD PTR __Lock$56265[esp+12]
  0002e	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit

; 326  : 		}

  00033	8b c7		 mov	 eax, edi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	59		 pop	 ecx
  00038	c3		 ret	 0
??0locale@std@@QAE@XZ ENDP				; std::locale::locale
_TEXT	ENDS
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
xdata$x	SEGMENT
__unwindtable$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ$0
__ehfuncinfo$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
__Lock$56287 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 28   : 		{	// construct with no buffers

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 08	 sub	 esp, 8
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c4		 xor	 eax, esp
  0001b	50		 push	 eax
  0001c	8d 44 24 18	 lea	 eax, DWORD PTR __$EHRec$[esp+36]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 74 24 14	 mov	 DWORD PTR _this$[esp+36], esi
  0002c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  00035	e8 00 00 00 00	 call	 ??0_Mutex@std@@QAE@XZ	; std::_Mutex::_Mutex
  0003a	6a 04		 push	 4
  0003c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 0
  00044	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00049	8b f8		 mov	 edi, eax
  0004b	83 c4 04	 add	 esp, 4
  0004e	85 ff		 test	 edi, edi
  00050	74 30		 je	 SHORT $LN3@basic_stre
  00052	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Init
  00057	89 07		 mov	 DWORD PTR [edi], eax
  00059	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0005e	6a 00		 push	 0
  00060	8d 4c 24 14	 lea	 ecx, DWORD PTR __Lock$56287[esp+40]
  00064	8b d8		 mov	 ebx, eax
  00066	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  0006b	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0006e	83 f8 ff	 cmp	 eax, -1
  00071	73 04		 jae	 SHORT $LN8@basic_stre
  00073	40		 inc	 eax
  00074	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN8@basic_stre:
  00077	8d 4c 24 10	 lea	 ecx, DWORD PTR __Lock$56287[esp+36]
  0007b	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00080	eb 02		 jmp	 SHORT $LN4@basic_stre
$LN3@basic_stre:
  00082	33 ff		 xor	 edi, edi
$LN4@basic_stre:

; 29   : 		_Init();

  00084	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00087	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0008a	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  0008d	89 4e 20	 mov	 DWORD PTR [esi+32], ecx
  00090	8d 56 1c	 lea	 edx, DWORD PTR [esi+28]
  00093	89 56 24	 mov	 DWORD PTR [esi+36], edx
  00096	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  00099	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0009c	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0009f	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  000a2	89 4e 30	 mov	 DWORD PTR [esi+48], ecx
  000a5	8d 56 2c	 lea	 edx, DWORD PTR [esi+44]
  000a8	89 56 34	 mov	 DWORD PTR [esi+52], edx
  000ab	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000b1	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000b4	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000ba	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  000bd	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000c3	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  000c6	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  000cc	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  000cf	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000d5	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  000d8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 30   : 		}

  000de	8b c6		 mov	 eax, esi
  000e0	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  000e4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000eb	59		 pop	 ecx
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx
  000ef	83 c4 14	 add	 esp, 20			; 00000014H
  000f2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1_Mutex@std@@QAE@XZ	; std::_Mutex::~_Mutex
__ehhandler$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 ec	 lea	 eax, DWORD PTR [edx-20]
  00012	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\istream
;	COMDAT ?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@H@2@XZ
_TEXT	SEGMENT
?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@H@2@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::tellg, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 837  : 		if (!ios_base::fail())

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00005	03 c2		 add	 eax, edx
  00007	f6 40 08 06	 test	 BYTE PTR [eax+8], 6
  0000b	75 14		 jne	 SHORT $LN2@tellg

; 838  : 			return (_Myios::rdbuf()->pubseekoff(0,
; 839  : 				ios_base::cur, ios_base::in));

  0000d	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00010	8b 01		 mov	 eax, DWORD PTR [ecx]
  00012	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00015	6a 01		 push	 1
  00017	6a 01		 push	 1
  00019	6a 00		 push	 0
  0001b	56		 push	 esi
  0001c	ff d2		 call	 edx

; 840  : 		else
; 841  : 			return (pos_type(_BADOFF));

  0001e	8b c6		 mov	 eax, esi

; 842  : 		}

  00020	c3		 ret	 0
$LN2@tellg:

; 840  : 		else
; 841  : 			return (pos_type(_BADOFF));

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3JB ; std::_BADOFF
  00026	89 06		 mov	 DWORD PTR [esi], eax
  00028	33 c0		 xor	 eax, eax
  0002a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002d	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00030	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00033	8b c6		 mov	 eax, esi

; 842  : 		}

  00035	c3		 ret	 0
?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE?AV?$fpos@H@2@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::tellg
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
_TEXT	ENDS
;	COMDAT ??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ PROC	; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 146  : 	__CLR_OR_THIS_CALL basic_ios()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@

; 147  : 		{	// default constructor, do nothing
; 148  : 		}

  00008	c3		 ret	 0
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ENDP	; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\fstream
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
__File$ = 8						; size = 4
__Which$ = 12						; size = 4
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 460  : 		__PURE_APPDOMAIN_GLOBAL static _Myst _Stinit;	// initial state
; 461  : 		_Closef = _Which == _Openfl;

  00000	83 7c 24 08 01	 cmp	 DWORD PTR __Which$[esp-4], 1

; 462  : 		_Wrotesome = false;
; 463  : 
; 464  : 		_Mysb::_Init();	// initialize stream buffer base object

  00005	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]
  00008	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000b	8d 51 18	 lea	 edx, DWORD PTR [ecx+24]
  0000e	89 51 20	 mov	 DWORD PTR [ecx+32], edx
  00011	8d 51 1c	 lea	 edx, DWORD PTR [ecx+28]
  00014	89 51 24	 mov	 DWORD PTR [ecx+36], edx
  00017	0f 94 c0	 sete	 al
  0001a	88 41 48	 mov	 BYTE PTR [ecx+72], al
  0001d	8d 51 28	 lea	 edx, DWORD PTR [ecx+40]
  00020	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  00023	c6 41 41 00	 mov	 BYTE PTR [ecx+65], 0
  00027	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  0002a	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0002d	8d 51 2c	 lea	 edx, DWORD PTR [ecx+44]
  00030	89 51 34	 mov	 DWORD PTR [ecx+52], edx
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00039	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0003c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00042	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00045	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0004b	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0004e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00054	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00057	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0005d	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00060	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 465  : 
; 466  :  #ifndef _IORCNT
; 467  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 468  :   #define _IOWCNT _IOCNT
; 469  :  #endif /* _IORCNT */
; 470  : 
; 471  : #pragma warning(push)
; 472  : #pragma warning(disable: 6240)
; 473  : 		/* prefast noise VSW 489858 */
; 474  : 		if (_File != 0 && sizeof (_Elem) == 1)

  00066	8b 44 24 04	 mov	 eax, DWORD PTR __File$[esp-4]
  0006a	85 c0		 test	 eax, eax
  0006c	74 18		 je	 SHORT $LN10@Init@2

; 475  : #pragma warning(pop)
; 476  : 			{	// point inside C stream with [first, first + count) buffer
; 477  : 			_Elem **_Pb = (_Elem **)&_File->_IOBASE;

  0006e	8d 50 08	 lea	 edx, DWORD PTR [eax+8]

; 478  : 			_Elem **_Pn = (_Elem **)&_File->_IOPTR;
; 479  : 			int *_Nr = (int *)&_File->_IORCNT;
; 480  : 			int *_Nw = (int *)&_File->_IOWCNT;
; 481  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);

  00071	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00074	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  00077	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0007a	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  0007d	89 41 24	 mov	 DWORD PTR [ecx+36], eax
  00080	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  00083	89 51 34	 mov	 DWORD PTR [ecx+52], edx
$LN10@Init@2:

; 482  : 			}
; 483  : 
; 484  : 		_Myfile = _File;

  00086	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 485  : 		_State = _Stinit;

  00089	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  0008f	89 51 44	 mov	 DWORD PTR [ecx+68], edx

; 486  : 		_Pcvt = 0;	// pointer to codecvt facet

  00092	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 487  : 		}

  00099	c2 08 00	 ret	 8
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBV_Container_base_secure@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBV_Container_base_secure@1@@Z PROC ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 83   : 		__CLR_OR_THIS_CALL _String_const_iterator(pointer _Ptr, const _Container_base_secure *_Pstring)

  00000	53		 push	 ebx

; 84   : 			{	// construct with pointer _Ptr
; 85   : 			_SCL_SECURE_VALIDATE(

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR __Ptr$[esp]
  00005	56		 push	 esi
  00006	8b 74 24 10	 mov	 esi, DWORD PTR __Pstring$[esp+4]
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00013	85 f6		 test	 esi, esi
  00015	74 29		 je	 SHORT $LN1@String_con
  00017	85 db		 test	 ebx, ebx
  00019	74 25		 je	 SHORT $LN1@String_con
  0001b	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0001e	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00021	83 fa 10	 cmp	 edx, 16			; 00000010H
  00024	72 04		 jb	 SHORT $LN11@String_con
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	eb 02		 jmp	 SHORT $LN12@String_con
$LN11@String_con:
  0002a	8b c8		 mov	 ecx, eax
$LN12@String_con:
  0002c	3b cb		 cmp	 ecx, ebx
  0002e	77 10		 ja	 SHORT $LN1@String_con
  00030	83 fa 10	 cmp	 edx, 16			; 00000010H
  00033	72 02		 jb	 SHORT $LN15@String_con
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
$LN15@String_con:
  00037	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0003a	03 c8		 add	 ecx, eax
  0003c	3b d9		 cmp	 ebx, ecx
  0003e	76 05		 jbe	 SHORT $LN2@String_con
$LN1@String_con:

; 86   : 				_Pstring != NULL && 
; 87   : 				_Ptr != NULL && 
; 88   : 				((_Mystring *)_Pstring)->_Myptr() <= _Ptr && _Ptr <= (((_Mystring *)_Pstring)->_Myptr() + ((_Mystring *)_Pstring)->_Mysize));

  00040	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN2@String_con:

; 89   : 			this->_Mycont = _Pstring;

  00045	89 37		 mov	 DWORD PTR [edi], esi

; 90   : 			_Myptr = _Ptr;

  00047	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 91   : 			}

  0004a	8b c7		 mov	 eax, edi
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	c2 08 00	 ret	 8
??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBV_Container_base_secure@1@@Z ENDP ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ
_TEXT	SEGMENT
??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ PROC ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*, COMDAT
; _this$ = ecx

; 368  : 		{	// return designated object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 369  : 		return ((reference)**(_Mybase *)this);

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	83 f8 fc	 cmp	 eax, -4			; fffffffcH
  00008	74 28		 je	 SHORT $LN15@operator@31
  0000a	85 c0		 test	 eax, eax
  0000c	75 05		 jne	 SHORT $LN4@operator@31
  0000e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN4@operator@31:
  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00019	72 05		 jb	 SHORT $LN12@operator@31
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	eb 03		 jmp	 SHORT $LN13@operator@31
$LN12@operator@31:
  00020	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
$LN13@operator@31:
  00023	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00026	03 c1		 add	 eax, ecx
  00028	39 46 04	 cmp	 DWORD PTR [esi+4], eax
  0002b	72 05		 jb	 SHORT $LN15@operator@31
  0002d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN15@operator@31:
  00032	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00035	5e		 pop	 esi

; 370  : 		}

  00036	c3		 ret	 0
??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ENDP ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT
__Lock$59006 = -4					; size = 4
___flags$ = 8						; size = 4
??_Glocale@std@@QAEPAXI@Z PROC				; std::locale::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	8b d9		 mov	 ebx, ecx
  00004	57		 push	 edi
  00005	8b 3b		 mov	 edi, DWORD PTR [ebx]
  00007	85 ff		 test	 edi, edi
  00009	74 3f		 je	 SHORT $LN7@scalar@10
  0000b	6a 00		 push	 0
  0000d	8d 4c 24 0c	 lea	 ecx, DWORD PTR __Lock$59006[esp+16]
  00011	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00016	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00019	85 c0		 test	 eax, eax
  0001b	76 09		 jbe	 SHORT $LN9@scalar@10
  0001d	83 f8 ff	 cmp	 eax, -1
  00020	73 04		 jae	 SHORT $LN9@scalar@10
  00022	48		 dec	 eax
  00023	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN9@scalar@10:
  00026	56		 push	 esi
  00027	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0002a	f7 de		 neg	 esi
  0002c	1b f6		 sbb	 esi, esi
  0002e	f7 d6		 not	 esi
  00030	8d 4c 24 0c	 lea	 ecx, DWORD PTR __Lock$59006[esp+16]
  00034	23 f7		 and	 esi, edi
  00036	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0003b	85 f6		 test	 esi, esi
  0003d	74 0a		 je	 SHORT $LN13@scalar@10
  0003f	8b 06		 mov	 eax, DWORD PTR [esi]
  00041	8b 10		 mov	 edx, DWORD PTR [eax]
  00043	6a 01		 push	 1
  00045	8b ce		 mov	 ecx, esi
  00047	ff d2		 call	 edx
$LN13@scalar@10:
  00049	5e		 pop	 esi
$LN7@scalar@10:
  0004a	f6 44 24 10 01	 test	 BYTE PTR ___flags$[esp+8], 1
  0004f	74 09		 je	 SHORT $LN12@scalar@10
  00051	53		 push	 ebx
  00052	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00057	83 c4 04	 add	 esp, 4
$LN12@scalar@10:
  0005a	5f		 pop	 edi
  0005b	8b c3		 mov	 eax, ebx
  0005d	5b		 pop	 ebx
  0005e	59		 pop	 ecx
  0005f	c2 04 00	 ret	 4
??_Glocale@std@@QAEPAXI@Z ENDP				; std::locale::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ??0?$codecvt@DDH@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$codecvt@DDH@std@@QAE@ABV_Locinfo@1@I@Z PROC	; std::codecvt<char,char,int>::codecvt<char,char,int>, COMDAT
; _this$ = ecx

; 777  : 		{	// construct from specified locale

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Refs$[esp-4]
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$codecvt@DDH@std@@6B@

; 778  : 		_Init(_Lobj);
; 779  : 		}

  0000f	c2 08 00	 ret	 8
??0?$codecvt@DDH@std@@QAE@ABV_Locinfo@1@I@Z ENDP	; std::codecvt<char,char,int>::codecvt<char,char,int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$codecvt@DDH@std@@MAE@XZ
_TEXT	SEGMENT
??1?$codecvt@DDH@std@@MAE@XZ PROC			; std::codecvt<char,char,int>::~codecvt<char,char,int>, COMDAT
; _this$ = ecx

; 793  : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
  00006	c3		 ret	 0
??1?$codecvt@DDH@std@@MAE@XZ ENDP			; std::codecvt<char,char,int>::~codecvt<char,char,int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@DDH@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$codecvt@DDH@std@@MAEPAXI@Z PROC			; std::codecvt<char,char,int>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	f6 44 24 04 01	 test	 BYTE PTR ___flags$[esp-4], 1
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  0000e	74 09		 je	 SHORT $LN10@scalar@11
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$LN10@scalar@11:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 04 00	 ret	 4
??_G?$codecvt@DDH@std@@MAEPAXI@Z ENDP			; std::codecvt<char,char,int>::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\fstream
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PADH@Z
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Count$ = 12						; size = 4
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PADH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 434  : 		{	// offer _Buffer to C stream

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 435  : 		if (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,
; 436  : 			_Buffer == 0 && _Count == 0 ? _IONBF : _IOFBF,
; 437  : 			_Count * sizeof (_Elem)) != 0)

  00003	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  00006	85 c9		 test	 ecx, ecx
  00008	74 3c		 je	 SHORT $LN2@setbuf
  0000a	8b 54 24 08	 mov	 edx, DWORD PTR __Buffer$[esp]
  0000e	56		 push	 esi
  0000f	8b 74 24 10	 mov	 esi, DWORD PTR __Count$[esp+4]
  00013	85 d2		 test	 edx, edx
  00015	75 09		 jne	 SHORT $LN6@setbuf
  00017	85 f6		 test	 esi, esi
  00019	75 05		 jne	 SHORT $LN6@setbuf
  0001b	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001e	eb 02		 jmp	 SHORT $LN7@setbuf
$LN6@setbuf:
  00020	33 c0		 xor	 eax, eax
$LN7@setbuf:
  00022	56		 push	 esi
  00023	50		 push	 eax
  00024	52		 push	 edx
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 _setvbuf
  0002b	83 c4 10	 add	 esp, 16			; 00000010H
  0002e	5e		 pop	 esi
  0002f	85 c0		 test	 eax, eax
  00031	75 13		 jne	 SHORT $LN2@setbuf

; 439  : 		else
; 440  : 			{	// new buffer, reinitialize pointers
; 441  : 			_Init(_Myfile, _Openfl);

  00033	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]
  00036	6a 01		 push	 1
  00038	50		 push	 eax
  00039	8b cf		 mov	 ecx, edi
  0003b	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 442  : 			return (this);

  00040	8b c7		 mov	 eax, edi
  00042	5f		 pop	 edi

; 443  : 			}
; 444  : 		}

  00043	c2 08 00	 ret	 8
$LN2@setbuf:

; 438  : 			return (0);	// failed

  00046	33 c0		 xor	 eax, eax
  00048	5f		 pop	 edi

; 443  : 			}
; 444  : 		}

  00049	c2 08 00	 ret	 8
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PADH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = eax
  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00005	83 c0 08	 add	 eax, 8
  00008	c7 44 02 f8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-8], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00010	50		 push	 eax
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  00017	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0001c	59		 pop	 ecx
  0001d	c3		 ret	 0
??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8d 71 f8	 lea	 esi, DWORD PTR [ecx-8]
  00004	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0000c	c7 44 02 f8 00
	00 00 00	 mov	 DWORD PTR [edx+eax-8], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00014	50		 push	 eax
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  0001b	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00020	83 c4 04	 add	 esp, 4
  00023	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  00028	74 09		 je	 SHORT $LN13@scalar@12
  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00030	83 c4 04	 add	 esp, 4
$LN13@scalar@12:
  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	c2 04 00	 ret	 4
??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::snextc, COMDAT
; _this$ = esi

; 131  : 		return (1 < _Gnavail()
; 132  : 			? _Traits::to_int_type(*_Gnpreinc())
; 133  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 134  : 				? _Traits::eof() : sgetc());

  00000	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]
  00005	85 c0		 test	 eax, eax
  00007	74 3c		 je	 SHORT $LN17@snextc
  00009	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000e	83 f9 01	 cmp	 ecx, 1
  00011	7e 13		 jle	 SHORT $LN5@snextc
  00013	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00016	ff 08		 dec	 DWORD PTR [eax]
  00018	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0001b	ff 00		 inc	 DWORD PTR [eax]
  0001d	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 135  : 		}

  00025	c3		 ret	 0
$LN5@snextc:

; 131  : 		return (1 < _Gnavail()
; 132  : 			? _Traits::to_int_type(*_Gnpreinc())
; 133  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 134  : 				? _Traits::eof() : sgetc());

  00026	85 c0		 test	 eax, eax
  00028	74 1b		 je	 SHORT $LN17@snextc
  0002a	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  0002d	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00030	7e 13		 jle	 SHORT $LN17@snextc
  00032	8b c1		 mov	 eax, ecx
  00034	ff 08		 dec	 DWORD PTR [eax]
  00036	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0003e	89 10		 mov	 DWORD PTR [eax], edx
  00040	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00043	eb 09		 jmp	 SHORT $LN18@snextc
$LN17@snextc:
  00045	8b 06		 mov	 eax, DWORD PTR [esi]
  00047	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0004a	8b ce		 mov	 ecx, esi
  0004c	ff d2		 call	 edx
$LN18@snextc:
  0004e	83 f8 ff	 cmp	 eax, -1
  00051	75 03		 jne	 SHORT $LN3@snextc
  00053	0b c0		 or	 eax, eax

; 135  : 		}

  00055	c3		 ret	 0
$LN3@snextc:

; 131  : 		return (1 < _Gnavail()
; 132  : 			? _Traits::to_int_type(*_Gnpreinc())
; 133  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 134  : 				? _Traits::eof() : sgetc());

  00056	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00059	83 38 00	 cmp	 DWORD PTR [eax], 0
  0005c	74 0e		 je	 SHORT $LN35@snextc
  0005e	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00061	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00064	7e 06		 jle	 SHORT $LN35@snextc
  00066	8b 10		 mov	 edx, DWORD PTR [eax]
  00068	0f b6 02	 movzx	 eax, BYTE PTR [edx]

; 135  : 		}

  0006b	c3		 ret	 0

; 131  : 		return (1 < _Gnavail()
; 132  : 			? _Traits::to_int_type(*_Gnpreinc())
; 133  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 134  : 				? _Traits::eof() : sgetc());

$LN35@snextc:
  0006c	8b 06		 mov	 eax, DWORD PTR [esi]
  0006e	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00071	8b ce		 mov	 ecx, esi
  00073	ff e2		 jmp	 edx
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::snextc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
$T59223 = -20						; size = 16
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 1784 : 		{	// construct from current locale

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Refs$[esp-4]
  00004	83 ec 18	 sub	 esp, 24			; 00000018H
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 1785 : 		_Init(_Lobj);

  0000a	8d 4c 24 08	 lea	 ecx, DWORD PTR $T59223[esp+28]
  0000e	51		 push	 ecx
  0000f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  00018	e8 00 00 00 00	 call	 __Getctype
  0001d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00021	66 0f d6 46 08	 movq	 QWORD PTR [esi+8], xmm0
  00026	f3 0f 7e 40 08	 movq	 xmm0, QWORD PTR [eax+8]
  0002b	83 c4 04	 add	 esp, 4
  0002e	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0

; 1786 : 		}

  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	83 c4 18	 add	 esp, 24			; 00000018H
  00039	c2 08 00	 ret	 8
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<char>::ctype<char>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 1801 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1802 : 		_Tidy();

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  0000c	85 c0		 test	 eax, eax
  0000e	7e 14		 jle	 SHORT $LN13@ctype
  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _free
  00019	83 c4 04	 add	 esp, 4

; 1803 : 		}

  0001c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00022	5e		 pop	 esi
  00023	c3		 ret	 0
$LN13@ctype:

; 1802 : 		_Tidy();

  00024	7d 0c		 jge	 SHORT $LN12@ctype
  00026	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002f	83 c4 04	 add	 esp, 4
$LN12@ctype:

; 1803 : 		}

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00038	5e		 pop	 esi
  00039	c3		 ret	 0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  0000c	85 c0		 test	 eax, eax
  0000e	7e 0b		 jle	 SHORT $LN16@scalar@13
  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _free
  00019	eb 0b		 jmp	 SHORT $LN17@scalar@13
$LN16@scalar@13:
  0001b	7d 0c		 jge	 SHORT $LN6@scalar@13
  0001d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
$LN17@scalar@13:
  00026	83 c4 04	 add	 esp, 4
$LN6@scalar@13:
  00029	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0002e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00034	74 09		 je	 SHORT $LN15@scalar@13
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003c	83 c4 04	 add	 esp, 4
$LN15@scalar@13:
  0003f	8b c6		 mov	 eax, esi
  00041	5e		 pop	 esi
  00042	c2 04 00	 ret	 4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
__Lock$59294 = -4					; size = 4
?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::getloc, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = edi

; 88   : 		{	// get locale

  00000	51		 push	 ecx

; 89   : 		return (*_Plocale);

  00001	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00004	56		 push	 esi
  00005	8b 31		 mov	 esi, DWORD PTR [ecx]
  00007	6a 00		 push	 0
  00009	8d 4c 24 08	 lea	 ecx, DWORD PTR __Lock$59294[esp+12]
  0000d	89 37		 mov	 DWORD PTR [edi], esi
  0000f	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00014	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00017	83 f8 ff	 cmp	 eax, -1
  0001a	73 04		 jae	 SHORT $LN5@getloc
  0001c	40		 inc	 eax
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN5@getloc:
  00020	8d 4c 24 04	 lea	 ecx, DWORD PTR __Lock$59294[esp+8]
  00024	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00029	8b c7		 mov	 eax, edi
  0002b	5e		 pop	 esi

; 90   : 		}

  0002c	59		 pop	 ecx
  0002d	c3		 ret	 0
?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::getloc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBV_Container_base_secure@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBV_Container_base_secure@1@@Z PROC ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_iterator<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 341  : 			{	// construct with pointer _Ptr

  00000	53		 push	 ebx
  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR __Ptr$[esp]
  00005	56		 push	 esi
  00006	8b 74 24 10	 mov	 esi, DWORD PTR __Pstring$[esp+4]
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00013	85 f6		 test	 esi, esi
  00015	74 29		 je	 SHORT $LN3@String_ite
  00017	85 db		 test	 ebx, ebx
  00019	74 25		 je	 SHORT $LN3@String_ite
  0001b	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0001e	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00021	83 fa 10	 cmp	 edx, 16			; 00000010H
  00024	72 04		 jb	 SHORT $LN13@String_ite
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	eb 02		 jmp	 SHORT $LN14@String_ite
$LN13@String_ite:
  0002a	8b c8		 mov	 ecx, eax
$LN14@String_ite:
  0002c	3b cb		 cmp	 ecx, ebx
  0002e	77 10		 ja	 SHORT $LN3@String_ite
  00030	83 fa 10	 cmp	 edx, 16			; 00000010H
  00033	72 02		 jb	 SHORT $LN17@String_ite
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
$LN17@String_ite:
  00037	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0003a	03 c8		 add	 ecx, eax
  0003c	3b d9		 cmp	 ebx, ecx
  0003e	76 05		 jbe	 SHORT $LN4@String_ite
$LN3@String_ite:
  00040	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN4@String_ite:
  00045	89 37		 mov	 DWORD PTR [edi], esi
  00047	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 342  : 			}

  0004a	8b c7		 mov	 eax, edi
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	c2 08 00	 ret	 8
??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBV_Container_base_secure@1@@Z ENDP ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_iterator<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__Lock$59503 = -4					; size = 4
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 42   : 		{	// destroy the object

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	8b e9		 mov	 ebp, ecx

; 43   : 		_DELETE_CRT(_Plocale);

  00005	8b 5d 38	 mov	 ebx, DWORD PTR [ebp+56]
  00008	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [ebp], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  0000f	85 db		 test	 ebx, ebx
  00011	74 50		 je	 SHORT $LN3@basic_stre@2
  00013	57		 push	 edi
  00014	8b 3b		 mov	 edi, DWORD PTR [ebx]
  00016	85 ff		 test	 edi, edi
  00018	74 3f		 je	 SHORT $LN12@basic_stre@2
  0001a	6a 00		 push	 0
  0001c	8d 4c 24 10	 lea	 ecx, DWORD PTR __Lock$59503[esp+20]
  00020	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00025	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00028	85 c0		 test	 eax, eax
  0002a	76 09		 jbe	 SHORT $LN14@basic_stre@2
  0002c	83 f8 ff	 cmp	 eax, -1
  0002f	73 04		 jae	 SHORT $LN14@basic_stre@2
  00031	48		 dec	 eax
  00032	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN14@basic_stre@2:
  00035	56		 push	 esi
  00036	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00039	f7 de		 neg	 esi
  0003b	1b f6		 sbb	 esi, esi
  0003d	f7 d6		 not	 esi
  0003f	8d 4c 24 10	 lea	 ecx, DWORD PTR __Lock$59503[esp+20]
  00043	23 f7		 and	 esi, edi
  00045	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0004a	85 f6		 test	 esi, esi
  0004c	74 0a		 je	 SHORT $LN18@basic_stre@2
  0004e	8b 06		 mov	 eax, DWORD PTR [esi]
  00050	8b 10		 mov	 edx, DWORD PTR [eax]
  00052	6a 01		 push	 1
  00054	8b ce		 mov	 ecx, esi
  00056	ff d2		 call	 edx
$LN18@basic_stre@2:
  00058	5e		 pop	 esi
$LN12@basic_stre@2:
  00059	53		 push	 ebx
  0005a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005f	83 c4 04	 add	 esp, 4
  00062	5f		 pop	 edi
$LN3@basic_stre@2:

; 44   : 		}

  00063	8d 4d 04	 lea	 ecx, DWORD PTR [ebp+4]
  00066	5d		 pop	 ebp
  00067	5b		 pop	 ebx
  00068	83 c4 04	 add	 esp, 4
  0006b	e9 00 00 00 00	 jmp	 ??1_Mutex@std@@QAE@XZ	; std::_Mutex::~_Mutex
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z
_TEXT	SEGMENT
__Copied$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn, COMDAT
; _this$ = ecx

; 362  : 		{	// put _Count characters to stream

  00000	51		 push	 ecx
  00001	55		 push	 ebp

; 363  : 		streamsize _Stream_size, _Size, _Copied;
; 364  : 
; 365  : 		for (_Copied = 0; 0 < _Count; )

  00002	8b 6c 24 10	 mov	 ebp, DWORD PTR __Count$[esp+4]
  00006	56		 push	 esi
  00007	33 f6		 xor	 esi, esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	89 74 24 0c	 mov	 DWORD PTR __Copied$[esp+16], esi
  00010	85 ed		 test	 ebp, ebp
  00012	7e 6e		 jle	 SHORT $LN31@xsputn
  00014	53		 push	 ebx
  00015	8b 5c 24 18	 mov	 ebx, DWORD PTR __Ptr$[esp+16]
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL7@xsputn:

; 366  : 			if (0 < (_Stream_size = _Pnavail()))

  00020	8b cf		 mov	 ecx, edi
  00022	e8 00 00 00 00	 call	 ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
  00027	85 c0		 test	 eax, eax
  00029	7e 30		 jle	 SHORT $LN5@xsputn

; 367  : 				{	// copy to write buffer
; 368  : 				_Size = _Stream_size;

  0002b	8b f0		 mov	 esi, eax

; 369  : 				if (_Count < _Size)

  0002d	3b e8		 cmp	 ebp, eax

; 370  : 					_Size = _Count;

  0002f	0f 4c f5	 cmovl	 esi, ebp

; 371  : 				_Traits_helper::copy_s<_Traits>(pptr(), _Stream_size, _Ptr, _Size);

  00032	56		 push	 esi
  00033	53		 push	 ebx
  00034	50		 push	 eax
  00035	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _memcpy_s

; 372  : 				_Ptr += _Size;
; 373  : 				_Copied += _Size;
; 374  : 				_Count -= _Size;
; 375  : 				pbump((int)_Size);

  00040	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  00043	29 30		 sub	 DWORD PTR [eax], esi
  00045	01 74 24 20	 add	 DWORD PTR __Copied$[esp+36], esi
  00049	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  0004c	03 de		 add	 ebx, esi
  0004e	2b ee		 sub	 ebp, esi
  00050	83 c4 10	 add	 esp, 16			; 00000010H
  00053	01 30		 add	 DWORD PTR [eax], esi

; 376  : 				}
; 377  : 			else if (_Traits::eq_int_type(_Traits::eof(),

  00055	8b 74 24 10	 mov	 esi, DWORD PTR __Copied$[esp+20]
  00059	eb 19		 jmp	 SHORT $LN1@xsputn
$LN5@xsputn:

; 378  : 				overflow(_Traits::to_int_type(*_Ptr))))

  0005b	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0005e	8b 17		 mov	 edx, DWORD PTR [edi]
  00060	50		 push	 eax
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	8b cf		 mov	 ecx, edi
  00066	ff d0		 call	 eax
  00068	83 f8 ff	 cmp	 eax, -1
  0006b	74 0b		 je	 SHORT $LN30@xsputn

; 379  : 				break;	// single character put failed, quit
; 380  : 			else
; 381  : 				{	// count character successfully put
; 382  : 				++_Ptr;
; 383  : 				++_Copied;

  0006d	46		 inc	 esi
  0006e	43		 inc	 ebx
  0006f	89 74 24 10	 mov	 DWORD PTR __Copied$[esp+20], esi

; 384  : 				--_Count;

  00073	4d		 dec	 ebp
$LN1@xsputn:

; 363  : 		streamsize _Stream_size, _Size, _Copied;
; 364  : 
; 365  : 		for (_Copied = 0; 0 < _Count; )

  00074	85 ed		 test	 ebp, ebp
  00076	7f a8		 jg	 SHORT $LL7@xsputn
$LN30@xsputn:
  00078	5b		 pop	 ebx
  00079	5f		 pop	 edi

; 385  : 				}
; 386  : 
; 387  : 		return (_Copied);

  0007a	8b c6		 mov	 eax, esi
  0007c	5e		 pop	 esi
  0007d	5d		 pop	 ebp

; 388  : 		}

  0007e	59		 pop	 ecx
  0007f	c2 08 00	 ret	 8
$LN31@xsputn:
  00082	5f		 pop	 edi

; 385  : 				}
; 386  : 
; 387  : 		return (_Copied);

  00083	8b c6		 mov	 eax, esi
  00085	5e		 pop	 esi
  00086	5d		 pop	 ebp

; 388  : 		}

  00087	59		 pop	 ecx
  00088	c2 08 00	 ret	 8
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Xsgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADIH@Z
_TEXT	SEGMENT
__Copied$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Ptr_size$ = 12					; size = 4
__Count$ = 16						; size = 4
?_Xsgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADIH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Xsgetn_s, COMDAT
; _this$ = ecx

; 332  : 		{	// get _Count characters from stream

  00000	51		 push	 ecx
  00001	55		 push	 ebp

; 333  : 		int_type _Meta;
; 334  : 		streamsize _Stream_size, _Size, _Copied;
; 335  : 
; 336  : 		for (_Copied = 0; 0 < _Count; )

  00002	8b 6c 24 14	 mov	 ebp, DWORD PTR __Count$[esp+4]
  00006	56		 push	 esi
  00007	33 f6		 xor	 esi, esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	89 74 24 0c	 mov	 DWORD PTR __Copied$[esp+16], esi
  00010	85 ed		 test	 ebp, ebp
  00012	7e 70		 jle	 SHORT $LN31@Xsgetn_s
  00014	53		 push	 ebx
  00015	8b 5c 24 18	 mov	 ebx, DWORD PTR __Ptr$[esp+16]
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL7@Xsgetn_s:

; 337  : 			if (0 < (_Stream_size = _Gnavail()))

  00020	8b cf		 mov	 ecx, edi
  00022	e8 00 00 00 00	 call	 ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
  00027	85 c0		 test	 eax, eax
  00029	7e 34		 jle	 SHORT $LN5@Xsgetn_s

; 338  : 				{	// copy from read buffer
; 339  : 				_Size = _Stream_size;
; 340  : 				if (_Count < _Size)
; 341  : 					_Size = _Count;
; 342  : 				_Traits_helper::copy_s<_Traits>(_Ptr, _Ptr_size, gptr(), _Size);

  0002b	8b 54 24 1c	 mov	 edx, DWORD PTR __Ptr_size$[esp+16]
  0002f	8b f0		 mov	 esi, eax
  00031	3b e8		 cmp	 ebp, eax
  00033	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	0f 4c f5	 cmovl	 esi, ebp
  0003b	56		 push	 esi
  0003c	51		 push	 ecx
  0003d	52		 push	 edx
  0003e	53		 push	 ebx
  0003f	e8 00 00 00 00	 call	 _memcpy_s

; 343  : 				_Ptr += _Size;
; 344  : 				_Copied += _Size;
; 345  : 				_Count -= _Size;
; 346  : 				gbump((int)_Size);

  00044	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  00047	29 30		 sub	 DWORD PTR [eax], esi
  00049	01 74 24 20	 add	 DWORD PTR __Copied$[esp+36], esi
  0004d	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00050	03 de		 add	 ebx, esi
  00052	2b ee		 sub	 ebp, esi
  00054	83 c4 10	 add	 esp, 16			; 00000010H
  00057	01 30		 add	 DWORD PTR [eax], esi
  00059	8b 74 24 10	 mov	 esi, DWORD PTR __Copied$[esp+20]
  0005d	eb 17		 jmp	 SHORT $LN1@Xsgetn_s
$LN5@Xsgetn_s:

; 347  : 				}
; 348  : 			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  0005f	8b 07		 mov	 eax, DWORD PTR [edi]
  00061	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00064	8b cf		 mov	 ecx, edi
  00066	ff d2		 call	 edx
  00068	83 f8 ff	 cmp	 eax, -1
  0006b	74 0d		 je	 SHORT $LN30@Xsgetn_s

; 349  : 				break;	// end of file, quit
; 350  : 			else
; 351  : 				{	// get a single character
; 352  : 				*_Ptr++ = _Traits::to_char_type(_Meta);
; 353  : 				++_Copied;

  0006d	46		 inc	 esi
  0006e	88 03		 mov	 BYTE PTR [ebx], al
  00070	43		 inc	 ebx
  00071	89 74 24 10	 mov	 DWORD PTR __Copied$[esp+20], esi

; 354  : 				--_Count;

  00075	4d		 dec	 ebp
$LN1@Xsgetn_s:

; 333  : 		int_type _Meta;
; 334  : 		streamsize _Stream_size, _Size, _Copied;
; 335  : 
; 336  : 		for (_Copied = 0; 0 < _Count; )

  00076	85 ed		 test	 ebp, ebp
  00078	7f a6		 jg	 SHORT $LL7@Xsgetn_s
$LN30@Xsgetn_s:
  0007a	5b		 pop	 ebx
  0007b	5f		 pop	 edi

; 355  : 				}
; 356  : 
; 357  : 		return (_Copied);

  0007c	8b c6		 mov	 eax, esi
  0007e	5e		 pop	 esi
  0007f	5d		 pop	 ebp

; 358  : 		}

  00080	59		 pop	 ecx
  00081	c2 0c 00	 ret	 12			; 0000000cH
$LN31@Xsgetn_s:
  00084	5f		 pop	 edi

; 355  : 				}
; 356  : 
; 357  : 		return (_Copied);

  00085	8b c6		 mov	 eax, esi
  00087	5e		 pop	 esi
  00088	5d		 pop	 ebp

; 358  : 		}

  00089	59		 pop	 ecx
  0008a	c2 0c 00	 ret	 12			; 0000000cH
?_Xsgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADIH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Xsgetn_s
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $LN4@scalar@14
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$LN4@scalar@14:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\fstream
_TEXT	ENDS
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
_TEXT	SEGMENT
__File$ = 8						; size = 4
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 124  : 		{	// construct from pointer to C stream

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >

; 125  : 		_Init(_File, _Newfl);

  00008	8b 44 24 08	 mov	 eax, DWORD PTR __File$[esp]
  0000c	6a 00		 push	 0
  0000e	50		 push	 eax
  0000f	8b ce		 mov	 ecx, esi
  00011	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00017	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 126  : 		}

  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c2 04 00	 ret	 4
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 1501 : 		{	// return iterator for beginning of mutable sequence

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 1502 : 		return (_STRING_ITERATOR(_Myptr()));

  00005	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  00008	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  0000b	83 fa 10	 cmp	 edx, 16			; 00000010H
  0000e	72 04		 jb	 SHORT $LN5@begin@6
  00010	8b 30		 mov	 esi, DWORD PTR [eax]
  00012	eb 02		 jmp	 SHORT $LN6@begin@6
$LN5@begin@6:
  00014	8b f0		 mov	 esi, eax
$LN6@begin@6:
  00016	8b 5c 24 10	 mov	 ebx, DWORD PTR ___$ReturnUdt$[esp+8]
  0001a	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00020	85 f6		 test	 esi, esi
  00022	74 1f		 je	 SHORT $LN9@begin@6
  00024	83 fa 10	 cmp	 edx, 16			; 00000010H
  00027	72 04		 jb	 SHORT $LN19@begin@6
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	eb 02		 jmp	 SHORT $LN20@begin@6
$LN19@begin@6:
  0002d	8b c8		 mov	 ecx, eax
$LN20@begin@6:
  0002f	3b ce		 cmp	 ecx, esi
  00031	77 10		 ja	 SHORT $LN9@begin@6
  00033	83 fa 10	 cmp	 edx, 16			; 00000010H
  00036	72 02		 jb	 SHORT $LN23@begin@6
  00038	8b 00		 mov	 eax, DWORD PTR [eax]
$LN23@begin@6:
  0003a	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  0003d	03 c8		 add	 ecx, eax
  0003f	3b f1		 cmp	 esi, ecx
  00041	76 05		 jbe	 SHORT $LN10@begin@6
$LN9@begin@6:
  00043	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN10@begin@6:
  00048	89 3b		 mov	 DWORD PTR [ebx], edi
  0004a	5f		 pop	 edi
  0004b	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  0004e	5e		 pop	 esi
  0004f	8b c3		 mov	 eax, ebx
  00051	5b		 pop	 ebx

; 1503 : 		}

  00052	c2 04 00	 ret	 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1089 : 		{	// assign _Count * _Ch

  00000	56		 push	 esi
  00001	57		 push	 edi

; 1090 : 		if (_Count == npos)

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR __Count$[esp+4]
  00006	8b f1		 mov	 esi, ecx
  00008	83 ff ff	 cmp	 edi, -1
  0000b	75 07		 jne	 SHORT $LN2@assign

; 1091 : 			_String_base::_Xlen();	// result too long

  0000d	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen

; 1092 : 
; 1093 : 		if (_Grow(_Count))

  00012	eb 05		 jmp	 SHORT $LN63@assign
$LN2@assign:
  00014	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00017	76 05		 jbe	 SHORT $LN10@assign
$LN63@assign:
  00019	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN10@assign:
  0001e	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00021	3b c7		 cmp	 eax, edi
  00023	73 36		 jae	 SHORT $LN9@assign
  00025	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00028	50		 push	 eax
  00029	57		 push	 edi
  0002a	8b ce		 mov	 ecx, esi
  0002c	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00031	85 ff		 test	 edi, edi
$LN65@assign:
  00033	76 53		 jbe	 SHORT $LN64@assign

; 1094 : 			{	// make room and assign new stuff
; 1095 : 			_Chassign(0, _Count, _Ch);

  00035	8b 4c 24 10	 mov	 ecx, DWORD PTR __Ch$[esp+4]
  00039	51		 push	 ecx
  0003a	57		 push	 edi
  0003b	6a 00		 push	 0
  0003d	8b ce		 mov	 ecx, esi
  0003f	e8 00 00 00 00	 call	 ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 1096 : 			_Eos(_Count);

  00044	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00048	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  0004b	72 34		 jb	 SHORT $LN59@assign
  0004d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00050	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  00054	5f		 pop	 edi

; 1097 : 			}
; 1098 : 		return (*this);

  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi

; 1099 : 		}

  00058	c2 08 00	 ret	 8

; 1092 : 
; 1093 : 		if (_Grow(_Count))

$LN9@assign:
  0005b	85 ff		 test	 edi, edi
  0005d	75 d4		 jne	 SHORT $LN65@assign
  0005f	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00062	83 f8 10	 cmp	 eax, 16			; 00000010H
  00065	72 0d		 jb	 SHORT $LN51@assign
  00067	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0006a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0006d	5f		 pop	 edi

; 1097 : 			}
; 1098 : 		return (*this);

  0006e	8b c6		 mov	 eax, esi
  00070	5e		 pop	 esi

; 1099 : 		}

  00071	c2 08 00	 ret	 8

; 1092 : 
; 1093 : 		if (_Grow(_Count))

$LN51@assign:
  00074	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00077	c6 00 00	 mov	 BYTE PTR [eax], 0
  0007a	5f		 pop	 edi

; 1097 : 			}
; 1098 : 		return (*this);

  0007b	8b c6		 mov	 eax, esi
  0007d	5e		 pop	 esi

; 1099 : 		}

  0007e	c2 08 00	 ret	 8

; 1096 : 			_Eos(_Count);

$LN59@assign:
  00081	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00084	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN64@assign:
  00088	5f		 pop	 edi

; 1097 : 			}
; 1098 : 		return (*this);

  00089	8b c6		 mov	 eax, esi
  0008b	5e		 pop	 esi

; 1099 : 		}

  0008c	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0
__ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
__Ch$37950 = -81					; size = 1
$T65063 = -80						; size = 4
__Src$37952 = -76					; size = 4
_this$GSCopy$ = -72					; size = 4
__Dest$37951 = -68					; size = 4
$T64824 = -64						; size = 8
$T64821 = -56						; size = 8
__Str$37946 = -48					; size = 28
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 325  : 		{	// get an element from stream, point past it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 48	 sub	 esp, 72			; 00000048H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c4		 xor	 eax, esp
  0001e	89 44 24 40	 mov	 DWORD PTR __$ArrayPad$[esp+84], eax
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	57		 push	 edi
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002a	33 c4		 xor	 eax, esp
  0002c	50		 push	 eax
  0002d	8d 44 24 58	 lea	 eax, DWORD PTR __$EHRec$[esp+100]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 326  : 		if (_Mysb::gptr() != 0
; 327  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00037	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	33 d2		 xor	 edx, edx

; 353  : 				switch (_Pcvt->in(_State,
; 354  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Src,
; 355  : 					&_Ch, &_Ch + 1, _Dest))

  0003e	89 4c 24 1c	 mov	 DWORD PTR _this$GSCopy$[esp+100], ecx
  00042	3b c2		 cmp	 eax, edx
  00044	74 27		 je	 SHORT $LN19@uflow@2
  00046	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00049	8b 71 30	 mov	 esi, DWORD PTR [ecx+48]
  0004c	8b 00		 mov	 eax, DWORD PTR [eax]
  0004e	8b 36		 mov	 esi, DWORD PTR [esi]
  00050	03 f0		 add	 esi, eax
  00052	3b c6		 cmp	 eax, esi
  00054	73 17		 jae	 SHORT $LN19@uflow@2
  00056	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00059	ff 08		 dec	 DWORD PTR [eax]
  0005b	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00063	89 10		 mov	 DWORD PTR [eax], edx
  00065	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00068	e9 83 02 00 00	 jmp	 $LN14@uflow@2
$LN19@uflow@2:

; 328  : 			return (_Traits::to_int_type(
; 329  : 				*_Mysb::_Gninc()));	// return buffered
; 330  : 		else if (_Myfile == 0)

  0006d	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00070	3b c2		 cmp	 eax, edx

; 331  : 			return (_Traits::eof());	// no open C stream, fail

  00072	0f 84 75 02 00
	00		 je	 $LN218@uflow@2

; 332  : 		else if (_Pcvt == 0)

  00078	39 51 3c	 cmp	 DWORD PTR [ecx+60], edx
  0007b	75 1a		 jne	 SHORT $LN15@uflow@2

; 333  : 			{	// no codecvt facet, just get it
; 334  : 			_Elem _Ch;
; 335  : 			return (_Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch)
; 336  : 				: _Traits::eof());

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _fgetc
  00083	83 c4 04	 add	 esp, 4
  00086	83 f8 ff	 cmp	 eax, -1
  00089	0f 84 5e 02 00
	00		 je	 $LN218@uflow@2
  0008f	0f b6 c0	 movzx	 eax, al
  00092	e9 59 02 00 00	 jmp	 $LN14@uflow@2
$LN15@uflow@2:

; 337  : 			}
; 338  : 		else
; 339  : 			{	// build string until codecvt succeeds
; 340  : 			string _Str;

  00097	c7 44 24 4c 0f
	00 00 00	 mov	 DWORD PTR __Str$37946[esp+124], 15 ; 0000000fH
  0009f	89 54 24 48	 mov	 DWORD PTR __Str$37946[esp+120], edx
  000a3	88 54 24 38	 mov	 BYTE PTR __Str$37946[esp+104], dl

; 341  : 
; 342  : 			for (; ; )
; 343  : 				{	// get using codecvt facet
; 344  : 				_Elem _Ch, *_Dest;
; 345  : 				const char *_Src;
; 346  : 				ptrdiff_t _Nleft;
; 347  : 				int _Meta = fgetc(_Myfile);

  000a7	50		 push	 eax
  000a8	89 54 24 64	 mov	 DWORD PTR __$EHRec$[esp+112], edx
  000ac	e8 00 00 00 00	 call	 _fgetc
  000b1	83 c4 04	 add	 esp, 4

; 348  : 
; 349  : 				if (_Meta == EOF)

  000b4	83 f8 ff	 cmp	 eax, -1
  000b7	0f 84 27 02 00
	00		 je	 $LN1@uflow@2
$LN13@uflow@2:

; 350  : 					return (_Traits::eof());	// partial char?
; 351  : 
; 352  : 				_Str.append(1, (char)_Meta);	// append byte and convert

  000bd	50		 push	 eax
  000be	6a 01		 push	 1
  000c0	8d 4c 24 3c	 lea	 ecx, DWORD PTR __Str$37946[esp+108]
  000c4	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 353  : 				switch (_Pcvt->in(_State,
; 354  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Src,
; 355  : 					&_Ch, &_Ch + 1, _Dest))

  000c9	8b 7c 24 4c	 mov	 edi, DWORD PTR __Str$37946[esp+124]
  000cd	8b 44 24 38	 mov	 eax, DWORD PTR __Str$37946[esp+104]
  000d1	83 ff 10	 cmp	 edi, 16			; 00000010H
  000d4	0f 82 54 01 00
	00		 jb	 $LN83@uflow@2
  000da	8b f0		 mov	 esi, eax
  000dc	89 74 24 14	 mov	 DWORD PTR $T65063[esp+100], esi
  000e0	85 c0		 test	 eax, eax
  000e2	74 24		 je	 SHORT $LN87@uflow@2
$LN211@uflow@2:
  000e4	8b c8		 mov	 ecx, eax
  000e6	83 ff 10	 cmp	 edi, 16			; 00000010H
  000e9	73 04		 jae	 SHORT $LN98@uflow@2
  000eb	8d 4c 24 38	 lea	 ecx, DWORD PTR __Str$37946[esp+104]
$LN98@uflow@2:
  000ef	3b ce		 cmp	 ecx, esi
  000f1	77 15		 ja	 SHORT $LN87@uflow@2
  000f3	8b c8		 mov	 ecx, eax
  000f5	83 ff 10	 cmp	 edi, 16			; 00000010H
  000f8	73 04		 jae	 SHORT $LN102@uflow@2
  000fa	8d 4c 24 38	 lea	 ecx, DWORD PTR __Str$37946[esp+104]
$LN102@uflow@2:
  000fe	8b 54 24 48	 mov	 edx, DWORD PTR __Str$37946[esp+120]
  00102	03 ca		 add	 ecx, edx
  00104	3b f1		 cmp	 esi, ecx
  00106	76 11		 jbe	 SHORT $LN88@uflow@2
$LN87@uflow@2:
  00108	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0010d	8b 7c 24 4c	 mov	 edi, DWORD PTR __Str$37946[esp+124]
  00111	8b 54 24 48	 mov	 edx, DWORD PTR __Str$37946[esp+120]
  00115	8b 44 24 38	 mov	 eax, DWORD PTR __Str$37946[esp+104]
$LN88@uflow@2:
  00119	8d 4c 24 34	 lea	 ecx, DWORD PTR __Str$37946[esp+100]
  0011d	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00120	74 22		 je	 SHORT $LN105@uflow@2
  00122	8b c8		 mov	 ecx, eax
  00124	83 ff 10	 cmp	 edi, 16			; 00000010H
  00127	73 04		 jae	 SHORT $LN115@uflow@2
  00129	8d 4c 24 38	 lea	 ecx, DWORD PTR __Str$37946[esp+104]
$LN115@uflow@2:
  0012d	03 ca		 add	 ecx, edx
  0012f	3b f1		 cmp	 esi, ecx
  00131	72 11		 jb	 SHORT $LN105@uflow@2
  00133	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00138	8b 7c 24 4c	 mov	 edi, DWORD PTR __Str$37946[esp+124]
  0013c	8b 54 24 48	 mov	 edx, DWORD PTR __Str$37946[esp+120]
  00140	8b 44 24 38	 mov	 eax, DWORD PTR __Str$37946[esp+104]
$LN105@uflow@2:
  00144	8b da		 mov	 ebx, edx
  00146	83 ff 10	 cmp	 edi, 16			; 00000010H
  00149	0f 82 ee 00 00
	00		 jb	 $LN122@uflow@2
  0014f	8b f0		 mov	 esi, eax
  00151	85 c0		 test	 eax, eax
  00153	74 20		 je	 SHORT $LN126@uflow@2
$LN212@uflow@2:
  00155	8b c8		 mov	 ecx, eax
  00157	83 ff 10	 cmp	 edi, 16			; 00000010H
  0015a	73 04		 jae	 SHORT $LN137@uflow@2
  0015c	8d 4c 24 38	 lea	 ecx, DWORD PTR __Str$37946[esp+104]
$LN137@uflow@2:
  00160	3b ce		 cmp	 ecx, esi
  00162	77 11		 ja	 SHORT $LN126@uflow@2
  00164	8b c8		 mov	 ecx, eax
  00166	83 ff 10	 cmp	 edi, 16			; 00000010H
  00169	73 04		 jae	 SHORT $LN141@uflow@2
  0016b	8d 4c 24 38	 lea	 ecx, DWORD PTR __Str$37946[esp+104]
$LN141@uflow@2:
  0016f	03 ca		 add	 ecx, edx
  00171	3b f1		 cmp	 esi, ecx
  00173	76 11		 jbe	 SHORT $LN127@uflow@2
$LN126@uflow@2:
  00175	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0017a	8b 7c 24 4c	 mov	 edi, DWORD PTR __Str$37946[esp+124]
  0017e	8b 54 24 48	 mov	 edx, DWORD PTR __Str$37946[esp+120]
  00182	8b 44 24 38	 mov	 eax, DWORD PTR __Str$37946[esp+104]
$LN127@uflow@2:
  00186	8d 4c 24 34	 lea	 ecx, DWORD PTR __Str$37946[esp+100]
  0018a	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  0018d	74 14		 je	 SHORT $LN144@uflow@2
  0018f	83 ff 10	 cmp	 edi, 16			; 00000010H
  00192	73 04		 jae	 SHORT $LN154@uflow@2
  00194	8d 44 24 38	 lea	 eax, DWORD PTR __Str$37946[esp+104]
$LN154@uflow@2:
  00198	03 c2		 add	 eax, edx
  0019a	3b f0		 cmp	 esi, eax
  0019c	72 05		 jb	 SHORT $LN144@uflow@2
  0019e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN144@uflow@2:
  001a3	8b 7c 24 1c	 mov	 edi, DWORD PTR _this$GSCopy$[esp+100]
  001a7	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
  001aa	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ac	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  001af	8d 44 24 20	 lea	 eax, DWORD PTR __Dest$37951[esp+100]
  001b3	50		 push	 eax
  001b4	8d 44 24 18	 lea	 eax, DWORD PTR __Ch$37950[esp+105]
  001b8	50		 push	 eax
  001b9	8d 44 24 1b	 lea	 eax, DWORD PTR __Ch$37950[esp+108]
  001bd	50		 push	 eax
  001be	8d 44 24 24	 lea	 eax, DWORD PTR __Src$37952[esp+112]
  001c2	50		 push	 eax
  001c3	8b 44 24 24	 mov	 eax, DWORD PTR $T65063[esp+116]
  001c7	03 c3		 add	 eax, ebx
  001c9	50		 push	 eax
  001ca	56		 push	 esi
  001cb	8d 47 44	 lea	 eax, DWORD PTR [edi+68]
  001ce	50		 push	 eax
  001cf	ff d2		 call	 edx
  001d1	85 c0		 test	 eax, eax
  001d3	0f 8c 0b 01 00
	00		 jl	 $LN1@uflow@2
  001d9	83 f8 01	 cmp	 eax, 1
  001dc	7e 68		 jle	 SHORT $LN8@uflow@2
  001de	83 f8 03	 cmp	 eax, 3
  001e1	0f 85 fd 00 00
	00		 jne	 $LN1@uflow@2

; 369  : 					break;
; 370  : 
; 371  : 				case codecvt_base::noconv:
; 372  : 					if (_Str.size() < sizeof (_Elem))

  001e7	83 7c 24 48 01	 cmp	 DWORD PTR __Str$37946[esp+120], 1
  001ec	0f 82 dd 00 00
	00		 jb	 $LN4@uflow@2

; 373  : 						break;	// no conversion, but need more chars
; 374  : 
; 375  : 					_CRT_SECURE_MEMCPY(&_Ch,sizeof (_Elem), &*_Str.begin(),

  001f2	6a 01		 push	 1
  001f4	8d 54 24 28	 lea	 edx, DWORD PTR $T64824[esp+104]
  001f8	52		 push	 edx
  001f9	8d 4c 24 3c	 lea	 ecx, DWORD PTR __Str$37946[esp+108]
  001fd	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  00202	8b c8		 mov	 ecx, eax
  00204	e8 00 00 00 00	 call	 ??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
  00209	50		 push	 eax
  0020a	8d 44 24 1b	 lea	 eax, DWORD PTR __Ch$37950[esp+108]
  0020e	6a 01		 push	 1
  00210	50		 push	 eax
  00211	e8 00 00 00 00	 call	 _memcpy_s

; 376  : 						sizeof (_Elem));	// copy raw bytes to element
; 377  : 					return (_Traits::to_int_type(_Ch));	// return result

  00216	0f b6 74 24 23	 movzx	 esi, BYTE PTR __Ch$37950[esp+116]
  0021b	83 c4 10	 add	 esp, 16			; 00000010H
  0021e	8d 4c 24 34	 lea	 ecx, DWORD PTR __Str$37946[esp+100]
  00222	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00227	8b c6		 mov	 eax, esi
  00229	e9 c2 00 00 00	 jmp	 $LN14@uflow@2

; 353  : 				switch (_Pcvt->in(_State,
; 354  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Src,
; 355  : 					&_Ch, &_Ch + 1, _Dest))

$LN83@uflow@2:
  0022e	8d 4c 24 38	 lea	 ecx, DWORD PTR __Str$37946[esp+104]
  00232	89 4c 24 14	 mov	 DWORD PTR $T65063[esp+100], ecx
  00236	8b f1		 mov	 esi, ecx
  00238	e9 a7 fe ff ff	 jmp	 $LN211@uflow@2
$LN122@uflow@2:
  0023d	8d 74 24 38	 lea	 esi, DWORD PTR __Str$37946[esp+104]
  00241	e9 0f ff ff ff	 jmp	 $LN212@uflow@2
$LN8@uflow@2:

; 356  : 					{	// test result of converting one element
; 357  : 				case codecvt_base::partial:
; 358  : 				case codecvt_base::ok:
; 359  : 					if (_Dest != &_Ch)

  00246	8d 44 24 13	 lea	 eax, DWORD PTR __Ch$37950[esp+100]
  0024a	39 44 24 20	 cmp	 DWORD PTR __Dest$37951[esp+100], eax
  0024e	0f 85 c3 00 00
	00		 jne	 $LN208@uflow@2

; 365  : 						}
; 366  : 					else
; 367  : 						_Str.erase((size_t)0,	// partial, discard used input
; 368  : 							(size_t)(_Src - &*_Str.begin()));

  00254	8b 54 24 4c	 mov	 edx, DWORD PTR __Str$37946[esp+124]
  00258	8b 44 24 38	 mov	 eax, DWORD PTR __Str$37946[esp+104]
  0025c	83 fa 10	 cmp	 edx, 16			; 00000010H
  0025f	0f 82 a9 00 00
	00		 jb	 $LN165@uflow@2
  00265	8b f0		 mov	 esi, eax
  00267	85 c0		 test	 eax, eax
  00269	74 24		 je	 SHORT $LN169@uflow@2
$LN213@uflow@2:
  0026b	8b c8		 mov	 ecx, eax
  0026d	83 fa 10	 cmp	 edx, 16			; 00000010H
  00270	73 04		 jae	 SHORT $LN180@uflow@2
  00272	8d 4c 24 38	 lea	 ecx, DWORD PTR __Str$37946[esp+104]
$LN180@uflow@2:
  00276	3b ce		 cmp	 ecx, esi
  00278	77 15		 ja	 SHORT $LN169@uflow@2
  0027a	8b c8		 mov	 ecx, eax
  0027c	83 fa 10	 cmp	 edx, 16			; 00000010H
  0027f	73 04		 jae	 SHORT $LN184@uflow@2
  00281	8d 4c 24 38	 lea	 ecx, DWORD PTR __Str$37946[esp+104]
$LN184@uflow@2:
  00285	8b 5c 24 48	 mov	 ebx, DWORD PTR __Str$37946[esp+120]
  00289	03 cb		 add	 ecx, ebx
  0028b	3b f1		 cmp	 esi, ecx
  0028d	76 0d		 jbe	 SHORT $LN170@uflow@2
$LN169@uflow@2:
  0028f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00294	8b 54 24 4c	 mov	 edx, DWORD PTR __Str$37946[esp+124]
  00298	8b 44 24 38	 mov	 eax, DWORD PTR __Str$37946[esp+104]
$LN170@uflow@2:
  0029c	8d 4c 24 34	 lea	 ecx, DWORD PTR __Str$37946[esp+100]
  002a0	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  002a3	74 18		 je	 SHORT $LN187@uflow@2
  002a5	83 fa 10	 cmp	 edx, 16			; 00000010H
  002a8	73 04		 jae	 SHORT $LN197@uflow@2
  002aa	8d 44 24 38	 lea	 eax, DWORD PTR __Str$37946[esp+104]
$LN197@uflow@2:
  002ae	8b 54 24 48	 mov	 edx, DWORD PTR __Str$37946[esp+120]
  002b2	03 c2		 add	 eax, edx
  002b4	3b f0		 cmp	 esi, eax
  002b6	72 05		 jb	 SHORT $LN187@uflow@2
  002b8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN187@uflow@2:
  002bd	8b 44 24 18	 mov	 eax, DWORD PTR __Src$37952[esp+100]
  002c1	2b c6		 sub	 eax, esi
  002c3	50		 push	 eax
  002c4	6a 00		 push	 0
  002c6	8d 4c 24 3c	 lea	 ecx, DWORD PTR __Str$37946[esp+108]
  002ca	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
$LN4@uflow@2:
  002cf	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  002d2	51		 push	 ecx
  002d3	e8 00 00 00 00	 call	 _fgetc
  002d8	83 c4 04	 add	 esp, 4
  002db	83 f8 ff	 cmp	 eax, -1
  002de	0f 85 d9 fd ff
	ff		 jne	 $LN13@uflow@2
$LN1@uflow@2:

; 378  : 
; 379  : 				default:
; 380  : 					return (_Traits::eof());	// conversion failed

  002e4	8d 4c 24 34	 lea	 ecx, DWORD PTR __Str$37946[esp+100]
  002e8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN218@uflow@2:
  002ed	83 c8 ff	 or	 eax, -1
$LN14@uflow@2:

; 381  : 					}
; 382  : 				}
; 383  : 			}
; 384  : 		}

  002f0	8b 4c 24 58	 mov	 ecx, DWORD PTR __$EHRec$[esp+100]
  002f4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002fb	59		 pop	 ecx
  002fc	5f		 pop	 edi
  002fd	5e		 pop	 esi
  002fe	5b		 pop	 ebx
  002ff	8b 4c 24 40	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+84]
  00303	33 cc		 xor	 ecx, esp
  00305	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0030a	8b e5		 mov	 esp, ebp
  0030c	5d		 pop	 ebp
  0030d	c3		 ret	 0

; 365  : 						}
; 366  : 					else
; 367  : 						_Str.erase((size_t)0,	// partial, discard used input
; 368  : 							(size_t)(_Src - &*_Str.begin()));

$LN165@uflow@2:
  0030e	8d 74 24 38	 lea	 esi, DWORD PTR __Str$37946[esp+104]
  00312	e9 54 ff ff ff	 jmp	 $LN213@uflow@2
$LN208@uflow@2:

; 360  : 						{	// got an element, put back excess and deliver it
; 361  : 						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);

  00317	8b 7c 24 48	 mov	 edi, DWORD PTR __Str$37946[esp+120]
  0031b	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T64821[esp+100]
  0031f	51		 push	 ecx
  00320	8d 4c 24 38	 lea	 ecx, DWORD PTR __Str$37946[esp+104]
  00324	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  00329	8b c8		 mov	 ecx, eax
  0032b	e8 00 00 00 00	 call	 ??D?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::operator*
  00330	2b 7c 24 18	 sub	 edi, DWORD PTR __Src$37952[esp+100]
  00334	8b f0		 mov	 esi, eax
  00336	03 f7		 add	 esi, edi

; 362  : 						for (; 0 < _Nleft; )

  00338	85 f6		 test	 esi, esi
  0033a	7e 1f		 jle	 SHORT $LN5@uflow@2
$LN6@uflow@2:

; 363  : 							ungetc(_Src[--_Nleft], _Myfile);

  0033c	8b 54 24 1c	 mov	 edx, DWORD PTR _this$GSCopy$[esp+100]
  00340	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00343	8b 4c 24 18	 mov	 ecx, DWORD PTR __Src$37952[esp+100]
  00347	0f be 54 0e ff	 movsx	 edx, BYTE PTR [esi+ecx-1]
  0034c	4e		 dec	 esi
  0034d	50		 push	 eax
  0034e	52		 push	 edx
  0034f	e8 00 00 00 00	 call	 _ungetc
  00354	83 c4 08	 add	 esp, 8
  00357	85 f6		 test	 esi, esi
  00359	7f e1		 jg	 SHORT $LN6@uflow@2
$LN5@uflow@2:

; 364  : 						return (_Traits::to_int_type(_Ch));

  0035b	0f b6 74 24 13	 movzx	 esi, BYTE PTR __Ch$37950[esp+100]
  00360	8d 4c 24 34	 lea	 ecx, DWORD PTR __Str$37946[esp+100]
  00364	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00369	8b c6		 mov	 eax, esi
  0036b	eb 83		 jmp	 SHORT $LN14@uflow@2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Str$37946[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 ac	 lea	 eax, DWORD PTR [edx-84]
  0000f	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	83 c0 0c	 add	 eax, 12			; 0000000cH
  0001c	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 665  : 		{	// construct from _Count * _Ch

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 666  : 		_Tidy();
; 667  : 		assign(_Count, _Ch);

  00003	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp]
  00007	33 c0		 xor	 eax, eax
  00009	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0000c	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00013	88 46 04	 mov	 BYTE PTR [esi+4], al
  00016	8b 44 24 0c	 mov	 eax, DWORD PTR __Ch$[esp]
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	8b ce		 mov	 ecx, esi
  0001e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 668  : 		}

  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi
  00026	c2 08 00	 ret	 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z$0
__ehfuncinfo$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -76					; size = 4
__Ch$37657 = -72					; size = 1
$T68422 = -68						; size = 4
__Dest$37659 = -64					; size = 4
__Src$37658 = -60					; size = 4
$T67743 = -56						; size = 8
__Str$37660 = -48					; size = 28
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__Meta$ = 8						; size = 4
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 222  : 		{	// put an element to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 40	 sub	 esp, 64			; 00000040H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c4		 xor	 eax, esp
  0001e	89 44 24 38	 mov	 DWORD PTR __$ArrayPad$[esp+76], eax
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	57		 push	 edi
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002a	33 c4		 xor	 eax, esp
  0002c	50		 push	 eax
  0002d	8d 44 24 50	 lea	 eax, DWORD PTR __$EHRec$[esp+92]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 223  : 		if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  00037	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]
  0003a	8b d1		 mov	 edx, ecx

; 264  : 						_Str.append(_STRING_INC, '\0');	// try with more space

  0003c	89 54 24 10	 mov	 DWORD PTR _this$GSCopy$[esp+92], edx
  00040	83 fb ff	 cmp	 ebx, -1
  00043	75 07		 jne	 SHORT $LN21@overflow

; 224  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

  00045	33 c0		 xor	 eax, eax
  00047	e9 4c 03 00 00	 jmp	 $LN14@overflow
$LN21@overflow:

; 225  : 		else if (_Mysb::pptr() != 0
; 226  : 			&& _Mysb::pptr() < _Mysb::epptr())

  0004c	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	85 c9		 test	 ecx, ecx
  00053	74 20		 je	 SHORT $LN19@overflow
  00055	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00058	8b 30		 mov	 esi, DWORD PTR [eax]
  0005a	03 f1		 add	 esi, ecx
  0005c	3b ce		 cmp	 ecx, esi
  0005e	73 15		 jae	 SHORT $LN19@overflow

; 227  : 			{	// room in buffer, store it
; 228  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  00060	ff 08		 dec	 DWORD PTR [eax]
  00062	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00065	8b 08		 mov	 ecx, DWORD PTR [eax]
  00067	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0006a	89 10		 mov	 DWORD PTR [eax], edx
  0006c	88 19		 mov	 BYTE PTR [ecx], bl

; 229  : 			return (_Meta);

  0006e	8b c3		 mov	 eax, ebx
  00070	e9 23 03 00 00	 jmp	 $LN14@overflow
$LN19@overflow:

; 230  : 			}
; 231  : 		else if (_Myfile == 0)

  00075	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00078	85 c0		 test	 eax, eax

; 232  : 			return (_Traits::eof());	// no open C stream, fail

  0007a	0f 84 15 03 00
	00		 je	 $LN322@overflow

; 233  : 		else if (_Pcvt == 0)

  00080	83 7a 3c 00	 cmp	 DWORD PTR [edx+60], 0
  00084	75 1d		 jne	 SHORT $LN15@overflow

; 234  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)
; 235  : 				? _Meta : _Traits::eof());	// no codecvt facet, put as is

  00086	50		 push	 eax
  00087	0f be c3	 movsx	 eax, bl
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _fputc
  00090	83 c4 08	 add	 esp, 8
  00093	83 f8 ff	 cmp	 eax, -1
  00096	0f 84 f9 02 00
	00		 je	 $LN322@overflow
  0009c	8b c3		 mov	 eax, ebx
  0009e	e9 f5 02 00 00	 jmp	 $LN14@overflow
$LN15@overflow:

; 236  : 		else
; 237  : 			{	// put using codecvt facet
; 238  : 			const int _STRING_INC = 8;
; 239  : 			const _Elem _Ch = _Traits::to_char_type(_Meta);
; 240  : 			const _Elem *_Src;
; 241  : 			char *_Dest;
; 242  : 
; 243  : 			string _Str(_STRING_INC, '\0');

  000a3	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  000a8	c6 44 24 30 00	 mov	 BYTE PTR __Str$37660[esp+96], 0
  000ad	66 0f ef c0	 pxor	 xmm0, xmm0
  000b1	89 44 24 44	 mov	 DWORD PTR __Str$37660[esp+116], eax
  000b5	66 0f d6 44 24
	30		 movq	 QWORD PTR __Str$37660[esp+96], xmm0
  000bb	83 f8 10	 cmp	 eax, 16			; 00000010H
  000be	8b 44 24 30	 mov	 eax, DWORD PTR __Str$37660[esp+96]
  000c2	88 5c 24 14	 mov	 BYTE PTR __Ch$37657[esp+92], bl
  000c6	c7 44 24 40 08
	00 00 00	 mov	 DWORD PTR __Str$37660[esp+112], 8
  000ce	73 04		 jae	 SHORT $LN168@overflow
  000d0	8d 44 24 30	 lea	 eax, DWORD PTR __Str$37660[esp+96]
$LN168@overflow:
  000d4	c6 40 08 00	 mov	 BYTE PTR [eax+8], 0
  000d8	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+100], 0
$LN323@overflow:
  000e0	8b 4c 24 30	 mov	 ecx, DWORD PTR __Str$37660[esp+96]
  000e4	8b 54 24 44	 mov	 edx, DWORD PTR __Str$37660[esp+116]
  000e8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL13@overflow:

; 244  : 			for (; ; )
; 245  : 				switch (_Pcvt->out(_State,
; 246  : 					&_Ch, &_Ch + 1, _Src,
; 247  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

  000f0	83 fa 10	 cmp	 edx, 16			; 00000010H
  000f3	0f 82 bc 01 00
	00		 jb	 $LN175@overflow
  000f9	8b d9		 mov	 ebx, ecx
  000fb	89 5c 24 18	 mov	 DWORD PTR $T68422[esp+92], ebx
  000ff	85 c9		 test	 ecx, ecx
  00101	74 24		 je	 SHORT $LN179@overflow
$LN313@overflow:
  00103	8b c1		 mov	 eax, ecx
  00105	83 fa 10	 cmp	 edx, 16			; 00000010H
  00108	73 04		 jae	 SHORT $LN190@overflow
  0010a	8d 44 24 30	 lea	 eax, DWORD PTR __Str$37660[esp+96]
$LN190@overflow:
  0010e	3b c3		 cmp	 eax, ebx
  00110	77 15		 ja	 SHORT $LN179@overflow
  00112	8b c1		 mov	 eax, ecx
  00114	83 fa 10	 cmp	 edx, 16			; 00000010H
  00117	73 04		 jae	 SHORT $LN194@overflow
  00119	8d 44 24 30	 lea	 eax, DWORD PTR __Str$37660[esp+96]
$LN194@overflow:
  0011d	8b 74 24 40	 mov	 esi, DWORD PTR __Str$37660[esp+112]
  00121	03 c6		 add	 eax, esi
  00123	3b d8		 cmp	 ebx, eax
  00125	76 0d		 jbe	 SHORT $LN180@overflow
$LN179@overflow:
  00127	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0012c	8b 54 24 44	 mov	 edx, DWORD PTR __Str$37660[esp+116]
  00130	8b 4c 24 30	 mov	 ecx, DWORD PTR __Str$37660[esp+96]
$LN180@overflow:
  00134	8d 44 24 2c	 lea	 eax, DWORD PTR __Str$37660[esp+92]
  00138	83 f8 fc	 cmp	 eax, -4			; fffffffcH
  0013b	74 22		 je	 SHORT $LN197@overflow
  0013d	8b c1		 mov	 eax, ecx
  0013f	83 fa 10	 cmp	 edx, 16			; 00000010H
  00142	73 04		 jae	 SHORT $LN207@overflow
  00144	8d 44 24 30	 lea	 eax, DWORD PTR __Str$37660[esp+96]
$LN207@overflow:
  00148	8b 74 24 40	 mov	 esi, DWORD PTR __Str$37660[esp+112]
  0014c	03 c6		 add	 eax, esi
  0014e	3b d8		 cmp	 ebx, eax
  00150	72 0d		 jb	 SHORT $LN197@overflow
  00152	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00157	8b 54 24 44	 mov	 edx, DWORD PTR __Str$37660[esp+116]
  0015b	8b 4c 24 30	 mov	 ecx, DWORD PTR __Str$37660[esp+96]
$LN197@overflow:
  0015f	8b 7c 24 40	 mov	 edi, DWORD PTR __Str$37660[esp+112]
  00163	83 fa 10	 cmp	 edx, 16			; 00000010H
  00166	0f 82 56 01 00
	00		 jb	 $LN214@overflow
  0016c	8b f1		 mov	 esi, ecx
  0016e	85 c9		 test	 ecx, ecx
  00170	74 28		 je	 SHORT $LN218@overflow
$LN314@overflow:
  00172	8b c1		 mov	 eax, ecx
  00174	83 fa 10	 cmp	 edx, 16			; 00000010H
  00177	73 04		 jae	 SHORT $LN229@overflow
  00179	8d 44 24 30	 lea	 eax, DWORD PTR __Str$37660[esp+96]
$LN229@overflow:
  0017d	3b c6		 cmp	 eax, esi
  0017f	77 19		 ja	 SHORT $LN218@overflow
  00181	8b c1		 mov	 eax, ecx
  00183	83 fa 10	 cmp	 edx, 16			; 00000010H
  00186	73 04		 jae	 SHORT $LN233@overflow
  00188	8d 44 24 30	 lea	 eax, DWORD PTR __Str$37660[esp+96]
$LN233@overflow:
  0018c	8b 5c 24 40	 mov	 ebx, DWORD PTR __Str$37660[esp+112]
  00190	03 c3		 add	 eax, ebx
  00192	8b 5c 24 18	 mov	 ebx, DWORD PTR $T68422[esp+92]
  00196	3b f0		 cmp	 esi, eax
  00198	76 0d		 jbe	 SHORT $LN219@overflow
$LN218@overflow:
  0019a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0019f	8b 54 24 44	 mov	 edx, DWORD PTR __Str$37660[esp+116]
  001a3	8b 4c 24 30	 mov	 ecx, DWORD PTR __Str$37660[esp+96]
$LN219@overflow:
  001a7	8d 44 24 2c	 lea	 eax, DWORD PTR __Str$37660[esp+92]
  001ab	83 f8 fc	 cmp	 eax, -4			; fffffffcH
  001ae	74 1a		 je	 SHORT $LN236@overflow
  001b0	8b c1		 mov	 eax, ecx
  001b2	83 fa 10	 cmp	 edx, 16			; 00000010H
  001b5	73 04		 jae	 SHORT $LN246@overflow
  001b7	8d 44 24 30	 lea	 eax, DWORD PTR __Str$37660[esp+96]
$LN246@overflow:
  001bb	8b 4c 24 40	 mov	 ecx, DWORD PTR __Str$37660[esp+112]
  001bf	03 c1		 add	 eax, ecx
  001c1	3b f0		 cmp	 esi, eax
  001c3	72 05		 jb	 SHORT $LN236@overflow
  001c5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN236@overflow:
  001ca	8b 54 24 10	 mov	 edx, DWORD PTR _this$GSCopy$[esp+92]
  001ce	8b 4a 3c	 mov	 ecx, DWORD PTR [edx+60]
  001d1	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d3	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  001d6	8d 44 24 1c	 lea	 eax, DWORD PTR __Dest$37659[esp+92]
  001da	50		 push	 eax
  001db	03 df		 add	 ebx, edi
  001dd	53		 push	 ebx
  001de	56		 push	 esi
  001df	8d 44 24 2c	 lea	 eax, DWORD PTR __Src$37658[esp+104]
  001e3	50		 push	 eax
  001e4	8d 44 24 25	 lea	 eax, DWORD PTR __Ch$37657[esp+109]
  001e8	50		 push	 eax
  001e9	8d 44 24 28	 lea	 eax, DWORD PTR __Ch$37657[esp+112]
  001ed	50		 push	 eax
  001ee	8b 44 24 28	 mov	 eax, DWORD PTR _this$GSCopy$[esp+116]
  001f2	83 c0 44	 add	 eax, 68			; 00000044H
  001f5	50		 push	 eax
  001f6	ff d2		 call	 edx
  001f8	85 c0		 test	 eax, eax
  001fa	0f 8c 8c 01 00
	00		 jl	 $LN1@overflow
  00200	83 f8 01	 cmp	 eax, 1
  00203	0f 8f 37 01 00
	00		 jg	 $LN310@overflow

; 248  : 				{	// test result of converting one element
; 249  : 				case codecvt_base::partial:
; 250  : 				case codecvt_base::ok:
; 251  : 					{	// converted something, try to put it out
; 252  : 					size_t _Count = _Dest - &*_Str.begin();

  00209	8b 54 24 44	 mov	 edx, DWORD PTR __Str$37660[esp+116]
  0020d	8b 4c 24 30	 mov	 ecx, DWORD PTR __Str$37660[esp+96]
  00211	83 fa 10	 cmp	 edx, 16			; 00000010H
  00214	0f 82 b1 00 00
	00		 jb	 $LN253@overflow
  0021a	8b f1		 mov	 esi, ecx
  0021c	85 c9		 test	 ecx, ecx
  0021e	74 24		 je	 SHORT $LN257@overflow
$LN315@overflow:
  00220	8b c1		 mov	 eax, ecx
  00222	83 fa 10	 cmp	 edx, 16			; 00000010H
  00225	73 04		 jae	 SHORT $LN268@overflow
  00227	8d 44 24 30	 lea	 eax, DWORD PTR __Str$37660[esp+96]
$LN268@overflow:
  0022b	3b c6		 cmp	 eax, esi
  0022d	77 15		 ja	 SHORT $LN257@overflow
  0022f	8b c1		 mov	 eax, ecx
  00231	83 fa 10	 cmp	 edx, 16			; 00000010H
  00234	73 04		 jae	 SHORT $LN272@overflow
  00236	8d 44 24 30	 lea	 eax, DWORD PTR __Str$37660[esp+96]
$LN272@overflow:
  0023a	8b 7c 24 40	 mov	 edi, DWORD PTR __Str$37660[esp+112]
  0023e	03 c7		 add	 eax, edi
  00240	3b f0		 cmp	 esi, eax
  00242	76 0d		 jbe	 SHORT $LN258@overflow
$LN257@overflow:
  00244	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00249	8b 54 24 44	 mov	 edx, DWORD PTR __Str$37660[esp+116]
  0024d	8b 4c 24 30	 mov	 ecx, DWORD PTR __Str$37660[esp+96]
$LN258@overflow:
  00251	8d 44 24 2c	 lea	 eax, DWORD PTR __Str$37660[esp+92]
  00255	83 f8 fc	 cmp	 eax, -4			; fffffffcH
  00258	74 22		 je	 SHORT $LN275@overflow
  0025a	8b c1		 mov	 eax, ecx
  0025c	83 fa 10	 cmp	 edx, 16			; 00000010H
  0025f	73 04		 jae	 SHORT $LN285@overflow
  00261	8d 44 24 30	 lea	 eax, DWORD PTR __Str$37660[esp+96]
$LN285@overflow:
  00265	8b 7c 24 40	 mov	 edi, DWORD PTR __Str$37660[esp+112]
  00269	03 c7		 add	 eax, edi
  0026b	3b f0		 cmp	 esi, eax
  0026d	72 0d		 jb	 SHORT $LN275@overflow
  0026f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00274	8b 54 24 44	 mov	 edx, DWORD PTR __Str$37660[esp+116]
  00278	8b 4c 24 30	 mov	 ecx, DWORD PTR __Str$37660[esp+96]
$LN275@overflow:
  0027c	8b 7c 24 1c	 mov	 edi, DWORD PTR __Dest$37659[esp+92]
  00280	2b fe		 sub	 edi, esi

; 253  : 					if (0 < _Count && _Count !=
; 254  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))

  00282	0f 84 85 00 00
	00		 je	 $LN8@overflow
  00288	8d 4c 24 24	 lea	 ecx, DWORD PTR $T67743[esp+92]
  0028c	51		 push	 ecx
  0028d	8d 4c 24 30	 lea	 ecx, DWORD PTR __Str$37660[esp+96]
  00291	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  00296	8b f0		 mov	 esi, eax
  00298	8b 06		 mov	 eax, DWORD PTR [esi]
  0029a	83 f8 fc	 cmp	 eax, -4			; fffffffcH
  0029d	74 47		 je	 SHORT $LN288@overflow
  0029f	85 c0		 test	 eax, eax
  002a1	75 05		 jne	 SHORT $LN289@overflow
  002a3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN289@overflow:
  002a8	8b 06		 mov	 eax, DWORD PTR [esi]
  002aa	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  002ae	72 24		 jb	 SHORT $LN297@overflow
  002b0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002b3	eb 22		 jmp	 SHORT $LN298@overflow

; 244  : 			for (; ; )
; 245  : 				switch (_Pcvt->out(_State,
; 246  : 					&_Ch, &_Ch + 1, _Src,
; 247  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

$LN175@overflow:
  002b5	8d 5c 24 30	 lea	 ebx, DWORD PTR __Str$37660[esp+96]
  002b9	89 5c 24 18	 mov	 DWORD PTR $T68422[esp+92], ebx
  002bd	e9 41 fe ff ff	 jmp	 $LN313@overflow
$LN214@overflow:
  002c2	8d 74 24 30	 lea	 esi, DWORD PTR __Str$37660[esp+96]
  002c6	e9 a7 fe ff ff	 jmp	 $LN314@overflow

; 248  : 				{	// test result of converting one element
; 249  : 				case codecvt_base::partial:
; 250  : 				case codecvt_base::ok:
; 251  : 					{	// converted something, try to put it out
; 252  : 					size_t _Count = _Dest - &*_Str.begin();

$LN253@overflow:
  002cb	8d 74 24 30	 lea	 esi, DWORD PTR __Str$37660[esp+96]
  002cf	e9 4c ff ff ff	 jmp	 $LN315@overflow

; 253  : 					if (0 < _Count && _Count !=
; 254  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))

$LN297@overflow:
  002d4	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
$LN298@overflow:
  002d7	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  002da	03 d1		 add	 edx, ecx
  002dc	39 56 04	 cmp	 DWORD PTR [esi+4], edx
  002df	72 05		 jb	 SHORT $LN288@overflow
  002e1	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN288@overflow:
  002e6	8b 44 24 10	 mov	 eax, DWORD PTR _this$GSCopy$[esp+92]
  002ea	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  002ed	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  002f0	51		 push	 ecx
  002f1	57		 push	 edi
  002f2	6a 01		 push	 1
  002f4	56		 push	 esi
  002f5	e8 00 00 00 00	 call	 _fwrite
  002fa	83 c4 10	 add	 esp, 16			; 00000010H
  002fd	3b f8		 cmp	 edi, eax
  002ff	0f 85 87 00 00
	00		 jne	 $LN1@overflow
  00305	8b 54 24 44	 mov	 edx, DWORD PTR __Str$37660[esp+116]
  00309	8b 4c 24 30	 mov	 ecx, DWORD PTR __Str$37660[esp+96]
$LN8@overflow:

; 255  : 						return (_Traits::eof());	// write failed
; 256  : 
; 257  : 					_Wrotesome = true;	// write succeeded

  0030d	8b 44 24 10	 mov	 eax, DWORD PTR _this$GSCopy$[esp+92]
  00311	c6 40 41 01	 mov	 BYTE PTR [eax+65], 1

; 258  : 					if (_Src != &_Ch)

  00315	8d 44 24 14	 lea	 eax, DWORD PTR __Ch$37657[esp+92]
  00319	39 44 24 20	 cmp	 DWORD PTR __Src$37658[esp+92], eax
  0031d	75 5f		 jne	 SHORT $LN312@overflow

; 260  : 
; 261  : 					if (0 < _Count)

  0031f	85 ff		 test	 edi, edi
  00321	0f 87 c9 fd ff
	ff		 ja	 $LL13@overflow

; 262  : 						;
; 263  : 					else if (_Str.size() < 4 * _STRING_INC)

  00327	83 7c 24 40 20	 cmp	 DWORD PTR __Str$37660[esp+112], 32 ; 00000020H

; 264  : 						_Str.append(_STRING_INC, '\0');	// try with more space

  0032c	8d 4c 24 2c	 lea	 ecx, DWORD PTR __Str$37660[esp+92]
  00330	73 5e		 jae	 SHORT $LN4@overflow
  00332	6a 00		 push	 0
  00334	6a 08		 push	 8
  00336	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 276  : 				}

  0033b	e9 a0 fd ff ff	 jmp	 $LN323@overflow
$LN310@overflow:

; 244  : 			for (; ; )
; 245  : 				switch (_Pcvt->out(_State,
; 246  : 					&_Ch, &_Ch + 1, _Src,
; 247  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

  00340	83 f8 03	 cmp	 eax, 3
  00343	75 47		 jne	 SHORT $LN1@overflow

; 265  : 					else
; 266  : 						return (_Traits::eof());	// conversion failed
; 267  : 					break;
; 268  : 					}
; 269  : 
; 270  : 				case codecvt_base::noconv:
; 271  : 					return (_Fputc(_Ch, _Myfile) ? _Meta
; 272  : 						: _Traits::eof());	// no conversion, put as is

  00345	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$GSCopy$[esp+92]
  00349	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  0034c	8b 44 24 14	 mov	 eax, DWORD PTR __Ch$37657[esp+92]
  00350	52		 push	 edx
  00351	50		 push	 eax
  00352	e8 00 00 00 00	 call	 ??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z ; std::_Fputc<char>
  00357	83 c4 08	 add	 esp, 8
  0035a	84 c0		 test	 al, al
  0035c	74 10		 je	 SHORT $LN26@overflow
  0035e	8b 75 08	 mov	 esi, DWORD PTR __Meta$[ebp]
  00361	8d 4c 24 2c	 lea	 ecx, DWORD PTR __Str$37660[esp+92]
  00365	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0036a	8b c6		 mov	 eax, esi
  0036c	eb 2a		 jmp	 SHORT $LN14@overflow
$LN26@overflow:
  0036e	8d 4c 24 2c	 lea	 ecx, DWORD PTR __Str$37660[esp+92]
  00372	83 ce ff	 or	 esi, -1
  00375	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0037a	8b c6		 mov	 eax, esi
  0037c	eb 1a		 jmp	 SHORT $LN14@overflow
$LN312@overflow:

; 259  : 						return (_Meta);	// converted whole element

  0037e	8d 4c 24 2c	 lea	 ecx, DWORD PTR __Str$37660[esp+92]
  00382	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00387	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  0038a	eb 0c		 jmp	 SHORT $LN14@overflow
$LN1@overflow:

; 273  : 
; 274  : 				default:
; 275  : 					return (_Traits::eof());	// conversion failed

  0038c	8d 4c 24 2c	 lea	 ecx, DWORD PTR __Str$37660[esp+92]
$LN4@overflow:
  00390	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN322@overflow:
  00395	83 c8 ff	 or	 eax, -1
$LN14@overflow:

; 277  : 			}
; 278  : 		}

  00398	8b 4c 24 50	 mov	 ecx, DWORD PTR __$EHRec$[esp+92]
  0039c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003a3	59		 pop	 ecx
  003a4	5f		 pop	 edi
  003a5	5e		 pop	 esi
  003a6	5b		 pop	 ebx
  003a7	8b 4c 24 38	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+76]
  003ab	33 cc		 xor	 ecx, esp
  003ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b2	8b e5		 mov	 esp, ebp
  003b4	5d		 pop	 ebp
  003b5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Str$37660[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 b4	 lea	 eax, DWORD PTR [edx-76]
  0000f	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	83 c0 0c	 add	 eax, 12			; 0000000cH
  0001c	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ$0
__ehfuncinfo$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
_TEXT	SEGMENT
_this$GSCopy$ = -60					; size = 4
$T74828 = -56						; size = 4
__Dest$38304 = -52					; size = 4
__Str$38308 = -48					; size = 28
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT
; _this$ = ecx

; 490  : 		{	// put shift to initial conversion state, as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 30	 sub	 esp, 48			; 00000030H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c4		 xor	 eax, esp
  0001e	89 44 24 28	 mov	 DWORD PTR __$ArrayPad$[esp+60], eax
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	57		 push	 edi
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002a	33 c4		 xor	 eax, esp
  0002c	50		 push	 eax
  0002d	8d 44 24 40	 lea	 eax, DWORD PTR __$EHRec$[esp+76]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 491  : 		if (_Pcvt == 0 || !_Wrotesome)

  00037	83 79 3c 00	 cmp	 DWORD PTR [ecx+60], 0

; 517  : 						_Str.append(_STRING_INC, '\0');	// try with more space

  0003b	89 4c 24 10	 mov	 DWORD PTR _this$GSCopy$[esp+76], ecx
  0003f	0f 84 d9 02 00
	00		 je	 $LN14@Endwrite

; 491  : 		if (_Pcvt == 0 || !_Wrotesome)

  00045	80 79 41 00	 cmp	 BYTE PTR [ecx+65], 0
  00049	0f 84 cf 02 00
	00		 je	 $LN14@Endwrite

; 493  : 		else
; 494  : 			{	// may have to put
; 495  : 			const int _STRING_INC = 8;
; 496  : 			char *_Dest;
; 497  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))

  0004f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00051	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00054	6a ff		 push	 -1
  00056	ff d2		 call	 edx
  00058	83 f8 ff	 cmp	 eax, -1

; 498  : 				return (false);

  0005b	0f 84 b0 02 00
	00		 je	 $LN303@Endwrite

; 499  : 
; 500  : 			string _Str(_STRING_INC, '\0');

  00061	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  00066	c6 44 24 20 00	 mov	 BYTE PTR __Str$38308[esp+80], 0
  0006b	66 0f ef c0	 pxor	 xmm0, xmm0
  0006f	89 44 24 34	 mov	 DWORD PTR __Str$38308[esp+100], eax
  00073	66 0f d6 44 24
	20		 movq	 QWORD PTR __Str$38308[esp+80], xmm0
  00079	83 f8 10	 cmp	 eax, 16			; 00000010H
  0007c	8b 44 24 20	 mov	 eax, DWORD PTR __Str$38308[esp+80]
  00080	c7 44 24 30 08
	00 00 00	 mov	 DWORD PTR __Str$38308[esp+96], 8
  00088	73 04		 jae	 SHORT $LN132@Endwrite
  0008a	8d 44 24 20	 lea	 eax, DWORD PTR __Str$38308[esp+80]
$LN132@Endwrite:
  0008e	c6 40 08 00	 mov	 BYTE PTR [eax+8], 0
  00092	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+84], 0
$LN302@Endwrite:
  0009a	8b 44 24 20	 mov	 eax, DWORD PTR __Str$38308[esp+80]
  0009e	8b 54 24 34	 mov	 edx, DWORD PTR __Str$38308[esp+100]
$LL11@Endwrite:

; 501  : 			for (; ; )
; 502  : 				switch (_Pcvt->unshift(_State,
; 503  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

  000a2	83 fa 10	 cmp	 edx, 16			; 00000010H
  000a5	0f 82 0a 01 00
	00		 jb	 $LN139@Endwrite
  000ab	8b d8		 mov	 ebx, eax
  000ad	89 5c 24 14	 mov	 DWORD PTR $T74828[esp+76], ebx
  000b1	85 c0		 test	 eax, eax
  000b3	74 24		 je	 SHORT $LN143@Endwrite
$LN290@Endwrite:
  000b5	8b c8		 mov	 ecx, eax
  000b7	83 fa 10	 cmp	 edx, 16			; 00000010H
  000ba	73 04		 jae	 SHORT $LN154@Endwrite
  000bc	8d 4c 24 20	 lea	 ecx, DWORD PTR __Str$38308[esp+80]
$LN154@Endwrite:
  000c0	3b cb		 cmp	 ecx, ebx
  000c2	77 15		 ja	 SHORT $LN143@Endwrite
  000c4	8b c8		 mov	 ecx, eax
  000c6	83 fa 10	 cmp	 edx, 16			; 00000010H
  000c9	73 04		 jae	 SHORT $LN158@Endwrite
  000cb	8d 4c 24 20	 lea	 ecx, DWORD PTR __Str$38308[esp+80]
$LN158@Endwrite:
  000cf	8b 74 24 30	 mov	 esi, DWORD PTR __Str$38308[esp+96]
  000d3	03 ce		 add	 ecx, esi
  000d5	3b d9		 cmp	 ebx, ecx
  000d7	76 0d		 jbe	 SHORT $LN144@Endwrite
$LN143@Endwrite:
  000d9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  000de	8b 54 24 34	 mov	 edx, DWORD PTR __Str$38308[esp+100]
  000e2	8b 44 24 20	 mov	 eax, DWORD PTR __Str$38308[esp+80]
$LN144@Endwrite:
  000e6	8d 4c 24 1c	 lea	 ecx, DWORD PTR __Str$38308[esp+76]
  000ea	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  000ed	74 22		 je	 SHORT $LN161@Endwrite
  000ef	8b c8		 mov	 ecx, eax
  000f1	83 fa 10	 cmp	 edx, 16			; 00000010H
  000f4	73 04		 jae	 SHORT $LN171@Endwrite
  000f6	8d 4c 24 20	 lea	 ecx, DWORD PTR __Str$38308[esp+80]
$LN171@Endwrite:
  000fa	8b 74 24 30	 mov	 esi, DWORD PTR __Str$38308[esp+96]
  000fe	03 ce		 add	 ecx, esi
  00100	3b d9		 cmp	 ebx, ecx
  00102	72 0d		 jb	 SHORT $LN161@Endwrite
  00104	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00109	8b 54 24 34	 mov	 edx, DWORD PTR __Str$38308[esp+100]
  0010d	8b 44 24 20	 mov	 eax, DWORD PTR __Str$38308[esp+80]
$LN161@Endwrite:
  00111	8b 7c 24 30	 mov	 edi, DWORD PTR __Str$38308[esp+96]
  00115	83 fa 10	 cmp	 edx, 16			; 00000010H
  00118	0f 82 a4 00 00
	00		 jb	 $LN178@Endwrite
  0011e	8b f0		 mov	 esi, eax
  00120	85 c0		 test	 eax, eax
  00122	74 28		 je	 SHORT $LN182@Endwrite
$LN291@Endwrite:
  00124	8b c8		 mov	 ecx, eax
  00126	83 fa 10	 cmp	 edx, 16			; 00000010H
  00129	73 04		 jae	 SHORT $LN193@Endwrite
  0012b	8d 4c 24 20	 lea	 ecx, DWORD PTR __Str$38308[esp+80]
$LN193@Endwrite:
  0012f	3b ce		 cmp	 ecx, esi
  00131	77 19		 ja	 SHORT $LN182@Endwrite
  00133	8b c8		 mov	 ecx, eax
  00135	83 fa 10	 cmp	 edx, 16			; 00000010H
  00138	73 04		 jae	 SHORT $LN197@Endwrite
  0013a	8d 4c 24 20	 lea	 ecx, DWORD PTR __Str$38308[esp+80]
$LN197@Endwrite:
  0013e	8b 5c 24 30	 mov	 ebx, DWORD PTR __Str$38308[esp+96]
  00142	03 cb		 add	 ecx, ebx
  00144	8b 5c 24 14	 mov	 ebx, DWORD PTR $T74828[esp+76]
  00148	3b f1		 cmp	 esi, ecx
  0014a	76 0d		 jbe	 SHORT $LN183@Endwrite
$LN182@Endwrite:
  0014c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00151	8b 54 24 34	 mov	 edx, DWORD PTR __Str$38308[esp+100]
  00155	8b 44 24 20	 mov	 eax, DWORD PTR __Str$38308[esp+80]
$LN183@Endwrite:
  00159	8d 4c 24 1c	 lea	 ecx, DWORD PTR __Str$38308[esp+76]
  0015d	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00160	74 18		 je	 SHORT $LN200@Endwrite
  00162	83 fa 10	 cmp	 edx, 16			; 00000010H
  00165	73 04		 jae	 SHORT $LN210@Endwrite
  00167	8d 44 24 20	 lea	 eax, DWORD PTR __Str$38308[esp+80]
$LN210@Endwrite:
  0016b	8b 54 24 30	 mov	 edx, DWORD PTR __Str$38308[esp+96]
  0016f	03 c2		 add	 eax, edx
  00171	3b f0		 cmp	 esi, eax
  00173	72 05		 jb	 SHORT $LN200@Endwrite
  00175	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN200@Endwrite:
  0017a	8b 44 24 10	 mov	 eax, DWORD PTR _this$GSCopy$[esp+76]
  0017e	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00181	8b 11		 mov	 edx, DWORD PTR [ecx]
  00183	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  00186	8d 44 24 18	 lea	 eax, DWORD PTR __Dest$38304[esp+76]
  0018a	50		 push	 eax
  0018b	8b 44 24 14	 mov	 eax, DWORD PTR _this$GSCopy$[esp+80]
  0018f	03 df		 add	 ebx, edi
  00191	53		 push	 ebx
  00192	56		 push	 esi
  00193	83 c0 44	 add	 eax, 68			; 00000044H
  00196	50		 push	 eax
  00197	ff d2		 call	 edx
  00199	83 e8 00	 sub	 eax, 0
  0019c	74 2d		 je	 SHORT $LN7@Endwrite
  0019e	83 e8 01	 sub	 eax, 1
  001a1	74 30		 je	 SHORT $LN6@Endwrite
  001a3	83 e8 02	 sub	 eax, 2

; 523  : 
; 524  : 				default:
; 525  : 					return (false);	// conversion failed

  001a6	8d 4c 24 1c	 lea	 ecx, DWORD PTR __Str$38308[esp+76]
  001aa	0f 85 5c 01 00
	00		 jne	 $LN304@Endwrite

; 518  : 					break;
; 519  : 					}
; 520  : 
; 521  : 				case codecvt_base::noconv:
; 522  : 					return (true);	// nothing to do

  001b0	e9 64 01 00 00	 jmp	 $LN305@Endwrite

; 501  : 			for (; ; )
; 502  : 				switch (_Pcvt->unshift(_State,
; 503  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

$LN139@Endwrite:
  001b5	8d 5c 24 20	 lea	 ebx, DWORD PTR __Str$38308[esp+80]
  001b9	89 5c 24 14	 mov	 DWORD PTR $T74828[esp+76], ebx
  001bd	e9 f3 fe ff ff	 jmp	 $LN290@Endwrite
$LN178@Endwrite:
  001c2	8d 74 24 20	 lea	 esi, DWORD PTR __Str$38308[esp+80]
  001c6	e9 59 ff ff ff	 jmp	 $LN291@Endwrite
$LN7@Endwrite:

; 504  : 				{	// test result of homing conversion
; 505  : 				case codecvt_base::ok:
; 506  : 					_Wrotesome = false;	// homed successfully

  001cb	8b 44 24 10	 mov	 eax, DWORD PTR _this$GSCopy$[esp+76]
  001cf	c6 40 41 00	 mov	 BYTE PTR [eax+65], 0
$LN6@Endwrite:

; 507  : 
; 508  : 				case codecvt_base::partial:	// fall through
; 509  : 					{	// put any generated bytes
; 510  : 					size_t _Count = _Dest - &*_Str.begin();

  001d3	8b 54 24 34	 mov	 edx, DWORD PTR __Str$38308[esp+100]
  001d7	8b 44 24 20	 mov	 eax, DWORD PTR __Str$38308[esp+80]
  001db	83 fa 10	 cmp	 edx, 16			; 00000010H
  001de	0f 82 12 01 00
	00		 jb	 $LN217@Endwrite
  001e4	8b f0		 mov	 esi, eax
  001e6	85 c0		 test	 eax, eax
  001e8	74 24		 je	 SHORT $LN221@Endwrite
$LN292@Endwrite:
  001ea	8b c8		 mov	 ecx, eax
  001ec	83 fa 10	 cmp	 edx, 16			; 00000010H
  001ef	73 04		 jae	 SHORT $LN232@Endwrite
  001f1	8d 4c 24 20	 lea	 ecx, DWORD PTR __Str$38308[esp+80]
$LN232@Endwrite:
  001f5	3b ce		 cmp	 ecx, esi
  001f7	77 15		 ja	 SHORT $LN221@Endwrite
  001f9	8b c8		 mov	 ecx, eax
  001fb	83 fa 10	 cmp	 edx, 16			; 00000010H
  001fe	73 04		 jae	 SHORT $LN236@Endwrite
  00200	8d 4c 24 20	 lea	 ecx, DWORD PTR __Str$38308[esp+80]
$LN236@Endwrite:
  00204	8b 7c 24 30	 mov	 edi, DWORD PTR __Str$38308[esp+96]
  00208	03 cf		 add	 ecx, edi
  0020a	3b f1		 cmp	 esi, ecx
  0020c	76 0d		 jbe	 SHORT $LN222@Endwrite
$LN221@Endwrite:
  0020e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00213	8b 54 24 34	 mov	 edx, DWORD PTR __Str$38308[esp+100]
  00217	8b 44 24 20	 mov	 eax, DWORD PTR __Str$38308[esp+80]
$LN222@Endwrite:
  0021b	8d 4c 24 1c	 lea	 ecx, DWORD PTR __Str$38308[esp+76]
  0021f	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00222	74 22		 je	 SHORT $LN239@Endwrite
  00224	8b c8		 mov	 ecx, eax
  00226	83 fa 10	 cmp	 edx, 16			; 00000010H
  00229	73 04		 jae	 SHORT $LN249@Endwrite
  0022b	8d 4c 24 20	 lea	 ecx, DWORD PTR __Str$38308[esp+80]
$LN249@Endwrite:
  0022f	8b 7c 24 30	 mov	 edi, DWORD PTR __Str$38308[esp+96]
  00233	03 cf		 add	 ecx, edi
  00235	3b f1		 cmp	 esi, ecx
  00237	72 0d		 jb	 SHORT $LN239@Endwrite
  00239	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0023e	8b 54 24 34	 mov	 edx, DWORD PTR __Str$38308[esp+100]
  00242	8b 44 24 20	 mov	 eax, DWORD PTR __Str$38308[esp+80]
$LN239@Endwrite:
  00246	8b 7c 24 18	 mov	 edi, DWORD PTR __Dest$38304[esp+76]
  0024a	2b fe		 sub	 edi, esi

; 511  : 					if (0 < _Count && _Count !=
; 512  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))

  0024c	0f 84 81 00 00
	00		 je	 $LN5@Endwrite
  00252	83 fa 10	 cmp	 edx, 16			; 00000010H
  00255	0f 82 a4 00 00
	00		 jb	 $LN254@Endwrite
  0025b	8b f0		 mov	 esi, eax
  0025d	85 c0		 test	 eax, eax
  0025f	74 24		 je	 SHORT $LN258@Endwrite
$LN293@Endwrite:
  00261	8b c8		 mov	 ecx, eax
  00263	83 fa 10	 cmp	 edx, 16			; 00000010H
  00266	73 04		 jae	 SHORT $LN269@Endwrite
  00268	8d 4c 24 20	 lea	 ecx, DWORD PTR __Str$38308[esp+80]
$LN269@Endwrite:
  0026c	3b ce		 cmp	 ecx, esi
  0026e	77 15		 ja	 SHORT $LN258@Endwrite
  00270	8b c8		 mov	 ecx, eax
  00272	83 fa 10	 cmp	 edx, 16			; 00000010H
  00275	73 04		 jae	 SHORT $LN273@Endwrite
  00277	8d 4c 24 20	 lea	 ecx, DWORD PTR __Str$38308[esp+80]
$LN273@Endwrite:
  0027b	8b 5c 24 30	 mov	 ebx, DWORD PTR __Str$38308[esp+96]
  0027f	03 cb		 add	 ecx, ebx
  00281	3b f1		 cmp	 esi, ecx
  00283	76 0d		 jbe	 SHORT $LN259@Endwrite
$LN258@Endwrite:
  00285	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0028a	8b 54 24 34	 mov	 edx, DWORD PTR __Str$38308[esp+100]
  0028e	8b 44 24 20	 mov	 eax, DWORD PTR __Str$38308[esp+80]
$LN259@Endwrite:
  00292	8d 4c 24 1c	 lea	 ecx, DWORD PTR __Str$38308[esp+76]
  00296	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00299	74 18		 je	 SHORT $LN276@Endwrite
  0029b	83 fa 10	 cmp	 edx, 16			; 00000010H
  0029e	73 04		 jae	 SHORT $LN286@Endwrite
  002a0	8d 44 24 20	 lea	 eax, DWORD PTR __Str$38308[esp+80]
$LN286@Endwrite:
  002a4	8b 54 24 30	 mov	 edx, DWORD PTR __Str$38308[esp+96]
  002a8	03 c2		 add	 eax, edx
  002aa	3b f0		 cmp	 esi, eax
  002ac	72 05		 jb	 SHORT $LN276@Endwrite
  002ae	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN276@Endwrite:
  002b3	8b 44 24 10	 mov	 eax, DWORD PTR _this$GSCopy$[esp+76]
  002b7	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  002ba	51		 push	 ecx
  002bb	57		 push	 edi
  002bc	6a 01		 push	 1
  002be	56		 push	 esi
  002bf	e8 00 00 00 00	 call	 _fwrite
  002c4	83 c4 10	 add	 esp, 16			; 00000010H
  002c7	3b f8		 cmp	 edi, eax
  002c9	75 3d		 jne	 SHORT $LN288@Endwrite
  002cb	8b 54 24 34	 mov	 edx, DWORD PTR __Str$38308[esp+100]
  002cf	8b 44 24 20	 mov	 eax, DWORD PTR __Str$38308[esp+80]
$LN5@Endwrite:

; 514  : 					if (!_Wrotesome)

  002d3	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$GSCopy$[esp+76]
  002d7	80 79 41 00	 cmp	 BYTE PTR [ecx+65], 0
  002db	74 38		 je	 SHORT $LN289@Endwrite

; 516  : 					if (_Count == 0)

  002dd	85 ff		 test	 edi, edi
  002df	0f 85 bd fd ff
	ff		 jne	 $LL11@Endwrite

; 517  : 						_Str.append(_STRING_INC, '\0');	// try with more space

  002e5	57		 push	 edi
  002e6	6a 08		 push	 8
  002e8	8d 4c 24 24	 lea	 ecx, DWORD PTR __Str$38308[esp+84]
  002ec	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 526  : 				}

  002f1	e9 a4 fd ff ff	 jmp	 $LN302@Endwrite

; 507  : 
; 508  : 				case codecvt_base::partial:	// fall through
; 509  : 					{	// put any generated bytes
; 510  : 					size_t _Count = _Dest - &*_Str.begin();

$LN217@Endwrite:
  002f6	8d 74 24 20	 lea	 esi, DWORD PTR __Str$38308[esp+80]
  002fa	e9 eb fe ff ff	 jmp	 $LN292@Endwrite

; 511  : 					if (0 < _Count && _Count !=
; 512  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))

$LN254@Endwrite:
  002ff	8d 74 24 20	 lea	 esi, DWORD PTR __Str$38308[esp+80]
  00303	e9 59 ff ff ff	 jmp	 $LN293@Endwrite
$LN288@Endwrite:

; 513  : 						return (false);	// write failed

  00308	8d 4c 24 1c	 lea	 ecx, DWORD PTR __Str$38308[esp+76]
$LN304@Endwrite:
  0030c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN303@Endwrite:
  00311	32 c0		 xor	 al, al
  00313	eb 0b		 jmp	 SHORT $LN13@Endwrite
$LN289@Endwrite:

; 515  : 						return (true);

  00315	8d 4c 24 1c	 lea	 ecx, DWORD PTR __Str$38308[esp+76]
$LN305@Endwrite:
  00319	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN14@Endwrite:

; 492  : 			return (true);

  0031e	b0 01		 mov	 al, 1
$LN13@Endwrite:

; 527  : 			}
; 528  : 		}

  00320	8b 4c 24 40	 mov	 ecx, DWORD PTR __$EHRec$[esp+76]
  00324	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0032b	59		 pop	 ecx
  0032c	5f		 pop	 edi
  0032d	5e		 pop	 esi
  0032e	5b		 pop	 ebx
  0032f	8b 4c 24 28	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+60]
  00333	33 cc		 xor	 ecx, esp
  00335	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0033a	8b e5		 mov	 esp, ebp
  0033c	5d		 pop	 ebp
  0033d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Str$38308[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 c4	 lea	 eax, DWORD PTR [edx-60]
  0000f	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	83 c0 0c	 add	 eax, 12			; 0000000cH
  0001c	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
xdata$x	ENDS
;	COMDAT ?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T75316 = -164						; size = 4
$T75310 = -160						; size = 4
$T75312 = -156						; size = 28
$T75311 = -128						; size = 116
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::codecvt<char,char,int>::_Getcat, COMDAT

; 783  : 		{	// return locale category mask and construct standard facet

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00014	53		 push	 ebx
  00015	55		 push	 ebp
  00016	56		 push	 esi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c4		 xor	 eax, esp
  0001e	50		 push	 eax
  0001f	8d 84 24 a8 00
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+180]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 784  : 		if (_Ppf != 0 && *_Ppf == 0)

  0002c	8b ac 24 b8 00
	00 00		 mov	 ebp, DWORD PTR __Ppf$[esp+176]
  00033	33 db		 xor	 ebx, ebx
  00035	89 5c 24 10	 mov	 DWORD PTR $T75316[esp+180], ebx
  00039	85 ed		 test	 ebp, ebp
  0003b	0f 84 a1 00 00
	00		 je	 $LN50@Getcat@3
  00041	39 5d 00	 cmp	 DWORD PTR [ebp], ebx
  00044	0f 85 98 00 00
	00		 jne	 $LN50@Getcat@3

; 785  : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 786  : 				_Locinfo(_Ploc->name()));

  0004a	6a 08		 push	 8
  0004c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00051	8b f0		 mov	 esi, eax
  00053	83 c4 04	 add	 esp, 4
  00056	89 74 24 14	 mov	 DWORD PTR $T75310[esp+180], esi
  0005a	89 9c 24 b0 00
	00 00		 mov	 DWORD PTR __$EHRec$[esp+188], ebx
  00061	85 f6		 test	 esi, esi
  00063	74 3f		 je	 SHORT $LN4@Getcat@3
  00065	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR __Ploc$[esp+176]
  0006c	8d 44 24 18	 lea	 eax, DWORD PTR $T75312[esp+180]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::locale::name
  00076	c6 84 24 b0 00
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+188], 1
  0007e	50		 push	 eax
  0007f	8d 4c 24 38	 lea	 ecx, DWORD PTR $T75311[esp+184]
  00083	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR $T75316[esp+184], 1
  0008b	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Locinfo::_Locinfo
  00090	bb 03 00 00 00	 mov	 ebx, 3
  00095	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0009c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$codecvt@DDH@std@@6B@
  000a2	eb 02		 jmp	 SHORT $LN5@Getcat@3
$LN4@Getcat@3:
  000a4	33 f6		 xor	 esi, esi
$LN5@Getcat@3:
  000a6	c7 84 24 b0 00
	00 00 02 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+188], 2
  000b1	89 75 00	 mov	 DWORD PTR [ebp], esi
  000b4	f6 c3 02	 test	 bl, 2
  000b7	74 10		 je	 SHORT $LN11@Getcat@3
  000b9	83 e3 fd	 and	 ebx, -3			; fffffffdH
  000bc	8d 4c 24 34	 lea	 ecx, DWORD PTR $T75311[esp+180]
  000c0	89 5c 24 10	 mov	 DWORD PTR $T75316[esp+180], ebx
  000c4	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN11@Getcat@3:
  000c9	f6 c3 01	 test	 bl, 1
  000cc	74 14		 je	 SHORT $LN50@Getcat@3
  000ce	83 7c 24 30 10	 cmp	 DWORD PTR $T75312[esp+204], 16 ; 00000010H
  000d3	72 0d		 jb	 SHORT $LN50@Getcat@3
  000d5	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T75312[esp+184]
  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000df	83 c4 04	 add	 esp, 4
$LN50@Getcat@3:

; 787  : 		return (_X_CTYPE);

  000e2	b8 02 00 00 00	 mov	 eax, 2

; 788  : 		}

  000e7	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+180]
  000ee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f5	59		 pop	 ecx
  000f6	5e		 pop	 esi
  000f7	5d		 pop	 ebp
  000f8	5b		 pop	 ebx
  000f9	81 c4 a4 00 00
	00		 add	 esp, 164		; 000000a4H
  000ff	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR $T75310[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__unwindfunclet$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
  0000e	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR $T75316[ebp]
  00014	83 e0 01	 and	 eax, 1
  00017	0f 84 12 00 00
	00		 je	 $LN8@Getcat@3
  0001d	83 a5 5c ff ff
	ff fe		 and	 DWORD PTR $T75316[ebp], -2 ; fffffffeH
  00024	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T75312[ebp]
  0002a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@Getcat@3:
  0002f	c3		 ret	 0
__ehhandler$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  00030	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00034	8d 82 5c ff ff
	ff		 lea	 eax, DWORD PTR [edx-164]
  0003a	8b 8a 58 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-168]
  00040	33 c8		 xor	 ecx, eax
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0004c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::codecvt<char,char,int>::_Getcat
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\fstream
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT
__Fileposition$ = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Pos$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 414  : 		{	// change position to _Pos

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8

; 415  : 		fpos_t _Fileposition = _POS_TYPE_TO_FPOS_T(_Pos);

  00009	8b 45 14	 mov	 eax, DWORD PTR __Pos$[ebp+8]
  0000c	56		 push	 esi
  0000d	8b f1		 mov	 esi, ecx

; 416  : 		off_type _Off = (off_type)_Pos - (off_type)_FPOSOFF(_Fileposition);
; 417  : 
; 418  : 		if (_Myfile == 0 || !_Endwrite()
; 419  : 			|| fsetpos(_Myfile, &_Fileposition) != 0
; 420  : 			|| _Off != 0 && fseek(_Myfile, (long)_Off, SEEK_CUR) != 0
; 421  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

  0000f	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00013	8b 4d 18	 mov	 ecx, DWORD PTR __Pos$[ebp+12]
  00016	57		 push	 edi
  00017	8b 7d 0c	 mov	 edi, DWORD PTR __Pos$[ebp]
  0001a	89 44 24 08	 mov	 DWORD PTR __Fileposition$[esp+16], eax
  0001e	89 4c 24 0c	 mov	 DWORD PTR __Fileposition$[esp+20], ecx
  00022	0f 84 9e 00 00
	00		 je	 $LN3@seekpos
  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  0002f	84 c0		 test	 al, al
  00031	0f 84 8f 00 00
	00		 je	 $LN3@seekpos
  00037	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  0003a	8d 54 24 08	 lea	 edx, DWORD PTR __Fileposition$[esp+16]
  0003e	52		 push	 edx
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _fsetpos
  00045	83 c4 08	 add	 esp, 8
  00048	85 c0		 test	 eax, eax
  0004a	75 7a		 jne	 SHORT $LN3@seekpos
  0004c	85 ff		 test	 edi, edi
  0004e	74 13		 je	 SHORT $LN2@seekpos
  00050	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  00053	6a 01		 push	 1
  00055	57		 push	 edi
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 _fseek
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005f	85 c0		 test	 eax, eax
  00061	75 63		 jne	 SHORT $LN3@seekpos
$LN2@seekpos:
  00063	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00066	8d 54 24 08	 lea	 edx, DWORD PTR __Fileposition$[esp+16]
  0006a	52		 push	 edx
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _fgetpos
  00071	83 c4 08	 add	 esp, 8
  00074	85 c0		 test	 eax, eax
  00076	75 4e		 jne	 SHORT $LN3@seekpos

; 423  : 
; 424  : 		_State = _POS_TYPE_TO_STATE(_Pos);

  00078	8b 4d 1c	 mov	 ecx, DWORD PTR __Pos$[ebp+16]

; 425  : 
; 426  : 		if (_Mysb::gptr() == &_Mychar)

  0007b	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  0007e	89 4e 44	 mov	 DWORD PTR [esi+68], ecx
  00081	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  00084	39 0a		 cmp	 DWORD PTR [edx], ecx
  00086	75 19		 jne	 SHORT $LN17@seekpos

; 427  : 			_Mysb::setg(&_Mychar, &_Mychar + 1,
; 428  : 				&_Mychar + 1);	// discard any putback

  00088	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0008b	89 0a		 mov	 DWORD PTR [edx], ecx
  0008d	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00090	8d 46 41	 lea	 eax, DWORD PTR [esi+65]
  00093	8b d6		 mov	 edx, esi
  00095	2b d0		 sub	 edx, eax
  00097	89 01		 mov	 DWORD PTR [ecx], eax
  00099	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0009c	83 c2 41	 add	 edx, 65			; 00000041H
  0009f	89 10		 mov	 DWORD PTR [eax], edx
$LN17@seekpos:

; 429  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a4	8b 4c 24 08	 mov	 ecx, DWORD PTR __Fileposition$[esp+16]
  000a8	8b 54 24 0c	 mov	 edx, DWORD PTR __Fileposition$[esp+20]
  000ac	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000af	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  000b2	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000b8	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  000bb	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 430  : 			_Fileposition));	// return new position
; 431  : 		}

  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 20 00	 ret	 32			; 00000020H
$LN3@seekpos:

; 422  : 			return (pos_type(_BADOFF));	// report failure

  000c6	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?_BADOFF@std@@3JB ; std::_BADOFF

; 430  : 			_Fileposition));	// return new position
; 431  : 		}

  000cf	5f		 pop	 edi
  000d0	89 10		 mov	 DWORD PTR [eax], edx
  000d2	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  000d9	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  000e0	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  000e7	5e		 pop	 esi
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT
__Fileposition$ = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Way$ = 16						; size = 4
___formal$ = 20						; size = 4
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 390  : 		{	// change position by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx

; 391  : 		fpos_t _Fileposition;
; 392  : 
; 393  : 		if (_Mysb::gptr() == &_Mychar	// something putback
; 394  : 			&& _Way == ios_base::cur	// a relative seek
; 395  : 			&& _Pcvt == 0)	// not converting

  0000d	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00010	57		 push	 edi
  00011	8d 7e 40	 lea	 edi, DWORD PTR [esi+64]
  00014	39 38		 cmp	 DWORD PTR [eax], edi
  00016	75 12		 jne	 SHORT $LN19@seekoff
  00018	83 7d 10 01	 cmp	 DWORD PTR __Way$[ebp], 1
  0001c	75 0c		 jne	 SHORT $LN19@seekoff
  0001e	83 7e 3c 00	 cmp	 DWORD PTR [esi+60], 0
  00022	75 06		 jne	 SHORT $LN19@seekoff

; 396  : 			_Off -= (off_type)sizeof (_Elem);	// back up over _Elem bytes

  00024	8b 5d 0c	 mov	 ebx, DWORD PTR __Off$[ebp]
  00027	4b		 dec	 ebx
  00028	eb 03		 jmp	 SHORT $LN6@seekoff
$LN19@seekoff:
  0002a	8b 5d 0c	 mov	 ebx, DWORD PTR __Off$[ebp]
$LN6@seekoff:

; 397  : 
; 398  : 		if (_Myfile == 0 || !_Endwrite()
; 399  : 			|| (_Off != 0 || _Way != ios_base::cur)
; 400  : 				&& fseek(_Myfile, (long)_Off, _Way) != 0
; 401  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

  0002d	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00031	0f 84 83 00 00
	00		 je	 $LN4@seekoff
  00037	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  0003c	84 c0		 test	 al, al
  0003e	74 7a		 je	 SHORT $LN4@seekoff
  00040	85 db		 test	 ebx, ebx
  00042	75 06		 jne	 SHORT $LN2@seekoff
  00044	83 7d 10 01	 cmp	 DWORD PTR __Way$[ebp], 1
  00048	74 15		 je	 SHORT $LN3@seekoff
$LN2@seekoff:
  0004a	8b 4d 10	 mov	 ecx, DWORD PTR __Way$[ebp]
  0004d	8b 56 4c	 mov	 edx, DWORD PTR [esi+76]
  00050	51		 push	 ecx
  00051	53		 push	 ebx
  00052	52		 push	 edx
  00053	e8 00 00 00 00	 call	 _fseek
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	85 c0		 test	 eax, eax
  0005d	75 5b		 jne	 SHORT $LN4@seekoff
$LN3@seekoff:
  0005f	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  00062	8d 44 24 10	 lea	 eax, DWORD PTR __Fileposition$[esp+24]
  00066	50		 push	 eax
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 _fgetpos
  0006d	83 c4 08	 add	 esp, 8
  00070	85 c0		 test	 eax, eax
  00072	75 46		 jne	 SHORT $LN4@seekoff

; 403  : 
; 404  : 		if (_Mysb::gptr() == &_Mychar)

  00074	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00077	39 3a		 cmp	 DWORD PTR [edx], edi
  00079	75 19		 jne	 SHORT $LN15@seekoff

; 405  : 			_Mysb::setg(&_Mychar, &_Mychar + 1,
; 406  : 				&_Mychar + 1);	// discard any putback

  0007b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0007e	89 39		 mov	 DWORD PTR [ecx], edi
  00080	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00083	8d 46 41	 lea	 eax, DWORD PTR [esi+65]
  00086	8b ce		 mov	 ecx, esi
  00088	89 02		 mov	 DWORD PTR [edx], eax
  0008a	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  0008d	2b c8		 sub	 ecx, eax
  0008f	83 c1 41	 add	 ecx, 65			; 00000041H
  00092	89 0a		 mov	 DWORD PTR [edx], ecx
$LN15@seekoff:

; 407  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  00094	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00097	8b 4c 24 10	 mov	 ecx, DWORD PTR __Fileposition$[esp+24]
  0009b	8b 54 24 14	 mov	 edx, DWORD PTR __Fileposition$[esp+28]
  0009f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000a2	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  000a5	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000ab	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  000ae	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 408  : 			_Fileposition));	// return new position
; 409  : 		}

  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 10 00	 ret	 16			; 00000010H
$LN4@seekoff:

; 402  : 			return (pos_type(_BADOFF));	// report failure

  000ba	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000bd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?_BADOFF@std@@3JB ; std::_BADOFF

; 408  : 			_Fileposition));	// return new position
; 409  : 		}

  000c3	5f		 pop	 edi
  000c4	33 c9		 xor	 ecx, ecx
  000c6	5e		 pop	 esi
  000c7	89 10		 mov	 DWORD PTR [eax], edx
  000c9	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000cc	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  000cf	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000d2	5b		 pop	 ebx
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c2 10 00	 ret	 16			; 00000010H
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
xdata$x	ENDS
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T75531 = -164						; size = 4
$T75525 = -160						; size = 4
$T75527 = -156						; size = 28
$T75526 = -128						; size = 116
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 1790 : 		{	// return locale category mask and construct standard facet

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c4		 xor	 eax, esp
  0001e	50		 push	 eax
  0001f	8d 84 24 a8 00
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+180]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1791 : 		if (_Ppf != 0 && *_Ppf == 0)

  0002c	8b bc 24 b8 00
	00 00		 mov	 edi, DWORD PTR __Ppf$[esp+176]
  00033	33 db		 xor	 ebx, ebx
  00035	89 5c 24 10	 mov	 DWORD PTR $T75531[esp+180], ebx
  00039	85 ff		 test	 edi, edi
  0003b	0f 84 9c 00 00
	00		 je	 $LN42@Getcat@4
  00041	39 1f		 cmp	 DWORD PTR [edi], ebx
  00043	0f 85 94 00 00
	00		 jne	 $LN42@Getcat@4

; 1792 : 			*_Ppf = _NEW_CRT ctype<_Elem>(
; 1793 : 				_Locinfo(_Ploc->name()));

  00049	6a 18		 push	 24			; 00000018H
  0004b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00050	8b f0		 mov	 esi, eax
  00052	83 c4 04	 add	 esp, 4
  00055	89 74 24 14	 mov	 DWORD PTR $T75525[esp+180], esi
  00059	89 9c 24 b0 00
	00 00		 mov	 DWORD PTR __$EHRec$[esp+188], ebx
  00060	85 f6		 test	 esi, esi
  00062	74 3c		 je	 SHORT $LN4@Getcat@4
  00064	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR __Ploc$[esp+176]
  0006b	8d 44 24 18	 lea	 eax, DWORD PTR $T75527[esp+180]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 ?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::locale::name
  00075	c6 84 24 b0 00
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+188], 1
  0007d	50		 push	 eax
  0007e	8d 4c 24 38	 lea	 ecx, DWORD PTR $T75526[esp+184]
  00082	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR $T75531[esp+184], 1
  0008a	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Locinfo::_Locinfo
  0008f	6a 00		 push	 0
  00091	50		 push	 eax
  00092	8b ce		 mov	 ecx, esi
  00094	bb 03 00 00 00	 mov	 ebx, 3
  00099	e8 00 00 00 00	 call	 ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ; std::ctype<char>::ctype<char>
  0009e	eb 02		 jmp	 SHORT $LN5@Getcat@4
$LN4@Getcat@4:
  000a0	33 c0		 xor	 eax, eax
$LN5@Getcat@4:
  000a2	c7 84 24 b0 00
	00 00 02 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+188], 2
  000ad	89 07		 mov	 DWORD PTR [edi], eax
  000af	f6 c3 02	 test	 bl, 2
  000b2	74 10		 je	 SHORT $LN11@Getcat@4
  000b4	83 e3 fd	 and	 ebx, -3			; fffffffdH
  000b7	8d 4c 24 34	 lea	 ecx, DWORD PTR $T75526[esp+180]
  000bb	89 5c 24 10	 mov	 DWORD PTR $T75531[esp+180], ebx
  000bf	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN11@Getcat@4:
  000c4	f6 c3 01	 test	 bl, 1
  000c7	74 14		 je	 SHORT $LN42@Getcat@4
  000c9	83 7c 24 30 10	 cmp	 DWORD PTR $T75527[esp+204], 16 ; 00000010H
  000ce	72 0d		 jb	 SHORT $LN42@Getcat@4
  000d0	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T75527[esp+184]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000da	83 c4 04	 add	 esp, 4
$LN42@Getcat@4:

; 1794 : 		return (_X_CTYPE);

  000dd	b8 02 00 00 00	 mov	 eax, 2

; 1795 : 		}

  000e2	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+180]
  000e9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f0	59		 pop	 ecx
  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx
  000f4	81 c4 a4 00 00
	00		 add	 esp, 164		; 000000a4H
  000fa	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR $T75525[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
  0000e	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR $T75531[ebp]
  00014	83 e0 01	 and	 eax, 1
  00017	0f 84 12 00 00
	00		 je	 $LN8@Getcat@4
  0001d	83 a5 5c ff ff
	ff fe		 and	 DWORD PTR $T75531[ebp], -2 ; fffffffeH
  00024	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T75527[ebp]
  0002a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@Getcat@4:
  0002f	c3		 ret	 0
__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  00030	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00034	8d 82 5c ff ff
	ff		 lea	 eax, DWORD PTR [edx-164]
  0003a	8b 8a 58 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-168]
  00040	33 c8		 xor	 ecx, eax
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0004c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<char>::_Getcat
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\fstream
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ
_TEXT	SEGMENT
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT
; _this$ = ecx

; 205  : 		{	// close the C stream

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 206  : 		_Myt *_Ans = this;
; 207  : 		if (_Myfile == 0)

  00004	33 db		 xor	 ebx, ebx
  00006	57		 push	 edi
  00007	8b fe		 mov	 edi, esi
  00009	39 5e 4c	 cmp	 DWORD PTR [esi+76], ebx

; 208  : 			_Ans = 0;
; 209  : 		else

  0000c	74 1a		 je	 SHORT $LN18@close

; 210  : 			{	// put any homing sequence and close file
; 211  : 			if (!_Endwrite())

  0000e	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  00013	84 c0		 test	 al, al

; 212  : 				_Ans = 0;
; 213  : 			if (fclose(_Myfile) != 0)

  00015	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00018	50		 push	 eax
  00019	0f 44 fb	 cmove	 edi, ebx
  0001c	e8 00 00 00 00	 call	 _fclose
  00021	83 c4 04	 add	 esp, 4
  00024	85 c0		 test	 eax, eax
  00026	74 02		 je	 SHORT $LN1@close
$LN18@close:

; 214  : 				_Ans = 0;

  00028	33 ff		 xor	 edi, edi
$LN1@close:

; 215  : 			}
; 216  : 		_Init(0, _Closefl);

  0002a	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0002d	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00030	88 5e 48	 mov	 BYTE PTR [esi+72], bl
  00033	88 5e 41	 mov	 BYTE PTR [esi+65], bl
  00036	8d 56 18	 lea	 edx, DWORD PTR [esi+24]
  00039	89 56 20	 mov	 DWORD PTR [esi+32], edx
  0003c	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  0003f	89 4e 24	 mov	 DWORD PTR [esi+36], ecx
  00042	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00045	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00048	8d 56 28	 lea	 edx, DWORD PTR [esi+40]
  0004b	89 56 30	 mov	 DWORD PTR [esi+48], edx
  0004e	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  00051	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  00054	89 18		 mov	 DWORD PTR [eax], ebx
  00056	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00059	89 1a		 mov	 DWORD PTR [edx], ebx
  0005b	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0005e	89 18		 mov	 DWORD PTR [eax], ebx
  00060	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00063	89 19		 mov	 DWORD PTR [ecx], ebx
  00065	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00068	89 1a		 mov	 DWORD PTR [edx], ebx
  0006a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0006d	89 18		 mov	 DWORD PTR [eax], ebx
  0006f	89 5e 4c	 mov	 DWORD PTR [esi+76], ebx
  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA

; 217  : 		return (_Ans);

  00078	8b c7		 mov	 eax, edi

; 218  : 		}

  0007a	5f		 pop	 edi
  0007b	89 5e 3c	 mov	 DWORD PTR [esi+60], ebx
  0007e	89 4e 44	 mov	 DWORD PTR [esi+68], ecx
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	c3		 ret	 0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Psave$38728 = -36					; size = 4
__Lock$79380 = -32					; size = 4
__Lock$38727 = -28					; size = 4
$T79372 = -24						; size = 12
__$EHRec$ = -12						; size = 12
__Lock$79402 = 8					; size = 4
__Loc$ = 8						; size = 4
??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,int> >, COMDAT

; 486  : {	// get facet reference from locale

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 18	 sub	 esp, 24			; 00000018H
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c4		 xor	 eax, esp
  0001b	50		 push	 eax
  0001c	8d 44 24 28	 lea	 eax, DWORD PTR __$EHRec$[esp+52]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 487  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00026	6a 00		 push	 0
  00028	8d 4c 24 1c	 lea	 ecx, DWORD PTR __Lock$38727[esp+56]
  0002c	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00031	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+60], 0

; 488  : 		const locale::facet *_Psave =
; 489  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 490  : 
; 491  : 		size_t _Id = _Facet::id;

  00039	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?id@?$codecvt@DDH@std@@2V0locale@2@A, 0 ; std::codecvt<char,char,int>::id
  00040	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
  00046	89 5c 24 10	 mov	 DWORD PTR __Psave$38728[esp+52], ebx
  0004a	75 2d		 jne	 SHORT $LN11@use_facet@4
  0004c	6a 00		 push	 0
  0004e	8d 4c 24 18	 lea	 ecx, DWORD PTR __Lock$79380[esp+56]
  00052	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00057	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?id@?$codecvt@DDH@std@@2V0locale@2@A, 0 ; std::codecvt<char,char,int>::id
  0005e	75 10		 jne	 SHORT $LN10@use_facet@4
  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00065	40		 inc	 eax
  00066	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  0006b	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$codecvt@DDH@std@@2V0locale@2@A, eax ; std::codecvt<char,char,int>::id
$LN10@use_facet@4:
  00070	8d 4c 24 14	 lea	 ecx, DWORD PTR __Lock$79380[esp+52]
  00074	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
$LN11@use_facet@4:

; 492  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00079	8b 7c 24 38	 mov	 edi, DWORD PTR __Loc$[esp+48]
  0007d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?id@?$codecvt@DDH@std@@2V0locale@2@A ; std::codecvt<char,char,int>::id
  00083	8b 07		 mov	 eax, DWORD PTR [edi]
  00085	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  00088	73 22		 jae	 SHORT $LN20@use_facet@4
  0008a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0008d	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00090	85 c9		 test	 ecx, ecx
  00092	75 1c		 jne	 SHORT $LN16@use_facet@4
$LN30@use_facet@4:
  00094	80 78 14 00	 cmp	 BYTE PTR [eax+20], 0
  00098	74 16		 je	 SHORT $LN16@use_facet@4
  0009a	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009f	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  000a2	73 12		 jae	 SHORT $LN31@use_facet@4
  000a4	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000a7	8b 34 b2	 mov	 esi, DWORD PTR [edx+esi*4]
  000aa	eb 06		 jmp	 SHORT $LN15@use_facet@4
$LN20@use_facet@4:
  000ac	33 c9		 xor	 ecx, ecx
  000ae	eb e4		 jmp	 SHORT $LN30@use_facet@4
$LN16@use_facet@4:
  000b0	8b f1		 mov	 esi, ecx
$LN15@use_facet@4:

; 493  : 
; 494  : 		if (_Pf != 0)

  000b2	85 f6		 test	 esi, esi
  000b4	75 6b		 jne	 SHORT $LN28@use_facet@4
$LN31@use_facet@4:

; 495  : 			;	// got facet from locale
; 496  : 		else if (_Psave != 0)

  000b6	85 db		 test	 ebx, ebx
  000b8	74 04		 je	 SHORT $LN4@use_facet@4

; 497  : 			_Pf = _Psave;	// lazy facet already allocated

  000ba	8b f3		 mov	 esi, ebx
  000bc	eb 63		 jmp	 SHORT $LN28@use_facet@4
$LN4@use_facet@4:

; 498  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000be	8d 44 24 10	 lea	 eax, DWORD PTR __Psave$38728[esp+52]
  000c2	57		 push	 edi
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 ?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::codecvt<char,char,int>::_Getcat
  000c9	83 c4 08	 add	 esp, 8
  000cc	83 f8 ff	 cmp	 eax, -1
  000cf	75 1d		 jne	 SHORT $LN2@use_facet@4

; 499  : 
; 500  :  #if _HAS_EXCEPTIONS
; 501  : 		_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000d6	8d 4c 24 20	 lea	 ecx, DWORD PTR $T79372[esp+56]
  000da	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@PBD@Z ; std::bad_cast::bad_cast
  000df	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000e4	8d 4c 24 20	 lea	 ecx, DWORD PTR $T79372[esp+56]
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN34@use_facet@4:
$LN2@use_facet@4:

; 502  : 
; 503  : 	#else /* _HAS_EXCEPTIONS */
; 504  : 			abort();	// lazy disallowed
; 505  : 	#endif /* _HAS_EXCEPTIONS */
; 506  : 
; 507  : 		else
; 508  : 			{	// queue up lazy facet for destruction
; 509  : 			_Pf = _Psave;

  000ee	8b 74 24 10	 mov	 esi, DWORD PTR __Psave$38728[esp+52]

; 510  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 511  : 
; 512  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 513  : 			_Pfmod->_Incref();

  000f2	6a 00		 push	 0
  000f4	8d 4c 24 3c	 lea	 ecx, DWORD PTR __Lock$79402[esp+52]
  000f8	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
  000fe	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00103	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00106	83 f8 ff	 cmp	 eax, -1
  00109	73 04		 jae	 SHORT $LN24@use_facet@4
  0010b	40		 inc	 eax
  0010c	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN24@use_facet@4:
  0010f	8d 4c 24 38	 lea	 ecx, DWORD PTR __Lock$79402[esp+48]
  00113	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit

; 514  : 			_Pfmod->_Register();

  00118	56		 push	 esi
  00119	e8 00 00 00 00	 call	 ?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
  0011e	83 c4 04	 add	 esp, 4
$LN28@use_facet@4:

; 515  : 			}
; 516  : 
; 517  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00121	8d 4c 24 18	 lea	 ecx, DWORD PTR __Lock$38727[esp+52]
  00125	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+60], -1
  0012d	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00132	8b c6		 mov	 eax, esi

; 518  : 	_END_LOCK()
; 519  : 	}

  00134	8b 4c 24 28	 mov	 ecx, DWORD PTR __$EHRec$[esp+52]
  00138	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013f	59		 pop	 ecx
  00140	5f		 pop	 edi
  00141	5e		 pop	 esi
  00142	5b		 pop	 ebx
  00143	83 c4 24	 add	 esp, 36			; 00000024H
  00146	c3		 ret	 0
$LN33@use_facet@4:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$38727[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 dc	 lea	 eax, DWORD PTR [edx-36]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,int> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Psave$38532 = -36					; size = 4
__Lock$79428 = -32					; size = 4
__Lock$38531 = -28					; size = 4
$T79420 = -24						; size = 12
__$EHRec$ = -12						; size = 12
__Lock$79450 = 8					; size = 4
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 486  : {	// get facet reference from locale

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c4		 xor	 eax, esp
  0001b	50		 push	 eax
  0001c	8d 44 24 2c	 lea	 eax, DWORD PTR __$EHRec$[esp+56]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 487  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00026	6a 00		 push	 0
  00028	8d 4c 24 20	 lea	 ecx, DWORD PTR __Lock$38531[esp+60]
  0002c	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00031	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+64], 0

; 488  : 		const locale::facet *_Psave =
; 489  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 490  : 
; 491  : 		size_t _Id = _Facet::id;

  00039	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, 0 ; std::ctype<char>::id
  00040	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  00046	89 5c 24 14	 mov	 DWORD PTR __Psave$38532[esp+56], ebx
  0004a	75 2d		 jne	 SHORT $LN11@use_facet@5
  0004c	6a 00		 push	 0
  0004e	8d 4c 24 1c	 lea	 ecx, DWORD PTR __Lock$79428[esp+60]
  00052	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00057	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, 0 ; std::ctype<char>::id
  0005e	75 10		 jne	 SHORT $LN10@use_facet@5
  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00065	40		 inc	 eax
  00066	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  0006b	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, eax ; std::ctype<char>::id
$LN10@use_facet@5:
  00070	8d 4c 24 18	 lea	 ecx, DWORD PTR __Lock$79428[esp+56]
  00074	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
$LN11@use_facet@5:

; 492  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00079	8b 7c 24 3c	 mov	 edi, DWORD PTR __Loc$[esp+52]
  0007d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
  00083	8b 07		 mov	 eax, DWORD PTR [edi]
  00085	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  00088	73 22		 jae	 SHORT $LN20@use_facet@5
  0008a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0008d	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00090	85 c9		 test	 ecx, ecx
  00092	75 1c		 jne	 SHORT $LN16@use_facet@5
$LN30@use_facet@5:
  00094	80 78 14 00	 cmp	 BYTE PTR [eax+20], 0
  00098	74 16		 je	 SHORT $LN16@use_facet@5
  0009a	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009f	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  000a2	73 12		 jae	 SHORT $LN31@use_facet@5
  000a4	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000a7	8b 34 b2	 mov	 esi, DWORD PTR [edx+esi*4]
  000aa	eb 06		 jmp	 SHORT $LN15@use_facet@5
$LN20@use_facet@5:
  000ac	33 c9		 xor	 ecx, ecx
  000ae	eb e4		 jmp	 SHORT $LN30@use_facet@5
$LN16@use_facet@5:
  000b0	8b f1		 mov	 esi, ecx
$LN15@use_facet@5:

; 493  : 
; 494  : 		if (_Pf != 0)

  000b2	85 f6		 test	 esi, esi
  000b4	75 6b		 jne	 SHORT $LN28@use_facet@5
$LN31@use_facet@5:

; 495  : 			;	// got facet from locale
; 496  : 		else if (_Psave != 0)

  000b6	85 db		 test	 ebx, ebx
  000b8	74 04		 je	 SHORT $LN4@use_facet@5

; 497  : 			_Pf = _Psave;	// lazy facet already allocated

  000ba	8b f3		 mov	 esi, ebx
  000bc	eb 63		 jmp	 SHORT $LN28@use_facet@5
$LN4@use_facet@5:

; 498  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000be	8d 44 24 14	 lea	 eax, DWORD PTR __Psave$38532[esp+56]
  000c2	57		 push	 edi
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
  000c9	83 c4 08	 add	 esp, 8
  000cc	83 f8 ff	 cmp	 eax, -1
  000cf	75 1d		 jne	 SHORT $LN2@use_facet@5

; 499  : 
; 500  :  #if _HAS_EXCEPTIONS
; 501  : 		_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000d6	8d 4c 24 24	 lea	 ecx, DWORD PTR $T79420[esp+60]
  000da	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@PBD@Z ; std::bad_cast::bad_cast
  000df	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000e4	8d 4c 24 24	 lea	 ecx, DWORD PTR $T79420[esp+60]
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN34@use_facet@5:
$LN2@use_facet@5:

; 502  : 
; 503  : 	#else /* _HAS_EXCEPTIONS */
; 504  : 			abort();	// lazy disallowed
; 505  : 	#endif /* _HAS_EXCEPTIONS */
; 506  : 
; 507  : 		else
; 508  : 			{	// queue up lazy facet for destruction
; 509  : 			_Pf = _Psave;

  000ee	8b 74 24 14	 mov	 esi, DWORD PTR __Psave$38532[esp+56]

; 510  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 511  : 
; 512  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 513  : 			_Pfmod->_Incref();

  000f2	6a 00		 push	 0
  000f4	8d 4c 24 40	 lea	 ecx, DWORD PTR __Lock$79450[esp+56]
  000f8	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<char> >::_Psave
  000fe	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00103	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00106	83 f8 ff	 cmp	 eax, -1
  00109	73 04		 jae	 SHORT $LN24@use_facet@5
  0010b	40		 inc	 eax
  0010c	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN24@use_facet@5:
  0010f	8d 4c 24 3c	 lea	 ecx, DWORD PTR __Lock$79450[esp+52]
  00113	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit

; 514  : 			_Pfmod->_Register();

  00118	56		 push	 esi
  00119	e8 00 00 00 00	 call	 ?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
  0011e	83 c4 04	 add	 esp, 4
$LN28@use_facet@5:

; 515  : 			}
; 516  : 
; 517  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00121	8d 4c 24 1c	 lea	 ecx, DWORD PTR __Lock$38531[esp+56]
  00125	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+64], -1
  0012d	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00132	8b c6		 mov	 eax, esi

; 518  : 	_END_LOCK()
; 519  : 	}

  00134	8b 4c 24 2c	 mov	 ecx, DWORD PTR __$EHRec$[esp+56]
  00138	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013f	59		 pop	 ecx
  00140	5f		 pop	 edi
  00141	5e		 pop	 esi
  00142	5b		 pop	 ebx
  00143	83 c4 28	 add	 esp, 40			; 00000028H
  00146	c3		 ret	 0
$LN33@use_facet@5:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$38531[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 d8	 lea	 eax, DWORD PTR [edx-40]
  0000f	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0
__ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	ENDS
;	COMDAT ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
_TEXT	SEGMENT
$T79468 = -20						; size = 4
__Lock$79492 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Byte$ = 8						; size = 1
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z PROC ; std::basic_ios<char,std::char_traits<char> >::widen, COMDAT
; _this$ = ecx

; 123  : 		{	// convert _Byte to character using imbued locale

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 08	 sub	 esp, 8
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c4		 xor	 eax, esp
  0001b	50		 push	 eax
  0001c	8d 44 24 18	 lea	 eax, DWORD PTR __$EHRec$[esp+36]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 124  : 		const _Ctype& _Ctype_fac = _USE(getloc(), _Ctype);

  00026	8d 44 24 10	 lea	 eax, DWORD PTR $T79468[esp+36]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00030	50		 push	 eax
  00031	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 0
  00039	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  0003e	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+48], -1
  00046	8b 7c 24 14	 mov	 edi, DWORD PTR $T79468[esp+40]
  0004a	83 c4 04	 add	 esp, 4
  0004d	8b d8		 mov	 ebx, eax
  0004f	85 ff		 test	 edi, edi
  00051	74 3d		 je	 SHORT $LN7@widen
  00053	6a 00		 push	 0
  00055	8d 4c 24 18	 lea	 ecx, DWORD PTR __Lock$79492[esp+40]
  00059	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  0005e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00061	85 c0		 test	 eax, eax
  00063	76 09		 jbe	 SHORT $LN9@widen
  00065	83 f8 ff	 cmp	 eax, -1
  00068	73 04		 jae	 SHORT $LN9@widen
  0006a	48		 dec	 eax
  0006b	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN9@widen:
  0006e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00071	f7 de		 neg	 esi
  00073	1b f6		 sbb	 esi, esi
  00075	f7 d6		 not	 esi
  00077	8d 4c 24 14	 lea	 ecx, DWORD PTR __Lock$79492[esp+36]
  0007b	23 f7		 and	 esi, edi
  0007d	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00082	85 f6		 test	 esi, esi
  00084	74 0a		 je	 SHORT $LN7@widen
  00086	8b 16		 mov	 edx, DWORD PTR [esi]
  00088	8b 02		 mov	 eax, DWORD PTR [edx]
  0008a	6a 01		 push	 1
  0008c	8b ce		 mov	 ecx, esi
  0008e	ff d0		 call	 eax
$LN7@widen:

; 125  : 		return (_Ctype_fac.widen(_Byte));

  00090	8b 13		 mov	 edx, DWORD PTR [ebx]
  00092	8b 44 24 28	 mov	 eax, DWORD PTR __Byte$[esp+32]
  00096	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  00099	50		 push	 eax
  0009a	8b cb		 mov	 ecx, ebx
  0009c	ff d2		 call	 edx

; 126  : 		}

  0009e	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  000a2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a9	59		 pop	 ecx
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	83 c4 14	 add	 esp, 20			; 00000014H
  000b0	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T79468[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 ec	 lea	 eax, DWORD PTR [edx-20]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::widen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0
__ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T79508 = 8						; size = 4
__Mode$ = 8						; size = 4
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT
; _this$ = esi
; __Filename$ = ecx

; 151  : 		{	// open a C stream with specified mode

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	57		 push	 edi
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00014	33 c4		 xor	 eax, esp
  00016	50		 push	 eax
  00017	8d 44 24 08	 lea	 eax, DWORD PTR __$EHRec$[esp+20]
  0001b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 152  : 		_Filet *_File;
; 153  : 		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)

  00021	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00025	0f 85 9a 00 00
	00		 jne	 $LN1@open
  0002b	8b 44 24 18	 mov	 eax, DWORD PTR __Mode$[esp+16]
  0002f	6a 40		 push	 64			; 00000040H
  00031	50		 push	 eax
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z ; std::_Fiopen
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	85 c0		 test	 eax, eax
  0003d	0f 84 82 00 00
	00		 je	 $LN1@open

; 155  : 
; 156  : 		_Init(_File, _Openfl);

  00043	6a 01		 push	 1
  00045	50		 push	 eax
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 157  : 		_Initcvt((_Cvt *)&_USE(_Mysb::getloc(), _Cvt));

  0004d	8d 7c 24 18	 lea	 edi, DWORD PTR $T79508[esp+16]
  00051	8b c6		 mov	 eax, esi
  00053	e8 00 00 00 00	 call	 ?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ ; std::basic_streambuf<char,std::char_traits<char> >::getloc
  00058	50		 push	 eax
  00059	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  00061	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,int> >
  00066	8b f8		 mov	 edi, eax
  00068	8b 17		 mov	 edx, DWORD PTR [edi]
  0006a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006d	83 c4 04	 add	 esp, 4
  00070	8b cf		 mov	 ecx, edi
  00072	ff d0		 call	 eax
  00074	84 c0		 test	 al, al
  00076	74 25		 je	 SHORT $LN7@open
  00078	8d 4c 24 18	 lea	 ecx, DWORD PTR $T79508[esp+16]
  0007c	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
  00083	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale

; 158  : 		return (this);	// open succeeded

  00088	8b c6		 mov	 eax, esi

; 159  : 		}

  0008a	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  0008e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00095	59		 pop	 ecx
  00096	5f		 pop	 edi
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009a	c2 04 00	 ret	 4

; 157  : 		_Initcvt((_Cvt *)&_USE(_Mysb::getloc(), _Cvt));

$LN7@open:
  0009d	8b ce		 mov	 ecx, esi
  0009f	89 7e 3c	 mov	 DWORD PTR [esi+60], edi
  000a2	e8 00 00 00 00	 call	 ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
  000a7	8d 4c 24 18	 lea	 ecx, DWORD PTR $T79508[esp+16]
  000ab	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale

; 158  : 		return (this);	// open succeeded

  000b0	8b c6		 mov	 eax, esi

; 159  : 		}

  000b2	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  000b6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bd	59		 pop	 ecx
  000be	5f		 pop	 edi
  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c2	c2 04 00	 ret	 4
$LN1@open:

; 154  : 			return (0);	// open failed

  000c5	33 c0		 xor	 eax, eax

; 159  : 		}

  000c7	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  000cb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d2	59		 pop	 ecx
  000d3	5f		 pop	 edi
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0:
  00000	8d 4d 04	 lea	 ecx, DWORD PTR $T79508[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ$0
__ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 117  : 		{	// destroy the object

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 08	 sub	 esp, 8
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c4		 xor	 eax, esp
  00019	50		 push	 eax
  0001a	8d 44 24 10	 lea	 eax, DWORD PTR __$EHRec$[esp+28]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi
  0002a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00030	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+36], 0

; 118  : 		if (_Closef)

  00038	80 7e 48 00	 cmp	 BYTE PTR [esi+72], 0
  0003c	74 05		 je	 SHORT $LN1@basic_file

; 119  : 			close();

  0003e	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN1@basic_file:

; 120  : 		}

  00043	8b ce		 mov	 ecx, esi
  00045	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+36], -1
  0004d	e8 00 00 00 00	 call	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
  00052	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  00056	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005d	59		 pop	 ecx
  0005e	5e		 pop	 esi
  0005f	83 c4 14	 add	 esp, 20			; 00000014H
  00062	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 f4	 lea	 eax, DWORD PTR [edx-12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
__Loc$ = 8						; size = 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 455  : 		_Initcvt((_Cvt *)&_USE(_Loc, _Cvt));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Loc$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	50		 push	 eax
  00007	8b f9		 mov	 edi, ecx
  00009	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,int> >
  0000e	8b f0		 mov	 esi, eax
  00010	8b 16		 mov	 edx, DWORD PTR [esi]
  00012	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00015	83 c4 04	 add	 esp, 4
  00018	8b ce		 mov	 ecx, esi
  0001a	ff d0		 call	 eax
  0001c	84 c0		 test	 al, al
  0001e	74 0c		 je	 SHORT $LN4@imbue
  00020	c7 47 3c 00 00
	00 00		 mov	 DWORD PTR [edi+60], 0
  00027	5f		 pop	 edi
  00028	5e		 pop	 esi

; 456  : 		}

  00029	c2 04 00	 ret	 4

; 455  : 		_Initcvt((_Cvt *)&_USE(_Loc, _Cvt));

$LN4@imbue:
  0002c	8b cf		 mov	 ecx, edi
  0002e	89 77 3c	 mov	 DWORD PTR [edi+60], esi
  00031	e8 00 00 00 00	 call	 ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi

; 456  : 		}

  00038	c2 04 00	 ret	 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $LN4@scalar@22
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$LN4@scalar@22:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ?clear@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
?clear@ios_base@std@@QAEXH@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 301  : 		clear(_State, false);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __State$[esp-4]
  00004	6a 00		 push	 0
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 302  : 		}

  0000c	c2 04 00	 ret	 4
?clear@ios_base@std@@QAEXH@Z ENDP			; std::ios_base::clear
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\istream
xdata$x	SEGMENT
__unwindtable$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ$0
__ehfuncinfo$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 642  : 		{	// destroy the object

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 08	 sub	 esp, 8
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c4		 xor	 eax, esp
  00019	50		 push	 eax
  0001a	8d 44 24 10	 lea	 eax, DWORD PTR __$EHRec$[esp+28]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4c 24 0c	 mov	 DWORD PTR _this$[esp+28], ecx
  00028	8b 41 a8	 mov	 eax, DWORD PTR [ecx-88]
  0002b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002e	c7 44 0a a8 00
	00 00 00	 mov	 DWORD PTR [edx+ecx-88], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@

; 643  : 		}

  00036	8d 71 b0	 lea	 esi, DWORD PTR [ecx-80]
  00039	8b ce		 mov	 ecx, esi
  0003b	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+36], 0
  00043	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00048	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  0004b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004e	c7 44 31 f8 00
	00 00 00	 mov	 DWORD PTR [ecx+esi-8], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00056	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  0005a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00061	59		 pop	 ecx
  00062	5e		 pop	 esi
  00063	83 c4 14	 add	 esp, 20			; 00000014H
  00066	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 e9 50	 sub	 ecx, 80			; 00000050H
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
__ehhandler$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 f4	 lea	 eax, DWORD PTR [edx-12]
  00012	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = eax
  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax
  00003	83 c6 58	 add	 esi, 88			; 00000058H
  00006	8b ce		 mov	 ecx, esi
  00008	e8 00 00 00 00	 call	 ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
  0000d	56		 push	 esi
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  00014	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00019	83 c4 04	 add	 esp, 4
  0001c	5e		 pop	 esi
  0001d	c3		 ret	 0
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8d 79 a8	 lea	 edi, DWORD PTR [ecx-88]
  00005	8d 77 58	 lea	 esi, DWORD PTR [edi+88]
  00008	8b ce		 mov	 ecx, esi
  0000a	e8 00 00 00 00	 call	 ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
  0000f	56		 push	 esi
  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  00016	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0001b	83 c4 04	 add	 esp, 4
  0001e	f6 44 24 0c 01	 test	 BYTE PTR ___flags$[esp+4], 1
  00023	74 09		 je	 SHORT $LN11@scalar@24
  00025	57		 push	 edi
  00026	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002b	83 c4 04	 add	 esp, 4
$LN11@scalar@24:
  0002e	8b c7		 mov	 eax, edi
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	c2 04 00	 ret	 4
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ?_Init@ios_base@std@@IAEXXZ
_TEXT	SEGMENT
__Lock$93469 = -4					; size = 4
?_Init@ios_base@std@@IAEXXZ PROC			; std::ios_base::_Init, COMDAT
; _this$ = ecx

; 515  :         {	// initialize a new ios_base

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp

; 516  :         _Ploc = 0;

  00003	33 ed		 xor	 ebp, ebp
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi

; 517  :         _Stdstr = 0;
; 518  :         _Except = goodbit;
; 519  :         _Fmtfl = skipws | dec;
; 520  :         _Prec = 6;
; 521  :         _Wide = 0;
; 522  :         _Arr = 0;
; 523  :         _Calls = 0;
; 524  :         clear(goodbit);

  00009	55		 push	 ebp
  0000a	55		 push	 ebp
  0000b	89 6e 24	 mov	 DWORD PTR [esi+36], ebp
  0000e	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  00011	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  00014	c7 46 10 01 02
	00 00		 mov	 DWORD PTR [esi+16], 513	; 00000201H
  0001b	c7 46 14 06 00
	00 00		 mov	 DWORD PTR [esi+20], 6
  00022	89 6e 18	 mov	 DWORD PTR [esi+24], ebp
  00025	89 6e 1c	 mov	 DWORD PTR [esi+28], ebp
  00028	89 6e 20	 mov	 DWORD PTR [esi+32], ebp
  0002b	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 525  :         _Ploc = _NEW_CRT locale;

  00030	6a 04		 push	 4
  00032	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00037	8b f8		 mov	 edi, eax
  00039	83 c4 04	 add	 esp, 4
  0003c	3b fd		 cmp	 edi, ebp
  0003e	74 36		 je	 SHORT $LN3@Init@3
  00040	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Init
  00045	89 07		 mov	 DWORD PTR [edi], eax
  00047	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0004c	55		 push	 ebp
  0004d	8d 4c 24 14	 lea	 ecx, DWORD PTR __Lock$93469[esp+24]
  00051	8b d8		 mov	 ebx, eax
  00053	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00058	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0005b	83 f8 ff	 cmp	 eax, -1
  0005e	73 04		 jae	 SHORT $LN9@Init@3
  00060	40		 inc	 eax
  00061	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN9@Init@3:
  00064	8d 4c 24 10	 lea	 ecx, DWORD PTR __Lock$93469[esp+20]
  00068	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0006d	89 7e 24	 mov	 DWORD PTR [esi+36], edi

; 526  :         }

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5d		 pop	 ebp
  00073	5b		 pop	 ebx
  00074	59		 pop	 ecx
  00075	c3		 ret	 0
$LN3@Init@3:
  00076	5f		 pop	 edi
  00077	89 6e 24	 mov	 DWORD PTR [esi+36], ebp
  0007a	5e		 pop	 esi
  0007b	5d		 pop	 ebp
  0007c	5b		 pop	 ebx
  0007d	59		 pop	 ecx
  0007e	c3		 ret	 0
?_Init@ios_base@std@@IAEXXZ ENDP			; std::ios_base::_Init
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
;	COMDAT ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
_TEXT	SEGMENT
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::init, COMDAT
; _this$ = ecx

; 131  : 		{	// initialize with stream buffer pointer

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 132  : 		_Init();	// initialize ios_base

  00003	e8 00 00 00 00	 call	 ?_Init@ios_base@std@@IAEXXZ ; std::ios_base::_Init

; 133  : 		_Mystrbuf = _Strbuf;

  00008	8b 44 24 08	 mov	 eax, DWORD PTR __Strbuf$[esp]

; 134  : 		_Tiestr = 0;
; 135  : 		_Fillch = widen(' ');

  0000c	6a 20		 push	 32			; 00000020H
  0000e	8b ce		 mov	 ecx, esi
  00010	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00013	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
  0001a	e8 00 00 00 00	 call	 ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen

; 136  : 
; 137  : 		if (_Mystrbuf == 0)

  0001f	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00023	88 46 30	 mov	 BYTE PTR [esi+48], al
  00026	75 10		 jne	 SHORT $LN11@init@4

; 138  : 			setstate(badbit);

  00028	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002b	83 c8 04	 or	 eax, 4
  0002e	6a 00		 push	 0
  00030	50		 push	 eax
  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN11@init@4:

; 139  : 
; 140  : 		if (_Isstd)

  00038	80 7c 24 0c 00	 cmp	 BYTE PTR __Isstd$[esp], 0
  0003d	74 0d		 je	 SHORT $LN2@init@4

; 141  : 			_Addstd(this);	// special handling for standard streams

  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  00045	83 c4 04	 add	 esp, 4

; 144  : 		}

  00048	5e		 pop	 esi
  00049	c2 08 00	 ret	 8
$LN2@init@4:

; 142  : 		else
; 143  : 		_Stdstr = 0;

  0004c	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 144  : 		}

  00053	5e		 pop	 esi
  00054	c2 08 00	 ret	 8
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::init
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 0ffffffffH
	DD	00H
__ehfuncinfo$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
_TEXT	SEGMENT
$T94565 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Strbuf$ = 12						; size = 4
??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >, COMDAT

; 32   : 		{	// construct from stream buffer pointer

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 08	 sub	 esp, 8
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c4		 xor	 eax, esp
  0001b	50		 push	 eax
  0001c	8d 44 24 18	 lea	 eax, DWORD PTR __$EHRec$[esp+36]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b 7c 24 28	 mov	 edi, DWORD PTR _this$[esp+32]
  0002a	33 db		 xor	 ebx, ebx
  0002c	89 5c 24 14	 mov	 DWORD PTR $T94565[esp+36], ebx
  00030	8b 07		 mov	 eax, DWORD PTR [edi]
  00032	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00035	c7 04 0f 00 00
	00 00		 mov	 DWORD PTR [edi+ecx], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@

; 33   : 		_Myios::init(_Strbuf, _Isstd);

  0003c	8b 17		 mov	 edx, DWORD PTR [edi]
  0003e	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00041	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00044	03 f7		 add	 esi, edi
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?_Init@ios_base@std@@IAEXXZ ; std::ios_base::_Init
  0004d	8b 44 24 2c	 mov	 eax, DWORD PTR __Strbuf$[esp+32]
  00051	6a 20		 push	 32			; 00000020H
  00053	8b ce		 mov	 ecx, esi
  00055	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00058	89 5e 2c	 mov	 DWORD PTR [esi+44], ebx
  0005b	e8 00 00 00 00	 call	 ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
  00060	88 46 30	 mov	 BYTE PTR [esi+48], al
  00063	39 5e 28	 cmp	 DWORD PTR [esi+40], ebx
  00066	75 0f		 jne	 SHORT $LN24@basic_istr
  00068	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006b	83 c8 04	 or	 eax, 4
  0006e	53		 push	 ebx
  0006f	50		 push	 eax
  00070	8b ce		 mov	 ecx, esi
  00072	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN24@basic_istr:

; 34   : 		}

  00077	8b c7		 mov	 eax, edi

; 33   : 		_Myios::init(_Strbuf, _Isstd);

  00079	89 5e 04	 mov	 DWORD PTR [esi+4], ebx

; 34   : 		}

  0007c	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	83 c4 14	 add	 esp, 20			; 00000014H
  0008e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 ec	 lea	 eax, DWORD PTR [edx-20]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\fstream
;	COMDAT ?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::close, COMDAT
; _this$ = esi

; 669  : 		{	// close the C stream

  00000	51		 push	 ecx

; 670  : 		if (_Filebuffer.close() == 0)

  00001	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00004	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  00009	85 c0		 test	 eax, eax
  0000b	75 1f		 jne	 SHORT $LN9@close@3

; 671  : 			_Myios::setstate(ios_base::failbit);

  0000d	8b 06		 mov	 eax, DWORD PTR [esi]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	8b 44 31 08	 mov	 eax, DWORD PTR [ecx+esi+8]
  00016	03 ce		 add	 ecx, esi
  00018	83 c8 02	 or	 eax, 2
  0001b	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  0001f	75 03		 jne	 SHORT $LN11@close@3
  00021	83 c8 04	 or	 eax, 4
$LN11@close@3:
  00024	6a 00		 push	 0
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN9@close@3:
  0002c	59		 pop	 ecx

; 672  : 		}

  0002d	c3		 ret	 0
?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::close
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z
_TEXT	SEGMENT
?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::open, COMDAT
; _this$ = edi
; __Filename$ = ecx

; 658  : 		{	// open a C stream with specified mode

  00000	56		 push	 esi

; 659  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)

  00001	6a 21		 push	 33			; 00000021H
  00003	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  00006	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  0000b	85 c0		 test	 eax, eax
  0000d	75 1f		 jne	 SHORT $LN9@open@3

; 660  : 			_Myios::setstate(ios_base::failbit);

  0000f	8b 07		 mov	 eax, DWORD PTR [edi]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	8b 44 39 08	 mov	 eax, DWORD PTR [ecx+edi+8]
  00018	03 cf		 add	 ecx, edi
  0001a	83 c8 02	 or	 eax, 2
  0001d	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  00021	75 03		 jne	 SHORT $LN11@open@3
  00023	83 c8 04	 or	 eax, 4
$LN11@open@3:
  00026	6a 00		 push	 0
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN9@open@3:

; 661  : 		}

  0002e	5e		 pop	 esi
  0002f	c3		 ret	 0
?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::open
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
xdata$x	SEGMENT
__unwindtable$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1
__ehfuncinfo$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\fstream
xdata$x	ENDS
;	COMDAT ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T94677 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >, COMDAT

; 575  : 		{	// construct unopened

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	53		 push	 ebx
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c4		 xor	 eax, esp
  00019	50		 push	 eax
  0001a	8d 44 24 14	 lea	 eax, DWORD PTR __$EHRec$[esp+32]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b 7c 24 24	 mov	 edi, DWORD PTR _this$[esp+28]
  00028	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  0002b	56		 push	 esi
  0002c	33 db		 xor	 ebx, ebx
  0002e	57		 push	 edi
  0002f	89 5c 24 18	 mov	 DWORD PTR $T94677[esp+40], ebx
  00033	e8 00 00 00 00	 call	 ??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >
  00038	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+40], 1
  00040	8b 07		 mov	 eax, DWORD PTR [edi]
  00042	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00045	c7 04 0f 00 00
	00 00		 mov	 DWORD PTR [edi+ecx], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
  00053	8d 56 08	 lea	 edx, DWORD PTR [esi+8]
  00056	89 56 10	 mov	 DWORD PTR [esi+16], edx
  00059	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  0005f	88 5e 48	 mov	 BYTE PTR [esi+72], bl
  00062	88 5e 41	 mov	 BYTE PTR [esi+65], bl
  00065	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00068	89 4e 20	 mov	 DWORD PTR [esi+32], ecx
  0006b	8d 56 1c	 lea	 edx, DWORD PTR [esi+28]
  0006e	89 56 24	 mov	 DWORD PTR [esi+36], edx
  00071	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00074	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00077	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  0007a	89 4e 30	 mov	 DWORD PTR [esi+48], ecx
  0007d	8d 56 2c	 lea	 edx, DWORD PTR [esi+44]
  00080	89 56 34	 mov	 DWORD PTR [esi+52], edx
  00083	89 18		 mov	 DWORD PTR [eax], ebx
  00085	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00088	89 18		 mov	 DWORD PTR [eax], ebx
  0008a	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  0008d	89 19		 mov	 DWORD PTR [ecx], ebx
  0008f	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00092	89 1a		 mov	 DWORD PTR [edx], ebx
  00094	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00097	89 18		 mov	 DWORD PTR [eax], ebx
  00099	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  0009c	89 19		 mov	 DWORD PTR [ecx], ebx
  0009e	89 5e 4c	 mov	 DWORD PTR [esi+76], ebx
  000a1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA
  000a7	89 56 44	 mov	 DWORD PTR [esi+68], edx
  000aa	89 5e 3c	 mov	 DWORD PTR [esi+60], ebx

; 576  : 		}

  000ad	8b c7		 mov	 eax, edi
  000af	8b 4c 24 14	 mov	 ecx, DWORD PTR __$EHRec$[esp+32]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ba	59		 pop	 ecx
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	83 c4 10	 add	 esp, 16			; 00000010H
  000c1	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1:
  00000	8b 4d 04	 mov	 ecx, DWORD PTR _this$[ebp-4]
  00003	83 c1 08	 add	 ecx, 8
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
__ehhandler$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 f0	 lea	 eax, DWORD PTR [edx-16]
  00012	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\istream
;	COMDAT ?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@JH@Z
_TEXT	SEGMENT
$T94754 = -28						; size = 24
__Off$ = 8						; size = 4
__Way$ = 12						; size = 4
?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@JH@Z PROC ; std::basic_istream<char,std::char_traits<char> >::seekg, COMDAT
; _this$ = esi

; 826  : 		if (!ios_base::fail()
; 827  : 			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
; 828  : 				ios_base::in) == _BADOFF)

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00005	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00008	f6 44 31 08 06	 test	 BYTE PTR [ecx+esi+8], 6
  0000d	75 56		 jne	 SHORT $LN2@seekg
  0000f	8b d1		 mov	 edx, ecx
  00011	8b 4c 32 28	 mov	 ecx, DWORD PTR [edx+esi+40]
  00015	8b 54 24 24	 mov	 edx, DWORD PTR __Way$[esp+24]
  00019	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001b	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0001e	6a 01		 push	 1
  00020	52		 push	 edx
  00021	8b 54 24 28	 mov	 edx, DWORD PTR __Off$[esp+32]
  00025	52		 push	 edx
  00026	8d 54 24 0c	 lea	 edx, DWORD PTR $T94754[esp+40]
  0002a	52		 push	 edx
  0002b	ff d0		 call	 eax
  0002d	8b 0c 24	 mov	 ecx, DWORD PTR $T94754[esp+28]
  00030	8b 54 24 08	 mov	 edx, DWORD PTR $T94754[esp+36]
  00034	03 d1		 add	 edx, ecx
  00036	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?_BADOFF@std@@3JB ; std::_BADOFF
  0003c	75 27		 jne	 SHORT $LN2@seekg

; 829  : 			_Myios::setstate(ios_base::failbit);

  0003e	8b 06		 mov	 eax, DWORD PTR [esi]
  00040	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00043	8b 44 31 08	 mov	 eax, DWORD PTR [ecx+esi+8]
  00047	03 ce		 add	 ecx, esi
  00049	83 c8 02	 or	 eax, 2
  0004c	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  00050	75 28		 jne	 SHORT $LN22@seekg
  00052	83 c8 04	 or	 eax, 4

; 830  : 		else
; 831  : 			_Myios::clear();	// clear eofbit if set

  00055	6a 00		 push	 0
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 832  : 		return (*this);

  0005d	8b c6		 mov	 eax, esi

; 833  : 		}

  0005f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00062	c2 08 00	 ret	 8
$LN2@seekg:

; 830  : 		else
; 831  : 			_Myios::clear();	// clear eofbit if set

  00065	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00067	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0006a	8b 44 31 28	 mov	 eax, DWORD PTR [ecx+esi+40]
  0006e	03 ce		 add	 ecx, esi
  00070	f7 d8		 neg	 eax
  00072	1b c0		 sbb	 eax, eax
  00074	83 e0 fc	 and	 eax, -4			; fffffffcH
  00077	83 c0 04	 add	 eax, 4
$LN22@seekg:
  0007a	6a 00		 push	 0
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 832  : 		return (*this);

  00082	8b c6		 mov	 eax, esi

; 833  : 		}

  00084	83 c4 1c	 add	 esp, 28			; 0000001cH
  00087	c2 08 00	 ret	 8
?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@JH@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::seekg
_TEXT	ENDS
PUBLIC	?GetSize@FileInput@@QAEIXZ			; FileInput::GetSize
; Function compile flags: /Ogtpy
; File i:\nj\my project\cms\cms\fileinput.cpp
;	COMDAT ?GetSize@FileInput@@QAEIXZ
_TEXT	SEGMENT
$T94809 = -28						; size = 24
$T94808 = -28						; size = 24
?GetSize@FileInput@@QAEIXZ PROC				; FileInput::GetSize, COMDAT
; _this$ = eax

; 80   : unsigned	int	FileInput::GetSize(){

  00000	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f0		 mov	 esi, eax

; 81   : 
; 82   : 	unsigned	int	iData;
; 83   : 	unsigned	int	iDataT = tellg();

  00008	8b 06		 mov	 eax, DWORD PTR [esi]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  00010	b3 06		 mov	 bl, 6
  00012	57		 push	 edi
  00013	84 58 08	 test	 BYTE PTR [eax+8], bl
  00016	75 1f		 jne	 SHORT $LN4@GetSize
  00018	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0001b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001d	8b 52 24	 mov	 edx, DWORD PTR [edx+36]
  00020	6a 01		 push	 1
  00022	6a 01		 push	 1
  00024	6a 00		 push	 0
  00026	8d 44 24 1c	 lea	 eax, DWORD PTR $T94808[esp+56]
  0002a	50		 push	 eax
  0002b	ff d2		 call	 edx
  0002d	8b 4c 24 18	 mov	 ecx, DWORD PTR $T94808[esp+52]
  00031	8b 44 24 10	 mov	 eax, DWORD PTR $T94808[esp+44]
  00035	eb 0b		 jmp	 SHORT $LN3@GetSize
$LN4@GetSize:
  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3JB ; std::_BADOFF
  0003c	33 c9		 xor	 ecx, ecx
  0003e	89 4c 24 1c	 mov	 DWORD PTR $T94808[esp+56], ecx
$LN3@GetSize:

; 84   : 
; 85   : 	seekg(0		,ios::end);

  00042	6a 02		 push	 2
  00044	6a 00		 push	 0
  00046	8d 2c 01	 lea	 ebp, DWORD PTR [ecx+eax]
  00049	e8 00 00 00 00	 call	 ?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@JH@Z ; std::basic_istream<char,std::char_traits<char> >::seekg

; 86   : 	iData = tellg();

  0004e	8b 06		 mov	 eax, DWORD PTR [esi]
  00050	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00053	84 5c 31 08	 test	 BYTE PTR [ecx+esi+8], bl
  00057	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  0005a	75 32		 jne	 SHORT $LN20@GetSize
  0005c	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0005f	8b 10		 mov	 edx, DWORD PTR [eax]
  00061	8b 52 24	 mov	 edx, DWORD PTR [edx+36]
  00064	6a 01		 push	 1
  00066	6a 01		 push	 1
  00068	6a 00		 push	 0
  0006a	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T94809[esp+56]
  0006e	51		 push	 ecx
  0006f	8b c8		 mov	 ecx, eax
  00071	ff d2		 call	 edx
  00073	8b 5c 24 18	 mov	 ebx, DWORD PTR $T94809[esp+52]
  00077	8b 7c 24 10	 mov	 edi, DWORD PTR $T94809[esp+44]

; 87   : 	seekg(iDataT,ios::beg);

  0007b	6a 00		 push	 0
  0007d	55		 push	 ebp
  0007e	e8 00 00 00 00	 call	 ?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@JH@Z ; std::basic_istream<char,std::char_traits<char> >::seekg
  00083	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]

; 88   : 
; 89   : 	return(iData);
; 90   : };

  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5d		 pop	 ebp
  00089	5b		 pop	 ebx
  0008a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0008d	c3		 ret	 0

; 86   : 	iData = tellg();

$LN20@GetSize:
  0008e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?_BADOFF@std@@3JB ; std::_BADOFF
  00094	33 db		 xor	 ebx, ebx

; 87   : 	seekg(iDataT,ios::beg);

  00096	53		 push	 ebx
  00097	55		 push	 ebp
  00098	89 5c 24 24	 mov	 DWORD PTR $T94809[esp+64], ebx
  0009c	e8 00 00 00 00	 call	 ?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@JH@Z ; std::basic_istream<char,std::char_traits<char> >::seekg
  000a1	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]

; 88   : 
; 89   : 	return(iData);
; 90   : };

  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5d		 pop	 ebp
  000a7	5b		 pop	 ebx
  000a8	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ab	c3		 ret	 0
?GetSize@FileInput@@QAEIXZ ENDP				; FileInput::GetSize
_TEXT	ENDS
PUBLIC	?StreamPointerMove@FileInput@@QAEXH@Z		; FileInput::StreamPointerMove
; Function compile flags: /Ogtpy
;	COMDAT ?StreamPointerMove@FileInput@@QAEXH@Z
_TEXT	SEGMENT
?StreamPointerMove@FileInput@@QAEXH@Z PROC		; FileInput::StreamPointerMove, COMDAT
; _this$ = esi
; _iSize$ = eax

; 52   : void	FileInput::StreamPointerMove(__int32 iSize){

  00000	51		 push	 ecx

; 53   : 	seekg((long)iSize,ios::beg);

  00001	6a 00		 push	 0
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@JH@Z ; std::basic_istream<char,std::char_traits<char> >::seekg
  00009	59		 pop	 ecx

; 54   : };

  0000a	c3		 ret	 0
?StreamPointerMove@FileInput@@QAEXH@Z ENDP		; FileInput::StreamPointerMove
_TEXT	ENDS
PUBLIC	?StreamPointerAdd@FileInput@@QAEXH@Z		; FileInput::StreamPointerAdd
; Function compile flags: /Ogtpy
;	COMDAT ?StreamPointerAdd@FileInput@@QAEXH@Z
_TEXT	SEGMENT
?StreamPointerAdd@FileInput@@QAEXH@Z PROC		; FileInput::StreamPointerAdd, COMDAT
; _this$ = esi
; _iSize$ = eax

; 45   : void	FileInput::StreamPointerAdd(__int32 iSize){

  00000	51		 push	 ecx

; 46   : 	seekg((long)iSize,ios::cur);

  00001	6a 01		 push	 1
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@JH@Z ; std::basic_istream<char,std::char_traits<char> >::seekg
  00009	59		 pop	 ecx

; 47   : };

  0000a	c3		 ret	 0
?StreamPointerAdd@FileInput@@QAEXH@Z ENDP		; FileInput::StreamPointerAdd
_TEXT	ENDS
PUBLIC	?fileopen@FileInput@@QAEXPBD@Z			; FileInput::fileopen
; Function compile flags: /Ogtpy
;	COMDAT ?fileopen@FileInput@@QAEXPBD@Z
_TEXT	SEGMENT
_strFileName$ = 8					; size = 4
?fileopen@FileInput@@QAEXPBD@Z PROC			; FileInput::fileopen, COMDAT
; _this$ = edi

; 33   : void	FileInput::fileopen(const char*	strFileName){

  00000	53		 push	 ebx
  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _strFileName$[esp]
  00005	56		 push	 esi

; 34   : 
; 35   : 	open(strFileName,ios_base::in | ios_base::binary);

  00006	6a 21		 push	 33			; 00000021H
  00008	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  0000b	8b cb		 mov	 ecx, ebx
  0000d	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00012	85 c0		 test	 eax, eax
  00014	75 1f		 jne	 SHORT $LN12@fileopen@2
  00016	8b 07		 mov	 eax, DWORD PTR [edi]
  00018	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001b	8b 44 39 08	 mov	 eax, DWORD PTR [ecx+edi+8]
  0001f	03 cf		 add	 ecx, edi
  00021	83 c8 02	 or	 eax, 2
  00024	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  00028	75 03		 jne	 SHORT $LN14@fileopen@2
  0002a	83 c8 04	 or	 eax, 4
$LN14@fileopen@2:
  0002d	6a 00		 push	 0
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN12@fileopen@2:

; 36   : 	if(good()==false){

  00035	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00037	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003a	83 7c 3a 08 00	 cmp	 DWORD PTR [edx+edi+8], 0
  0003f	74 10		 je	 SHORT $LN1@fileopen@2

; 37   : 		perror(strFileName);

  00041	53		 push	 ebx
  00042	e8 00 00 00 00	 call	 _perror
  00047	83 c4 04	 add	 esp, 4

; 38   : 		exit(EXIT_FAILURE);

  0004a	6a 01		 push	 1
  0004c	e8 00 00 00 00	 call	 _exit
$LN21@fileopen@2:
$LN1@fileopen@2:

; 39   : 	};
; 40   : };

  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	c2 04 00	 ret	 4
$LN20@fileopen@2:
?fileopen@FileInput@@QAEXPBD@Z ENDP			; FileInput::fileopen
_TEXT	ENDS
PUBLIC	??1FileInput@@UAE@XZ				; FileInput::~FileInput
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??1FileInput@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1FileInput@@UAE@XZ$0
__ehfuncinfo$??1FileInput@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1FileInput@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File i:\nj\my project\cms\cms\fileinput.cpp
xdata$x	ENDS
;	COMDAT ??1FileInput@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1FileInput@@UAE@XZ PROC				; FileInput::~FileInput, COMDAT

; 26   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1FileInput@@UAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 7c 24 1c	 mov	 edi, DWORD PTR _this$[esp+20]
  00026	8b 47 a8	 mov	 eax, DWORD PTR [edi-88]
  00029	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002c	8d 77 a8	 lea	 esi, DWORD PTR [edi-88]
  0002f	c7 44 39 a8 00
	00 00 00	 mov	 DWORD PTR [ecx+edi-88], OFFSET ??_7FileInput@@6B@

; 27   : 	close();

  00037	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0003a	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  00042	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  00047	85 c0		 test	 eax, eax
  00049	75 1f		 jne	 SHORT $LN12@FileInput
  0004b	8b 16		 mov	 edx, DWORD PTR [esi]
  0004d	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00050	8b 44 31 08	 mov	 eax, DWORD PTR [ecx+esi+8]
  00054	03 ce		 add	 ecx, esi
  00056	83 c8 02	 or	 eax, 2
  00059	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  0005d	75 03		 jne	 SHORT $LN14@FileInput
  0005f	83 c8 04	 or	 eax, 4
$LN14@FileInput:
  00062	6a 00		 push	 0
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN12@FileInput:

; 28   : }

  0006a	8b cf		 mov	 ecx, edi
  0006c	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  00074	e8 00 00 00 00	 call	 ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
  00079	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  0007d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00084	59		 pop	 ecx
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1FileInput@@UAE@XZ$0:
  00000	8b 4d 04	 mov	 ecx, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
__ehhandler$??1FileInput@@UAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1FileInput@@UAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1FileInput@@UAE@XZ ENDP				; FileInput::~FileInput
PUBLIC	??0FileInput@@QAE@PBD@Z				; FileInput::FileInput
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xiosbase
xdata$x	SEGMENT
__unwindtable$??0FileInput@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FileInput@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0FileInput@@QAE@PBD@Z$1
__ehfuncinfo$??0FileInput@@QAE@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0FileInput@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File i:\nj\my project\cms\cms\fileinput.cpp
xdata$x	ENDS
;	COMDAT ??0FileInput@@QAE@PBD@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
$T94994 = 12						; size = 4
_strFileName$ = 12					; size = 4
_$initVBases$ = 16					; size = 4
??0FileInput@@QAE@PBD@Z PROC				; FileInput::FileInput, COMDAT

; 13   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0FileInput@@QAE@PBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	55		 push	 ebp
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c4		 xor	 eax, esp
  00019	50		 push	 eax
  0001a	8d 44 24 14	 lea	 eax, DWORD PTR __$EHRec$[esp+32]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b 6c 24 28	 mov	 ebp, DWORD PTR _strFileName$[esp+28]
  00028	8b 7c 24 24	 mov	 edi, DWORD PTR _this$[esp+28]
  0002c	83 7c 24 2c 00	 cmp	 DWORD PTR _$initVBases$[esp+28], 0
  00031	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR $T94994[esp+28], 0
  00039	74 1d		 je	 SHORT $LN1@FileInput@2
  0003b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8FileInput@@7B@
  00041	c7 47 58 00 00
	00 00		 mov	 DWORD PTR [edi+88], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  00048	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+40], 0
  00050	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR $T94994[esp+28], 1
$LN1@FileInput@2:
  00058	57		 push	 edi
  00059	e8 00 00 00 00	 call	 ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
  0005e	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+40], 1
  00066	8b 07		 mov	 eax, DWORD PTR [edi]
  00068	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006b	c7 04 0f 00 00
	00 00		 mov	 DWORD PTR [edi+ecx], OFFSET ??_7FileInput@@6B@

; 14   : 	fileopen(strFileName);

  00072	6a 21		 push	 33			; 00000021H
  00074	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  00077	8b cd		 mov	 ecx, ebp
  00079	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  0007e	85 c0		 test	 eax, eax
  00080	75 1f		 jne	 SHORT $LN22@FileInput@2
  00082	8b 17		 mov	 edx, DWORD PTR [edi]
  00084	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00087	8b 44 39 08	 mov	 eax, DWORD PTR [ecx+edi+8]
  0008b	03 cf		 add	 ecx, edi
  0008d	83 c8 02	 or	 eax, 2
  00090	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  00094	75 03		 jne	 SHORT $LN24@FileInput@2
  00096	83 c8 04	 or	 eax, 4
$LN24@FileInput@2:
  00099	6a 00		 push	 0
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN22@FileInput@2:
  000a1	8b 07		 mov	 eax, DWORD PTR [edi]
  000a3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a6	83 7c 39 08 00	 cmp	 DWORD PTR [ecx+edi+8], 0
  000ab	74 10		 je	 SHORT $LN11@FileInput@2
  000ad	55		 push	 ebp
  000ae	e8 00 00 00 00	 call	 _perror
  000b3	83 c4 04	 add	 esp, 4
  000b6	6a 01		 push	 1
  000b8	e8 00 00 00 00	 call	 _exit
$LN34@FileInput@2:
$LN11@FileInput@2:

; 15   : }

  000bd	8b c7		 mov	 eax, edi
  000bf	8b 4c 24 14	 mov	 ecx, DWORD PTR __$EHRec$[esp+32]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5d		 pop	 ebp
  000ce	83 c4 10	 add	 esp, 16			; 00000010H
  000d1	c2 0c 00	 ret	 12			; 0000000cH
$LN33@FileInput@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FileInput@@QAE@PBD@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR $T94994[ebp-4]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@FileInput@2
  0000c	83 65 08 fe	 and	 DWORD PTR $T94994[ebp-4], -2 ; fffffffeH
  00010	8b 4d 04	 mov	 ecx, DWORD PTR _this$[ebp-4]
  00013	83 c1 58	 add	 ecx, 88			; 00000058H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN5@FileInput@2:
  0001b	c3		 ret	 0
__unwindfunclet$??0FileInput@@QAE@PBD@Z$1:
  0001c	8b 4d 04	 mov	 ecx, DWORD PTR _this$[ebp-4]
  0001f	83 c1 58	 add	 ecx, 88			; 00000058H
  00022	e9 00 00 00 00	 jmp	 ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
__ehhandler$??0FileInput@@QAE@PBD@Z:
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 f0	 lea	 eax, DWORD PTR [edx-16]
  0002e	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0FileInput@@QAE@PBD@Z
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0FileInput@@QAE@PBD@Z ENDP				; FileInput::FileInput
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Ipfx, COMDAT
; _this$ = esi

; 92   : 		{	// test stream state and skip whitespace as needed

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	51		 push	 ecx
  00014	33 c4		 xor	 eax, esp
  00016	50		 push	 eax
  00017	8d 44 24 08	 lea	 eax, DWORD PTR __$EHRec$[esp+20]
  0001b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 93   : 		if (ios_base::good())

  00021	8b 06		 mov	 eax, DWORD PTR [esi]
  00023	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00026	8b 44 31 08	 mov	 eax, DWORD PTR [ecx+esi+8]
  0002a	03 ce		 add	 ecx, esi
  0002c	85 c0		 test	 eax, eax
  0002e	75 31		 jne	 SHORT $LN1@Ipfx

; 94   : 			{	// state okay, flush tied stream and skip whitespace
; 95   : 			if (_Myios::tie() != 0)

  00030	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  00033	85 c9		 test	 ecx, ecx
  00035	74 09		 je	 SHORT $LL7@Ipfx

; 96   : 				_Myios::tie()->flush();

  00037	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
  0003c	8d 64 24 00	 npad	 4
$LL7@Ipfx:

; 97   : 
; 98   : 			if (!_Noskip && ios_base::flags() & ios_base::skipws)
; 99   : 				{	// skip whitespace
; 100  : 				const _Ctype& _Ctype_fac = _USE(ios_base::getloc(), _Ctype);
; 101  : 
; 102  : 				_TRY_IO_BEGIN
; 103  : 				int_type _Meta = _Myios::rdbuf()->sgetc();
; 104  : 
; 105  : 				for (; ; _Meta = _Myios::rdbuf()->snextc())
; 106  : 					if (_Traits::eq_int_type(_Traits::eof(), _Meta))
; 107  : 						{	// end of file, quit
; 108  : 						_Myios::setstate(ios_base::eofbit);
; 109  : 						break;
; 110  : 						}
; 111  : 					else if (!_Ctype_fac.is(_Ctype::space,
; 112  : 						_Traits::to_char_type(_Meta)))
; 113  : 						break;	// not whitespace, quit
; 114  : 				_CATCH_IO_END
; 115  : 				}
; 116  : 
; 117  : 			if (ios_base::good())

  00040	8b 16		 mov	 edx, DWORD PTR [esi]
  00042	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00045	83 7c 30 08 00	 cmp	 DWORD PTR [eax+esi+8], 0
  0004a	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  0004d	75 12		 jne	 SHORT $LN1@Ipfx

; 118  : 				return (true);

  0004f	b0 01		 mov	 al, 1

; 122  : 		}

  00051	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	83 c4 10	 add	 esp, 16			; 00000010H
  00060	c3		 ret	 0
$LN1@Ipfx:

; 119  : 			}
; 120  : 		_Myios::setstate(ios_base::failbit);

  00061	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00064	83 c8 02	 or	 eax, 2
  00067	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  0006b	75 03		 jne	 SHORT $LN104@Ipfx
  0006d	83 c8 04	 or	 eax, 4
$LN104@Ipfx:
  00070	6a 00		 push	 0
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 121  : 		return (false);

  00078	32 c0		 xor	 al, al

; 122  : 		}

  0007a	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	83 c4 10	 add	 esp, 16			; 00000010H
  00089	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
; Function compile flags: /Ogtpy
;	COMDAT ??_GFileInput@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GFileInput@@UAEPAXI@Z PROC				; FileInput::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8d 79 a8	 lea	 edi, DWORD PTR [ecx-88]
  00005	8d 77 58	 lea	 esi, DWORD PTR [edi+88]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ??1FileInput@@UAE@XZ	; FileInput::~FileInput
  0000e	56		 push	 esi
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  00015	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0001a	83 c4 04	 add	 esp, 4
  0001d	f6 44 24 0c 01	 test	 BYTE PTR ___flags$[esp+4], 1
  00022	74 09		 je	 SHORT $LN11@scalar@28
  00024	57		 push	 edi
  00025	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002a	83 c4 04	 add	 esp, 4
$LN11@scalar@28:
  0002d	8b c7		 mov	 eax, edi
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	c2 04 00	 ret	 4
??_GFileInput@@UAEPAXI@Z ENDP				; FileInput::`scalar deleting destructor'
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Istr$ = 12						; size = 4
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 75   : 			{	// construct locking and calling _Ipfx

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c4		 xor	 eax, esp
  00018	50		 push	 eax
  00019	8d 44 24 10	 lea	 eax, DWORD PTR __$EHRec$[esp+28]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR __Istr$[esp+24]
  00027	8b 7c 24 20	 mov	 edi, DWORD PTR _this$[esp+24]
  0002b	89 07		 mov	 DWORD PTR [edi], eax
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  00036	85 c0		 test	 eax, eax
  00038	74 08		 je	 SHORT $LN11@sentry@4
  0003a	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0003d	e8 00 00 00 00	 call	 ?_Lock@_Mutex@std@@QAEXXZ ; std::_Mutex::_Lock
$LN11@sentry@4:
  00042	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+36], 0

; 76   : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  0004a	8b 37		 mov	 esi, DWORD PTR [edi]
  0004c	e8 00 00 00 00	 call	 ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
  00051	88 47 04	 mov	 BYTE PTR [edi+4], al

; 77   : 			}

  00054	8b c7		 mov	 eax, edi
  00056	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  0005a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00061	59		 pop	 ecx
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	83 c4 10	 add	 esp, 16			; 00000010H
  00067	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 f4	 lea	 eax, DWORD PTR [edx-12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
xdata$x	SEGMENT
__unwindtable$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z$0
__tryblocktable$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z$10
__ehfuncinfo$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z
_TEXT	SEGMENT
__Ok$ = -28						; size = 8
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Str$ = 12						; size = 4
__State$ = 16						; size = 4
__Count$ = 16						; size = 4
?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Read_s, COMDAT

; 679  : 		{	// read up to _Count characters into buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp]
  0002e	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]

; 680  : 		_DEBUG_POINTER(_Str);
; 681  : 		ios_base::iostate _State = ios_base::goodbit;
; 682  : 		_Chcount = 0;
; 683  : 		const sentry _Ok(*this, true);

  00031	56		 push	 esi
  00032	8d 45 e4	 lea	 eax, DWORD PTR __Ok$[ebp]
  00035	33 ff		 xor	 edi, edi
  00037	50		 push	 eax
  00038	89 7d 10	 mov	 DWORD PTR __State$[ebp], edi
  0003b	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0003e	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  00043	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi

; 684  : 
; 685  : 		if (_Ok)

  00046	80 7d e8 00	 cmp	 BYTE PTR __Ok$[ebp+4], 0
  0004a	74 64		 je	 SHORT $LN10@Read_s

; 686  : 			{	// state okay, use facet to extract
; 687  : 			_TRY_IO_BEGIN

  0004c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 688  : 			const streamsize _Num = _Myios::rdbuf()->_Sgetn_s(_Str, _Str_size, _Count);

  00050	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00052	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00055	8b 4c 32 28	 mov	 ecx, DWORD PTR [edx+esi+40]
  00059	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005b	8b 55 0c	 mov	 edx, DWORD PTR __Str$[ebp]
  0005e	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00061	53		 push	 ebx
  00062	6a ff		 push	 -1
  00064	52		 push	 edx
  00065	ff d0		 call	 eax

; 689  : 			_Chcount += _Num;

  00067	01 46 04	 add	 DWORD PTR [esi+4], eax

; 690  : 			if (_Num != _Count)

  0006a	3b c3		 cmp	 eax, ebx
  0006c	74 05		 je	 SHORT $LN1@Read_s

; 691  : 				_State |= ios_base::eofbit | ios_base::failbit;	// short read

  0006e	bf 03 00 00 00	 mov	 edi, 3
$LN1@Read_s:
  00073	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0007a	eb 34		 jmp	 SHORT $LN10@Read_s
__catch$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z$0:

; 692  : 			_CATCH_IO_END

  0007c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00081	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00084	03 c8		 add	 ecx, eax
  00086	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00089	83 c8 04	 or	 eax, 4
  0008c	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  00090	75 03		 jne	 SHORT $LN24@Read_s
  00092	83 c8 04	 or	 eax, 4
$LN24@Read_s:
  00095	6a 01		 push	 1
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
  0009d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000a4	b8 00 00 00 00	 mov	 eax, $LN71@Read_s
  000a9	c3		 ret	 0
$LN71@Read_s:
  000aa	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  000ad	8b 7d 10	 mov	 edi, DWORD PTR __State$[ebp]
$LN10@Read_s:

; 693  : 			}
; 694  : 
; 695  : 		_Myios::setstate(_State);

  000b0	8b 16		 mov	 edx, DWORD PTR [esi]
  000b2	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000b5	03 ce		 add	 ecx, esi
  000b7	85 ff		 test	 edi, edi
  000b9	74 16		 je	 SHORT $LN53@Read_s
  000bb	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000be	0b c7		 or	 eax, edi
  000c0	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  000c4	75 03		 jne	 SHORT $LN55@Read_s
  000c6	83 c8 04	 or	 eax, 4
$LN55@Read_s:
  000c9	6a 00		 push	 0
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN53@Read_s:

; 696  : 		return (*this);

  000d1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000d8	8b 45 e4	 mov	 eax, DWORD PTR __Ok$[ebp]
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000e0	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  000e4	85 c0		 test	 eax, eax
  000e6	74 08		 je	 SHORT $LN70@Read_s
  000e8	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  000eb	e8 00 00 00 00	 call	 ?_Unlock@_Mutex@std@@QAEXXZ ; std::_Mutex::_Unlock
$LN70@Read_s:
  000f0	8b c6		 mov	 eax, esi

; 697  : 		}

  000f2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000f5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fc	59		 pop	 ecx
  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	5b		 pop	 ebx
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z$2:
  00000	8d 45 e4	 lea	 eax, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Read_s
; Function compile flags: /Ogtpy
;	COMDAT ?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z PROC ; std::basic_istream<char,std::char_traits<char> >::read, COMDAT
; __Str$ = ecx
; __Count$ = eax

; 701  : 		return _Read_s(_Str, (size_t)-1, _Count);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	50		 push	 eax
  00005	51		 push	 ecx
  00006	52		 push	 edx
  00007	e8 00 00 00 00	 call	 ?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z ; std::basic_istream<char,std::char_traits<char> >::_Read_s

; 702  : 		}

  0000c	c2 04 00	 ret	 4
?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::read
_TEXT	ENDS
PUBLIC	?cRead@FileInput@@QAEEXZ			; FileInput::cRead
; Function compile flags: /Ogtpy
; File i:\nj\my project\cms\cms\fileinput.cpp
;	COMDAT ?cRead@FileInput@@QAEEXZ
_TEXT	SEGMENT
_cData$ = -1						; size = 1
?cRead@FileInput@@QAEEXZ PROC				; FileInput::cRead, COMDAT
; _this$ = ecx

; 59   : unsigned	char	FileInput::cRead(){

  00000	51		 push	 ecx

; 60   : 
; 61   : 	unsigned	char	cData;
; 62   : 
; 63   : 	read((char*)&cData, sizeof(unsigned char));

  00001	6a 01		 push	 1
  00003	8d 44 24 07	 lea	 eax, DWORD PTR _cData$[esp+8]
  00007	50		 push	 eax
  00008	51		 push	 ecx
  00009	e8 00 00 00 00	 call	 ?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z ; std::basic_istream<char,std::char_traits<char> >::_Read_s

; 64   : 	return(cData);

  0000e	8a 44 24 03	 mov	 al, BYTE PTR _cData$[esp+4]

; 65   : };

  00012	59		 pop	 ecx
  00013	c3		 ret	 0
?cRead@FileInput@@QAEEXZ ENDP				; FileInput::cRead
END

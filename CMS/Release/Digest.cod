; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\?n????j\My Project\CMS\CMS\ASN1\Algorithm\Digest.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?final@Digest@@UAEXPAXI@Z			; Digest::final
PUBLIC	??_R4Digest@@6B@				; Digest::`RTTI Complete Object Locator'
PUBLIC	??_R3Digest@@8					; Digest::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Digest@@8					; Digest::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Digest@@8				; Digest::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVDigest@@@8				; Digest `RTTI Type Descriptor'
PUBLIC	?init@Digest@@UAEXXZ				; Digest::init
PUBLIC	?getHash@Digest@@UAEXPAX@Z			; Digest::getHash
PUBLIC	?calc@Digest@@UAEXPAX@Z				; Digest::calc
PUBLIC	??_7Digest@@6B@					; Digest::`vftable'
;	COMDAT ??_7Digest@@6B@
CONST	SEGMENT
??_7Digest@@6B@ DD FLAT:??_R4Digest@@6B@		; Digest::`vftable'
	DD	FLAT:?encodeBER@Sequence@@UAEXXZ
	DD	FLAT:?Get_BERcode@ASN1@@UAEPBDXZ
	DD	FLAT:?Get_BERsize@ASN1@@UAEIXZ
	DD	FLAT:?init@Digest@@UAEXXZ
	DD	FLAT:?final@Digest@@UAEXPAXI@Z
	DD	FLAT:?getHash@Digest@@UAEXPAX@Z
	DD	FLAT:?calc@Digest@@UAEXPAX@Z
CONST	ENDS
;	COMDAT ??_R4Digest@@6B@
rdata$r	SEGMENT
??_R4Digest@@6B@ DD 00H					; Digest::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDigest@@@8
	DD	FLAT:??_R3Digest@@8
rdata$r	ENDS
;	COMDAT ??_R3Digest@@8
rdata$r	SEGMENT
??_R3Digest@@8 DD 00H					; Digest::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2Digest@@8
rdata$r	ENDS
;	COMDAT ??_R2Digest@@8
rdata$r	SEGMENT
??_R2Digest@@8 DD FLAT:??_R1A@?0A@EA@Digest@@8		; Digest::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@AlgorithmIdentifier@@8
	DD	FLAT:??_R1A@?0A@EA@Sequence@@8
	DD	FLAT:??_R1A@?0A@EA@ASN1@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Digest@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Digest@@8 DD FLAT:??_R0?AVDigest@@@8	; Digest::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Digest@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDigest@@@8
_DATA	SEGMENT
??_R0?AVDigest@@@8 DD FLAT:??_7type_info@@6B@		; Digest `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDigest@@', 00H
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\digest.h
;	COMDAT ?init@Digest@@UAEXXZ
_TEXT	SEGMENT
?init@Digest@@UAEXXZ PROC				; Digest::init, COMDAT
; _this$ = ecx

; 39   : 	virtual	void	init(void){};

  00000	c3		 ret	 0
?init@Digest@@UAEXXZ ENDP				; Digest::init
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getHash@Digest@@UAEXPAX@Z
_TEXT	SEGMENT
_result$ = 8						; size = 4
?getHash@Digest@@UAEXPAX@Z PROC				; Digest::getHash, COMDAT
; _this$ = ecx

; 42   : 	virtual	void	getHash(void *result){};

  00000	c2 04 00	 ret	 4
?getHash@Digest@@UAEXPAX@Z ENDP				; Digest::getHash
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?calc@Digest@@UAEXPAX@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?calc@Digest@@UAEXPAX@Z PROC				; Digest::calc, COMDAT
; _this$ = ecx

; 44   : 	virtual	void	calc(void *data){};

  00000	c2 04 00	 ret	 4
?calc@Digest@@UAEXPAX@Z ENDP				; Digest::calc
_TEXT	ENDS
PUBLIC	?add@Digest@@QAEXPAX@Z				; Digest::add
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\digest.cpp
;	COMDAT ?add@Digest@@QAEXPAX@Z
_TEXT	SEGMENT
?add@Digest@@QAEXPAX@Z PROC				; Digest::add, COMDAT
; _this$ = esi
; _data$ = ecx

; 68   : 	calc(data);

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00005	51		 push	 ecx
  00006	8b ce		 mov	 ecx, esi
  00008	ff d2		 call	 edx

; 69   : 	iCountBlock++;

  0000a	ff 86 a0 00 00
	00		 inc	 DWORD PTR [esi+160]

; 70   : }

  00010	c3		 ret	 0
?add@Digest@@QAEXPAX@Z ENDP				; Digest::add
_TEXT	ENDS
PUBLIC	?CalcHash@Digest@@QAEXPAX0I@Z			; Digest::CalcHash
; Function compile flags: /Ogtpy
;	COMDAT ?CalcHash@Digest@@QAEXPAX0I@Z
_TEXT	SEGMENT
_result$ = 8						; size = 4
_data$ = 12						; size = 4
_iSize$ = 16						; size = 4
?CalcHash@Digest@@QAEXPAX0I@Z PROC			; Digest::CalcHash, COMDAT
; _this$ = esi

; 39   : 	unsigned	int		i			= iSize;
; 40   : 	unsigned	char*	cData		= (unsigned	char*)data;
; 41   : 	unsigned	int		_szBlock	=	szBlock;	//頻度に使うのでレジスタに入って貰う。
; 42   : 
; 43   : 	init();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00005	53		 push	 ebx
  00006	8b 5c 24 0c	 mov	 ebx, DWORD PTR _data$[esp]
  0000a	55		 push	 ebp
  0000b	8b 6c 24 14	 mov	 ebp, DWORD PTR _iSize$[esp+4]
  0000f	57		 push	 edi
  00010	8b be a4 00 00
	00		 mov	 edi, DWORD PTR [esi+164]
  00016	8b ce		 mov	 ecx, esi
  00018	ff d2		 call	 edx

; 44   : 
; 45   : 	while(i>0){

  0001a	85 ed		 test	 ebp, ebp
  0001c	76 37		 jbe	 SHORT $LN3@CalcHash
  0001e	8b ff		 npad	 2
$LL4@CalcHash:

; 46   : 		if(i>=_szBlock){
; 47   : 			add(cData);

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	8b ce		 mov	 ecx, esi
  00024	3b ef		 cmp	 ebp, edi
  00026	72 26		 jb	 SHORT $LN2@CalcHash
  00028	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0002b	53		 push	 ebx
  0002c	ff d2		 call	 edx
  0002e	ff 86 a0 00 00
	00		 inc	 DWORD PTR [esi+160]

; 48   : 			cData += _szBlock;

  00034	03 df		 add	 ebx, edi

; 49   : 			i -= _szBlock;

  00036	2b ef		 sub	 ebp, edi
  00038	75 e6		 jne	 SHORT $LL4@CalcHash

; 52   : 			break;
; 53   : 		}
; 54   : 	}
; 55   : 
; 56   : 	getHash(result);

  0003a	8b 4c 24 10	 mov	 ecx, DWORD PTR _result$[esp+8]
  0003e	8b 06		 mov	 eax, DWORD PTR [esi]
  00040	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00043	51		 push	 ecx
  00044	8b ce		 mov	 ecx, esi
  00046	ff d2		 call	 edx
  00048	5f		 pop	 edi
  00049	5d		 pop	 ebp
  0004a	5b		 pop	 ebx

; 57   : }

  0004b	c2 0c 00	 ret	 12			; 0000000cH
$LN2@CalcHash:

; 50   : 		} else {
; 51   : 			final(cData,i);

  0004e	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00051	55		 push	 ebp
  00052	53		 push	 ebx
  00053	ff d2		 call	 edx
$LN3@CalcHash:

; 52   : 			break;
; 53   : 		}
; 54   : 	}
; 55   : 
; 56   : 	getHash(result);

  00055	8b 4c 24 10	 mov	 ecx, DWORD PTR _result$[esp+8]
  00059	8b 06		 mov	 eax, DWORD PTR [esi]
  0005b	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0005e	51		 push	 ecx
  0005f	8b ce		 mov	 ecx, esi
  00061	ff d2		 call	 edx
  00063	5f		 pop	 edi
  00064	5d		 pop	 ebp
  00065	5b		 pop	 ebx

; 57   : }

  00066	c2 0c 00	 ret	 12			; 0000000cH
?CalcHash@Digest@@QAEXPAX0I@Z ENDP			; Digest::CalcHash
; Function compile flags: /Ogtpy
;	COMDAT ?final@Digest@@UAEXPAXI@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_iTotalSize$ = -8					; size = 8
_data$ = 8						; size = 4
_iSize$ = 12						; size = 4
?final@Digest@@UAEXPAXI@Z PROC				; Digest::final, COMDAT
; _this$ = ecx

; 83   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 84   : 	unsigned	int			i = 0;
; 85   : 
; 86   : 	unsigned	__int64		iTotalSize	= ((iCountBlock*64)+iSize)*8;

  00009	8b 55 0c	 mov	 edx, DWORD PTR _iSize$[ebp]
  0000c	53		 push	 ebx
  0000d	8b d9		 mov	 ebx, ecx
  0000f	8b 8b a0 00 00
	00		 mov	 ecx, DWORD PTR [ebx+160]
  00015	c1 e1 06	 shl	 ecx, 6
  00018	03 ca		 add	 ecx, edx
  0001a	03 c9		 add	 ecx, ecx
  0001c	56		 push	 esi

; 87   : 	unsigned	char*		cData		= (unsigned char*)data;
; 88   : 
; 89   : 	//頻度に使うのでレジスタに入って貰う。
; 90   : 	unsigned	char*		_M			= M;

  0001d	8b b3 ac 00 00
	00		 mov	 esi, DWORD PTR [ebx+172]
  00023	03 c9		 add	 ecx, ecx
  00025	57		 push	 edi

; 91   : 	unsigned	int			_szBlock	= szBlock;

  00026	8b bb a4 00 00
	00		 mov	 edi, DWORD PTR [ebx+164]
  0002c	33 c0		 xor	 eax, eax
  0002e	03 c9		 add	 ecx, ecx
  00030	89 4c 24 10	 mov	 DWORD PTR _iTotalSize$[esp+24], ecx
  00034	89 44 24 14	 mov	 DWORD PTR _iTotalSize$[esp+28], eax

; 92   : 
; 93   : 	//--------------------
; 94   : 	//BlockSizeぴったりだった。
; 95   : 	if(iSize == _szBlock){

  00038	3b d7		 cmp	 edx, edi
  0003a	75 21		 jne	 SHORT $LN4@final

; 96   : 		add(data);

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0003f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00041	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00044	51		 push	 ecx
  00045	8b cb		 mov	 ecx, ebx
  00047	ff d2		 call	 edx
  00049	ff 83 a0 00 00
	00		 inc	 DWORD PTR [ebx+160]

; 97   : 		iSize = 0;

  0004f	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _iSize$[ebp], 0
  00056	8b 55 0c	 mov	 edx, DWORD PTR _iSize$[ebp]
  00059	8b c2		 mov	 eax, edx
  0005b	eb 19		 jmp	 SHORT $LN2@final
$LN4@final:

; 98   : 	}
; 99   : 
; 100  : 	//--------------------
; 101  : 	//配列へ
; 102  : 	else if(iSize>0){

  0005d	3b d0		 cmp	 edx, eax
  0005f	76 15		 jbe	 SHORT $LN2@final

; 103  : 		memcpy(_M, cData, iSize);

  00061	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00064	52		 push	 edx
  00065	50		 push	 eax
  00066	56		 push	 esi
  00067	e8 00 00 00 00	 call	 _memcpy

; 104  : 		i = iSize;

  0006c	8b 4d 0c	 mov	 ecx, DWORD PTR _iSize$[ebp]
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00072	8b d1		 mov	 edx, ecx
  00074	8b c1		 mov	 eax, ecx
$LN2@final:

; 105  : 	}
; 106  : 
; 107  : 	_M[i] = 0x80;

  00076	c6 04 06 80	 mov	 BYTE PTR [esi+eax], 128	; 00000080H

; 108  : 	i++;
; 109  : 
; 110  : 	//--------------------
; 111  : 	//サイズを書き込めない場合
; 112  : 	if(iSize >= (_szBlock-8)){

  0007a	8d 4f f8	 lea	 ecx, DWORD PTR [edi-8]
  0007d	40		 inc	 eax
  0007e	3b d1		 cmp	 edx, ecx
  00080	72 2e		 jb	 SHORT $LN1@final

; 113  : 		memset(&_M[i],0,_szBlock - i);

  00082	8b d7		 mov	 edx, edi
  00084	2b d0		 sub	 edx, eax
  00086	52		 push	 edx
  00087	03 c6		 add	 eax, esi
  00089	6a 00		 push	 0
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _memset

; 114  : 		add(_M);

  00091	8b 13		 mov	 edx, DWORD PTR [ebx]
  00093	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
  00099	56		 push	 esi
  0009a	8b cb		 mov	 ecx, ebx
  0009c	ff d0		 call	 eax
  0009e	ff 83 a0 00 00
	00		 inc	 DWORD PTR [ebx+160]

; 115  : 		i = 0;

  000a4	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _i$[esp+24], 0
  000ac	8b 44 24 0c	 mov	 eax, DWORD PTR _i$[esp+24]
$LN1@final:

; 116  : 	}
; 117  : 
; 118  : 	//--------------------
; 119  : 	//サイズの所まで、0x00で埋める。
; 120  : 	memset(&_M[i],0,(_szBlock-8)-i);

  000b0	8b cf		 mov	 ecx, edi
  000b2	2b c8		 sub	 ecx, eax
  000b4	83 e9 08	 sub	 ecx, 8
  000b7	51		 push	 ecx
  000b8	8d 14 06	 lea	 edx, DWORD PTR [esi+eax]
  000bb	6a 00		 push	 0
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _memset

; 121  : 	i = (_szBlock - 8)-i;
; 122  : 
; 123  : 	//--------------------
; 124  : 	//サイズ書き込み。
; 125  : 	_M[_szBlock - 8] = (iTotalSize>>56) & 0xFF;

  000c3	8b 44 24 20	 mov	 eax, DWORD PTR _iTotalSize$[esp+40]
  000c7	8b c8		 mov	 ecx, eax
  000c9	c1 e9 18	 shr	 ecx, 24			; 00000018H
  000cc	88 4c 37 f8	 mov	 BYTE PTR [edi+esi-8], cl

; 126  : 	_M[_szBlock - 7] = (iTotalSize>>48) & 0xFF;

  000d0	8b d0		 mov	 edx, eax
  000d2	c1 ea 10	 shr	 edx, 16			; 00000010H
  000d5	88 54 37 f9	 mov	 BYTE PTR [edi+esi-7], dl

; 127  : 	_M[_szBlock - 6] = (iTotalSize>>40) & 0xFF;

  000d9	8b c8		 mov	 ecx, eax
  000db	c1 e9 08	 shr	 ecx, 8
  000de	88 4c 37 fa	 mov	 BYTE PTR [edi+esi-6], cl

; 128  : 	_M[_szBlock - 5] = (iTotalSize>>32) & 0xFF;
; 129  : 	_M[_szBlock - 4] = (iTotalSize>>24) & 0xFF;

  000e2	8b 4c 24 1c	 mov	 ecx, DWORD PTR _iTotalSize$[esp+36]
  000e6	8b d0		 mov	 edx, eax
  000e8	88 54 37 fb	 mov	 BYTE PTR [edi+esi-5], dl
  000ec	0f ac d1 18	 shrd	 ecx, edx, 24
  000f0	c1 ea 18	 shr	 edx, 24			; 00000018H
  000f3	88 4c 37 fc	 mov	 BYTE PTR [edi+esi-4], cl

; 130  : 	_M[_szBlock - 3] = (iTotalSize>>16) & 0xFF;

  000f7	8b 4c 24 1c	 mov	 ecx, DWORD PTR _iTotalSize$[esp+36]
  000fb	8b d0		 mov	 edx, eax
  000fd	0f ac d1 10	 shrd	 ecx, edx, 16
  00101	88 4c 37 fd	 mov	 BYTE PTR [edi+esi-3], cl

; 131  : 	_M[_szBlock - 2] = (iTotalSize>>8) & 0xFF;

  00105	8b 4c 24 1c	 mov	 ecx, DWORD PTR _iTotalSize$[esp+36]
  00109	c1 ea 10	 shr	 edx, 16			; 00000010H
  0010c	8b d1		 mov	 edx, ecx
  0010e	0f ac c2 08	 shrd	 edx, eax, 8
  00112	88 54 37 fe	 mov	 BYTE PTR [edi+esi-2], dl

; 132  : 	_M[_szBlock - 1] = iTotalSize & 0xFF;

  00116	88 4c 37 ff	 mov	 BYTE PTR [edi+esi-1], cl
  0011a	c1 e8 08	 shr	 eax, 8

; 133  : 
; 134  : 	calc(_M);

  0011d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0011f	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00122	83 c4 0c	 add	 esp, 12			; 0000000cH
  00125	56		 push	 esi
  00126	8b cb		 mov	 ecx, ebx
  00128	ff d2		 call	 edx

; 135  : }

  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi
  0012c	5b		 pop	 ebx
  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c2 08 00	 ret	 8
?final@Digest@@UAEXPAXI@Z ENDP				; Digest::final
PUBLIC	??1Digest@@QAE@XZ				; Digest::~Digest
; Function compile flags: /Ogtpy
;	COMDAT ??1Digest@@QAE@XZ
_TEXT	SEGMENT
??1Digest@@QAE@XZ PROC					; Digest::~Digest, COMDAT
; _this$ = esi

; 25   : {

  00000	57		 push	 edi

; 26   : }

  00001	8d 7e 44	 lea	 edi, DWORD PTR [esi+68]
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7AlgorithmIdentifier@@6B@
  0000a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7ObjectIdentifier@@6B@
  00010	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  00013	85 c0		 test	 eax, eax
  00015	74 09		 je	 SHORT $LN12@Digest
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN12@Digest:
  00020	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  00023	50		 push	 eax
  00024	c7 47 50 00 00
	00 00		 mov	 DWORD PTR [edi+80], 0
  0002b	c7 47 54 00 00
	00 00		 mov	 DWORD PTR [edi+84], 0
  00032	c7 47 58 00 00
	00 00		 mov	 DWORD PTR [edi+88], 0
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 04	 add	 esp, 4
  00041	e8 00 00 00 00	 call	 ??1ASN1@@QAE@XZ		; ASN1::~ASN1
  00046	8b fe		 mov	 edi, esi
  00048	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Sequence@@6B@
  0004e	e8 00 00 00 00	 call	 ??1ASN1@@QAE@XZ		; ASN1::~ASN1
  00053	5f		 pop	 edi
  00054	c3		 ret	 0
??1Digest@@QAE@XZ ENDP					; Digest::~Digest
PUBLIC	??0Digest@@QAE@QBD@Z				; Digest::Digest
; Function compile flags: /Ogtpy
;	COMDAT ??0Digest@@QAE@QBD@Z
_TEXT	SEGMENT
??0Digest@@QAE@QBD@Z PROC				; Digest::Digest, COMDAT
; _this$ = esi
; __strName$ = eax

; 14   : {

  00000	51		 push	 ecx
  00001	50		 push	 eax
  00002	56		 push	 esi
  00003	e8 00 00 00 00	 call	 ??0AlgorithmIdentifier@@QAE@QBD@Z ; AlgorithmIdentifier::AlgorithmIdentifier
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Digest@@6B@

; 15   : }

  0000e	8b c6		 mov	 eax, esi
  00010	59		 pop	 ecx
  00011	c3		 ret	 0
??0Digest@@QAE@QBD@Z ENDP				; Digest::Digest
END

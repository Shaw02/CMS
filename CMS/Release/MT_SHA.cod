; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\?n????j\My Project\CMS\CMS\ASN1\Algorithm\MT_SHA.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?generate@MT_SHA@@QAEXXZ			; MT_SHA::generate
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\mt_sha.cpp
;	COMDAT ?generate@MT_SHA@@QAEXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?generate@MT_SHA@@QAEXXZ PROC				; MT_SHA::generate, COMDAT

; 37   : {

  00000	53		 push	 ebx
  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _this$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi

; 38   : 	unsigned	int	i = sizeof(cHashBuff)/sizeof(int);

  00007	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  0000c	8d bb e0 0a 00
	00		 lea	 edi, DWORD PTR [ebx+2784]
$LL3@generate:

; 39   : 
; 40   : 	//MT乱数取得（64Byte分）
; 41   : 	do{
; 42   : 		i--;
; 43   : 		cHashBuff.i[i] = genrand_int32();

  00012	53		 push	 ebx
  00013	4e		 dec	 esi
  00014	83 ef 04	 sub	 edi, 4
  00017	e8 00 00 00 00	 call	 ?genrand_int32@MT@@QAEKXZ ; MT::genrand_int32
  0001c	89 07		 mov	 DWORD PTR [edi], eax

; 44   : 	} while(i);

  0001e	85 f6		 test	 esi, esi
  00020	75 f0		 jne	 SHORT $LL3@generate

; 45   : 
; 46   : 	//乱数から、更にSHA-256ハッシュ値を得る。
; 47   : 	cSHA.init();

  00022	8b 83 c4 09 00
	00		 mov	 eax, DWORD PTR [ebx+2500]
  00028	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002b	8d b3 c4 09 00
	00		 lea	 esi, DWORD PTR [ebx+2500]
  00031	8b ce		 mov	 ecx, esi
  00033	ff d2		 call	 edx

; 48   : 	cSHA.final(cHashBuff.c, SHA_BlockSize);

  00035	8b 06		 mov	 eax, DWORD PTR [esi]
  00037	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0003a	6a 40		 push	 64			; 00000040H
  0003c	81 c3 a0 0a 00
	00		 add	 ebx, 2720		; 00000aa0H
  00042	53		 push	 ebx
  00043	8b ce		 mov	 ecx, esi
  00045	ff d2		 call	 edx
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx

; 49   : }

  0004a	c2 04 00	 ret	 4
?generate@MT_SHA@@QAEXXZ ENDP				; MT_SHA::generate
PUBLIC	__$ArrayPad$
PUBLIC	?get__m128i@MT_SHA@@QAE?AT__m128i@@XZ		; MT_SHA::get__m128i
; Function compile flags: /Ogtpy
;	COMDAT ?get__m128i@MT_SHA@@QAE?AT__m128i@@XZ
_TEXT	SEGMENT
_result$ = -144						; size = 128
__$ArrayPad$ = -4					; size = 4
?get__m128i@MT_SHA@@QAE?AT__m128i@@XZ PROC		; MT_SHA::get__m128i, COMDAT
; ___$ReturnUdt$ = esi

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	81 ec 9c 00 00
	00		 sub	 esp, 156		; 0000009cH
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	33 c4		 xor	 eax, esp
  00013	89 84 24 98 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+156], eax
  0001a	57		 push	 edi
  0001b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?cRandom@@3PAVMT_SHA@@A ; cRandom

; 107  : union{
; 108  : 	int		i[SHA256_HashSize];
; 109  : 	__m128i	_m;
; 110  : }	result;
; 111  : 
; 112  : 	generate();

  00021	57		 push	 edi
  00022	e8 00 00 00 00	 call	 ?generate@MT_SHA@@QAEXXZ ; MT_SHA::generate

; 113  : 	cSHA.getHash((__m128i*)&result._m);	//リトルエンディアンに変換

  00027	8b 87 c4 09 00
	00		 mov	 eax, DWORD PTR [edi+2500]
  0002d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00030	8d 8f c4 09 00
	00		 lea	 ecx, DWORD PTR [edi+2500]
  00036	8d 54 24 10	 lea	 edx, DWORD PTR _result$[esp+160]
  0003a	52		 push	 edx
  0003b	ff d0		 call	 eax

; 114  : 	return(result._m);
; 115  : 
; 116  : //	return(_mm_loadu_si128((__m128i *)&cSHA->H[0]));
; 117  : }

  0003d	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+160]
  00044	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR _result$[esp+160]
  0004a	5f		 pop	 edi
  0004b	33 cc		 xor	 ecx, esp
  0004d	66 0f 7f 06	 movdqa	 XMMWORD PTR [esi], xmm0
  00051	8b c6		 mov	 eax, esi
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?get__m128i@MT_SHA@@QAE?AT__m128i@@XZ ENDP		; MT_SHA::get__m128i
_TEXT	ENDS
PUBLIC	?get_int64@MT_SHA@@QAE_JXZ			; MT_SHA::get_int64
; Function compile flags: /Ogtpy
;	COMDAT ?get_int64@MT_SHA@@QAE_JXZ
_TEXT	SEGMENT
_result$ = -36						; size = 32
?get_int64@MT_SHA@@QAE_JXZ PROC				; MT_SHA::get_int64, COMDAT

; 89   : {

  00000	83 ec 28	 sub	 esp, 40			; 00000028H
  00003	56		 push	 esi
  00004	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cRandom@@3PAVMT_SHA@@A ; cRandom

; 90   : 	__int64		result[SHA256_HashSize/sizeof(__int64)];
; 91   : 
; 92   : 	generate();

  0000a	56		 push	 esi
  0000b	e8 00 00 00 00	 call	 ?generate@MT_SHA@@QAEXXZ ; MT_SHA::generate

; 93   : 	cSHA.getHash(result);

  00010	8b 86 c4 09 00
	00		 mov	 eax, DWORD PTR [esi+2500]
  00016	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00019	8d 8e c4 09 00
	00		 lea	 ecx, DWORD PTR [esi+2500]
  0001f	8d 54 24 08	 lea	 edx, DWORD PTR _result$[esp+44]
  00023	52		 push	 edx
  00024	ff d0		 call	 eax

; 94   : 
; 95   : 	return(result[0]);

  00026	8b 44 24 08	 mov	 eax, DWORD PTR _result$[esp+44]
  0002a	8b 54 24 0c	 mov	 edx, DWORD PTR _result$[esp+48]

; 96   : }

  0002e	5e		 pop	 esi
  0002f	83 c4 28	 add	 esp, 40			; 00000028H
  00032	c3		 ret	 0
?get_int64@MT_SHA@@QAE_JXZ ENDP				; MT_SHA::get_int64
_TEXT	ENDS
PUBLIC	?get_int@MT_SHA@@QAEHXZ				; MT_SHA::get_int
; Function compile flags: /Ogtpy
;	COMDAT ?get_int@MT_SHA@@QAEHXZ
_TEXT	SEGMENT
_result$ = -32						; size = 32
?get_int@MT_SHA@@QAEHXZ PROC				; MT_SHA::get_int, COMDAT

; 72   : {

  00000	83 ec 20	 sub	 esp, 32			; 00000020H
  00003	56		 push	 esi
  00004	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cRandom@@3PAVMT_SHA@@A ; cRandom

; 73   : 	int		result[SHA256_HashSize/sizeof(int)];
; 74   : 
; 75   : 	generate();

  0000a	56		 push	 esi
  0000b	e8 00 00 00 00	 call	 ?generate@MT_SHA@@QAEXXZ ; MT_SHA::generate

; 76   : 	cSHA.getHash(result);

  00010	8b 86 c4 09 00
	00		 mov	 eax, DWORD PTR [esi+2500]
  00016	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00019	8d 8e c4 09 00
	00		 lea	 ecx, DWORD PTR [esi+2500]
  0001f	8d 54 24 04	 lea	 edx, DWORD PTR _result$[esp+36]
  00023	52		 push	 edx
  00024	ff d0		 call	 eax

; 77   : 
; 78   : 	return(result[0]);

  00026	8b 44 24 04	 mov	 eax, DWORD PTR _result$[esp+36]
  0002a	5e		 pop	 esi

; 79   : }

  0002b	83 c4 20	 add	 esp, 32			; 00000020H
  0002e	c3		 ret	 0
?get_int@MT_SHA@@QAEHXZ ENDP				; MT_SHA::get_int
_TEXT	ENDS
PUBLIC	?get256@MT_SHA@@QAEXPAX@Z			; MT_SHA::get256
; Function compile flags: /Ogtpy
;	COMDAT ?get256@MT_SHA@@QAEXPAX@Z
_TEXT	SEGMENT
_result$ = 8						; size = 4
?get256@MT_SHA@@QAEXPAX@Z PROC				; MT_SHA::get256, COMDAT

; 59   : {

  00000	56		 push	 esi
  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cRandom@@3PAVMT_SHA@@A ; cRandom

; 60   : 	generate();

  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?generate@MT_SHA@@QAEXXZ ; MT_SHA::generate

; 61   : 	cSHA.getHash(result);

  0000d	8b 86 c4 09 00
	00		 mov	 eax, DWORD PTR [esi+2500]
  00013	8d 8e c4 09 00
	00		 lea	 ecx, DWORD PTR [esi+2500]
  00019	5e		 pop	 esi
  0001a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001d	ff e0		 jmp	 eax
?get256@MT_SHA@@QAEXPAX@Z ENDP				; MT_SHA::get256
PUBLIC	??1MT_SHA@@QAE@XZ				; MT_SHA::~MT_SHA
; Function compile flags: /Ogtpy
;	COMDAT ??1MT_SHA@@QAE@XZ
_TEXT	SEGMENT
??1MT_SHA@@QAE@XZ PROC					; MT_SHA::~MT_SHA, COMDAT
; _this$ = eax

; 25   : {

  00000	56		 push	 esi

; 26   : }

  00001	8b f0		 mov	 esi, eax
  00003	81 c6 c4 09 00
	00		 add	 esi, 2500		; 000009c4H
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7SHA256@@6B@
  0000f	e8 00 00 00 00	 call	 ??1SHA@@QAE@XZ		; SHA::~SHA
  00014	5e		 pop	 esi
  00015	c3		 ret	 0
??1MT_SHA@@QAE@XZ ENDP					; MT_SHA::~MT_SHA
PUBLIC	??0MT_SHA@@QAE@QAKI@Z				; MT_SHA::MT_SHA
; Function compile flags: /Ogtpy
;	COMDAT ??0MT_SHA@@QAE@QAKI@Z
_TEXT	SEGMENT
??0MT_SHA@@QAE@QAKI@Z PROC				; MT_SHA::MT_SHA, COMDAT
; _this$ = esi
; _init_key$ = eax

; 14   : {

  00000	51		 push	 ecx
  00001	50		 push	 eax
  00002	8b c6		 mov	 eax, esi
  00004	c7 86 c0 09 00
	00 71 02 00 00	 mov	 DWORD PTR [esi+2496], 625 ; 00000271H
  0000e	e8 00 00 00 00	 call	 ?init_by_array@MT@@QAEXQAKI@Z ; MT::init_by_array
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_07DKFLFLPF@SHA?9256?$AA@
  00018	8d 8e c4 09 00
	00		 lea	 ecx, DWORD PTR [esi+2500]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ??0SHA256@@QAE@QBD@Z	; SHA256::SHA256

; 15   : }

  00024	8b c6		 mov	 eax, esi
  00026	59		 pop	 ecx
  00027	c3		 ret	 0
??0MT_SHA@@QAE@QAKI@Z ENDP				; MT_SHA::MT_SHA
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\?n????j\My Project\CMS\CMS\ASN1\Algorithm\HMAC.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4HMAC@@6B@					; HMAC::`RTTI Complete Object Locator'
PUBLIC	??_7HMAC@@6B@					; HMAC::`vftable'
;	COMDAT ??_7HMAC@@6B@
CONST	SEGMENT
??_7HMAC@@6B@ DD FLAT:??_R4HMAC@@6B@			; HMAC::`vftable'
	DD	FLAT:?encodeBER@Sequence@@UAEXXZ
	DD	FLAT:?Get_BERcode@ASN1@@UAEPBDXZ
	DD	FLAT:?Get_BERsize@ASN1@@UAEIXZ
CONST	ENDS
;	COMDAT ??_R4HMAC@@6B@
rdata$r	SEGMENT
??_R4HMAC@@6B@ DD 00H					; HMAC::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVHMAC@@@8
	DD	FLAT:??_R3HMAC@@8
rdata$r	ENDS
;	COMDAT ?_mm_5C@?8??SetKey@HMAC@@QAEXPAXI@Z@4T_mm_i32@2@B
CONST	SEGMENT
?_mm_5C@?8??SetKey@HMAC@@QAEXPAXI@Z@4T_mm_i32@2@B DD 05c5c5c5cH ; `HMAC::SetKey'::`9'::_mm_5C
	DD	05c5c5c5cH
	DD	05c5c5c5cH
	DD	05c5c5c5cH
CONST	ENDS
;	COMDAT ?_mm_36@?8??SetKey@HMAC@@QAEXPAXI@Z@4T_mm_i32@2@B
CONST	SEGMENT
?_mm_36@?8??SetKey@HMAC@@QAEXPAXI@Z@4T_mm_i32@2@B DD 036363636H ; `HMAC::SetKey'::`9'::_mm_36
	DD	036363636H
	DD	036363636H
	DD	036363636H
PUBLIC	?calc@HMAC@@QAEXPAX0I@Z				; HMAC::calc
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\hmac.cpp
;	COMDAT ?calc@HMAC@@QAEXPAX0I@Z
_TEXT	SEGMENT
_szHash$ = -4						; size = 4
_this$ = 8						; size = 4
_result$ = 12						; size = 4
_data$ = 16						; size = 4
_szData$ = 20						; size = 4
?calc@HMAC@@QAEXPAX0I@Z PROC				; HMAC::calc, COMDAT

; 108  : {

  00000	51		 push	 ecx

; 109  : 			unsigned	int		i	=	szData;
; 110  : 
; 111  : 	//頻度にアクセスするので、レジスタに入れる。
; 112  : 			Digest*			_cHash	=	cHash;				//ハッシュ関数のポインタ

  00001	8b 44 24 08	 mov	 eax, DWORD PTR _this$[esp]
  00005	53		 push	 ebx

; 113  : 	const	unsigned	int	szBlock =	_cHash->szBlock;	//ハッシュ関数の入力ブロック長
; 114  : 	const	unsigned	int	szHash	=	_cHash->szHash;		//ハッシュ関数の出力長
; 115  : 
; 116  : 	//------------
; 117  : 	//計算
; 118  : 	{
; 119  : 		//変数定義
; 120  : 		char*	cData	= (char *)data;

  00006	8b 5c 24 14	 mov	 ebx, DWORD PTR _data$[esp+4]
  0000a	55		 push	 ebp
  0000b	8b 6c 24 1c	 mov	 ebp, DWORD PTR _szData$[esp+8]
  0000f	56		 push	 esi
  00010	8b b0 a0 00 00
	00		 mov	 esi, DWORD PTR [eax+160]
  00016	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]

; 121  : 
; 122  : 		//1st PASS
; 123  : 		_cHash->init();

  0001c	8b 16		 mov	 edx, DWORD PTR [esi]
  0001e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00021	89 4c 24 0c	 mov	 DWORD PTR _szHash$[esp+16], ecx
  00025	57		 push	 edi
  00026	8b be a4 00 00
	00		 mov	 edi, DWORD PTR [esi+164]
  0002c	8b ce		 mov	 ecx, esi
  0002e	ff d0		 call	 eax

; 124  : 		_cHash->add(Kipad);

  00030	8b 44 24 18	 mov	 eax, DWORD PTR _this$[esp+16]
  00034	8b 88 e8 00 00
	00		 mov	 ecx, DWORD PTR [eax+232]
  0003a	8b 16		 mov	 edx, DWORD PTR [esi]
  0003c	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  0003f	51		 push	 ecx
  00040	8b ce		 mov	 ecx, esi
  00042	ff d2		 call	 edx
  00044	ff 86 a0 00 00
	00		 inc	 DWORD PTR [esi+160]

; 125  : 		while(i>0){

  0004a	85 ed		 test	 ebp, ebp
  0004c	76 25		 jbe	 SHORT $LN3@calc@3
  0004e	8b ff		 npad	 2
$LL4@calc@3:

; 126  : 			if(i>=szBlock){
; 127  : 				_cHash->add(cData);

  00050	8b 06		 mov	 eax, DWORD PTR [esi]
  00052	8b ce		 mov	 ecx, esi
  00054	3b ef		 cmp	 ebp, edi
  00056	72 14		 jb	 SHORT $LN2@calc@3
  00058	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0005b	53		 push	 ebx
  0005c	ff d2		 call	 edx
  0005e	ff 86 a0 00 00
	00		 inc	 DWORD PTR [esi+160]

; 128  : 				cData += szBlock;

  00064	03 df		 add	 ebx, edi

; 129  : 				i -= szBlock;

  00066	2b ef		 sub	 ebp, edi
  00068	75 e6		 jne	 SHORT $LL4@calc@3
  0006a	eb 07		 jmp	 SHORT $LN3@calc@3
$LN2@calc@3:

; 130  : 			} else {
; 131  : 				_cHash->final(cData,i);

  0006c	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0006f	55		 push	 ebp
  00070	53		 push	 ebx
  00071	ff d2		 call	 edx
$LN3@calc@3:

; 132  : 				break;
; 133  : 			}
; 134  : 		}
; 135  : 		_cHash->getHash(&Kopad[szBlock]);

  00073	8b 5c 24 18	 mov	 ebx, DWORD PTR _this$[esp+16]
  00077	8b 8b ec 00 00
	00		 mov	 ecx, DWORD PTR [ebx+236]
  0007d	8b 06		 mov	 eax, DWORD PTR [esi]
  0007f	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00082	03 cf		 add	 ecx, edi
  00084	51		 push	 ecx
  00085	8b ce		 mov	 ecx, esi
  00087	ff d2		 call	 edx

; 136  : 
; 137  : 		//2nd PASS
; 138  : 		_cHash->CalcHash(result, Kopad, szBlock + szHash);

  00089	8b 44 24 10	 mov	 eax, DWORD PTR _szHash$[esp+20]
  0008d	8b 8b ec 00 00
	00		 mov	 ecx, DWORD PTR [ebx+236]
  00093	8b 54 24 1c	 mov	 edx, DWORD PTR _result$[esp+16]
  00097	03 c7		 add	 eax, edi
  00099	50		 push	 eax
  0009a	51		 push	 ecx
  0009b	52		 push	 edx
  0009c	e8 00 00 00 00	 call	 ?CalcHash@Digest@@QAEXPAX0I@Z ; Digest::CalcHash
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5d		 pop	 ebp
  000a4	5b		 pop	 ebx

; 139  : 	}
; 140  : }

  000a5	59		 pop	 ecx
  000a6	c2 10 00	 ret	 16			; 00000010H
?calc@HMAC@@QAEXPAX0I@Z ENDP				; HMAC::calc
_TEXT	ENDS
PUBLIC	_Key$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?SetKey@HMAC@@QAEXPAXI@Z			; HMAC::SetKey
EXTRN	___security_cookie:DWORD
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?SetKey@HMAC@@QAEXPAXI@Z
_TEXT	SEGMENT
tv208 = -44						; size = 4
_Key$GSCopy$ = -44					; size = 4
_szBlock$ = -40						; size = 4
_szHash$ = -36						; size = 4
__mm_temp$39077 = -32					; size = 16
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
?SetKey@HMAC@@QAEXPAXI@Z PROC				; HMAC::SetKey, COMDAT
; _Key$ = edx
; _szKey$ = ecx

; 46   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	83 ec 34	 sub	 esp, 52			; 00000034H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 30	 mov	 DWORD PTR __$ArrayPad$[esp+52], eax
  00014	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00017	53		 push	 ebx

; 47   : 	//頻度にアクセスするので、レジスタに入れる。
; 48   : 			Digest*			_cHash	=	cHash;				//ハッシュ関数のポインタ
; 49   : 	const	unsigned	int	szBlock =	_cHash->szBlock;	//ハッシュ関数の入力ブロック長
; 50   : 	const	unsigned	int	szHash	=	_cHash->szHash;		//ハッシュ関数の出力長
; 51   : 			char*			_Kipad	=	Kipad;				//最適化でレジスタに入れて貰う。
; 52   : 			char*			_Kopad	=	Kopad;				//

  00018	8b 98 ec 00 00
	00		 mov	 ebx, DWORD PTR [eax+236]
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	8b f1		 mov	 esi, ecx
  00022	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00028	8b b9 a4 00 00
	00		 mov	 edi, DWORD PTR [ecx+164]
  0002e	89 7c 24 18	 mov	 DWORD PTR _szBlock$[esp+64], edi
  00032	8b b9 a8 00 00
	00		 mov	 edi, DWORD PTR [ecx+168]

; 53   : 
; 54   : 	//------------
; 55   : 	//鍵の0x00Padding
; 56   : 	{
; 57   : 		//変数定義
; 58   : 		const	char*	cKey			= (char *)Key;
; 59   : 
; 60   : 		//Padding実施
; 61   : 		if(szKey > szBlock){
; 62   : 			_cHash->CalcHash(_Kipad, Key, szKey);

  00038	56		 push	 esi
  00039	89 7c 24 20	 mov	 DWORD PTR _szHash$[esp+68], edi
  0003d	8b b8 e8 00 00
	00		 mov	 edi, DWORD PTR [eax+232]
  00043	52		 push	 edx

; 68   : 		}
; 69   : 		memset(&_Kipad[szKey],0x00,szBlock - szKey);

  00044	89 54 24 1c	 mov	 DWORD PTR _Key$GSCopy$[esp+72], edx
  00048	57		 push	 edi
  00049	3b 74 24 24	 cmp	 esi, DWORD PTR _szBlock$[esp+76]
  0004d	76 18		 jbe	 SHORT $LN4@SetKey
  0004f	8b f1		 mov	 esi, ecx
  00051	e8 00 00 00 00	 call	 ?CalcHash@Digest@@QAEXPAX0I@Z ; Digest::CalcHash
  00056	8b 74 24 1c	 mov	 esi, DWORD PTR _szHash$[esp+64]
  0005a	56		 push	 esi
  0005b	57		 push	 edi
  0005c	53		 push	 ebx
  0005d	e8 00 00 00 00	 call	 _memcpy
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
  00065	eb 14		 jmp	 SHORT $LN3@SetKey
$LN4@SetKey:

; 63   : 			szKey = szHash;
; 64   : 			memcpy((char*)_Kopad,(char*)_Kipad,szKey);
; 65   : 		} else {
; 66   : 			memcpy(_Kipad,Key,szKey);

  00067	e8 00 00 00 00	 call	 _memcpy

; 67   : 			memcpy(_Kopad,Key,szKey);

  0006c	8b 44 24 20	 mov	 eax, DWORD PTR _Key$GSCopy$[esp+76]
  00070	56		 push	 esi
  00071	50		 push	 eax
  00072	53		 push	 ebx
  00073	e8 00 00 00 00	 call	 _memcpy
  00078	83 c4 18	 add	 esp, 24			; 00000018H
$LN3@SetKey:

; 68   : 		}
; 69   : 		memset(&_Kipad[szKey],0x00,szBlock - szKey);

  0007b	8b 44 24 18	 mov	 eax, DWORD PTR _szBlock$[esp+64]
  0007f	2b c6		 sub	 eax, esi
  00081	50		 push	 eax
  00082	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  00085	6a 00		 push	 0
  00087	51		 push	 ecx
  00088	89 44 24 20	 mov	 DWORD PTR tv208[esp+76], eax
  0008c	e8 00 00 00 00	 call	 _memset

; 70   : 		memset(&_Kopad[szKey],0x00,szBlock - szKey);

  00091	8b 54 24 20	 mov	 edx, DWORD PTR tv208[esp+76]
  00095	52		 push	 edx
  00096	6a 00		 push	 0
  00098	03 f3		 add	 esi, ebx
  0009a	56		 push	 esi
  0009b	e8 00 00 00 00	 call	 _memset

; 71   : 	}
; 72   : 
; 73   : 	//------------
; 74   : 	//ipad ＆ opad で排他的論理和した鍵を作成
; 75   : 	{
; 76   : 		//変数定義
; 77   : 				unsigned	int		i	=	0;
; 78   : 		static	const	_mm_i32	_mm_36	= {0x36363636,0x36363636,0x36363636,0x36363636};
; 79   : 		static	const	_mm_i32	_mm_5C	= {0x5C5C5C5C,0x5C5C5C5C,0x5C5C5C5C,0x5C5C5C5C};
; 80   : 						__m128i _mm_temp;	
; 81   : 
; 82   : 		//排他的論理和を実施
; 83   : 		while((i + sizeof(__m128i)) < szBlock){

  000a0	8b 44 24 30	 mov	 eax, DWORD PTR _szBlock$[esp+88]
  000a4	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR ?_mm_36@?8??SetKey@HMAC@@QAEXPAXI@Z@4T_mm_i32@2@B
  000ac	66 0f 6f 0d 00
	00 00 00	 movdqa	 xmm1, XMMWORD PTR ?_mm_5C@?8??SetKey@HMAC@@QAEXPAXI@Z@4T_mm_i32@2@B
  000b4	83 c4 18	 add	 esp, 24			; 00000018H
  000b7	33 d2		 xor	 edx, edx
  000b9	83 f8 10	 cmp	 eax, 16			; 00000010H
  000bc	76 2b		 jbe	 SHORT $LN1@SetKey

; 68   : 		}
; 69   : 		memset(&_Kipad[szKey],0x00,szBlock - szKey);

  000be	8d 4a 10	 lea	 ecx, DWORD PTR [edx+16]
$LL2@SetKey:

; 84   : 			_mm_storeu_si128((__m128i*)_Kipad, _mm_xor_si128(_mm_loadu_si128((__m128i*)_Kipad) ,_mm_36.m128i));

  000c1	f3 0f 6f 17	 movdqu	 xmm2, XMMWORD PTR [edi]
  000c5	66 0f ef d0	 pxor	 xmm2, xmm0
  000c9	f3 0f 7f 17	 movdqu	 XMMWORD PTR [edi], xmm2

; 85   : 			_mm_storeu_si128((__m128i*)_Kopad, _mm_xor_si128(_mm_loadu_si128((__m128i*)_Kopad) ,_mm_5C.m128i));

  000cd	f3 0f 6f 13	 movdqu	 xmm2, XMMWORD PTR [ebx]
  000d1	66 0f ef d1	 pxor	 xmm2, xmm1
  000d5	f3 0f 7f 13	 movdqu	 XMMWORD PTR [ebx], xmm2

; 86   : 			_Kipad += sizeof(__m128i);
; 87   : 			_Kopad += sizeof(__m128i);
; 88   : 			i += sizeof(__m128i);

  000d9	83 c1 10	 add	 ecx, 16			; 00000010H
  000dc	83 c7 10	 add	 edi, 16			; 00000010H
  000df	83 c3 10	 add	 ebx, 16			; 00000010H
  000e2	83 c2 10	 add	 edx, 16			; 00000010H
  000e5	3b c8		 cmp	 ecx, eax
  000e7	72 d8		 jb	 SHORT $LL2@SetKey
$LN1@SetKey:

; 89   : 		}
; 90   : 		i = szBlock - i;
; 91   : 		_mm_temp	= _mm_xor_si128(_mm_loadu_si128((__m128i*)_Kipad) ,_mm_36.m128i);

  000e9	f3 0f 6f 0f	 movdqu	 xmm1, XMMWORD PTR [edi]
  000ed	2b c2		 sub	 eax, edx
  000ef	8b f0		 mov	 esi, eax

; 92   : 		memcpy(_Kipad, &_mm_temp, i);

  000f1	56		 push	 esi
  000f2	8d 44 24 24	 lea	 eax, DWORD PTR __mm_temp$39077[esp+68]
  000f6	50		 push	 eax
  000f7	66 0f ef c8	 pxor	 xmm1, xmm0
  000fb	57		 push	 edi
  000fc	66 0f 7f 4c 24
	2c		 movdqa	 XMMWORD PTR __mm_temp$39077[esp+76], xmm1
  00102	e8 00 00 00 00	 call	 _memcpy

; 93   : 		_mm_temp	= _mm_xor_si128(_mm_loadu_si128((__m128i*)_Kopad) ,_mm_5C.m128i);

  00107	f3 0f 6f 03	 movdqu	 xmm0, XMMWORD PTR [ebx]
  0010b	66 0f ef 05 00
	00 00 00	 pxor	 xmm0, XMMWORD PTR ?_mm_5C@?8??SetKey@HMAC@@QAEXPAXI@Z@4T_mm_i32@2@B

; 94   : 		memcpy(_Kopad, &_mm_temp, i);

  00113	56		 push	 esi
  00114	8d 4c 24 30	 lea	 ecx, DWORD PTR __mm_temp$39077[esp+80]
  00118	51		 push	 ecx
  00119	53		 push	 ebx
  0011a	66 0f 7f 44 24
	38		 movdqa	 XMMWORD PTR __mm_temp$39077[esp+88], xmm0
  00120	e8 00 00 00 00	 call	 _memcpy

; 95   : 	}
; 96   : }

  00125	8b 4c 24 54	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+88]
  00129	83 c4 18	 add	 esp, 24			; 00000018H
  0012c	5f		 pop	 edi
  0012d	5e		 pop	 esi
  0012e	5b		 pop	 ebx
  0012f	33 cc		 xor	 ecx, esp
  00131	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c2 04 00	 ret	 4
?SetKey@HMAC@@QAEXPAXI@Z ENDP				; HMAC::SetKey
PUBLIC	??1HMAC@@QAE@XZ					; HMAC::~HMAC
; Function compile flags: /Ogtpy
;	COMDAT ??1HMAC@@QAE@XZ
_TEXT	SEGMENT
??1HMAC@@QAE@XZ PROC					; HMAC::~HMAC, COMDAT
; _this$ = esi

; 30   : 	//計算用のバッファ開放
; 31   : 	delete	Kipad;

  00000	8b 86 e8 00 00
	00		 mov	 eax, DWORD PTR [esi+232]
  00006	57		 push	 edi
  00007	50		 push	 eax
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7HMAC@@6B@
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 32   : 	delete	Kopad;

  00013	8b 8e ec 00 00
	00		 mov	 ecx, DWORD PTR [esi+236]
  00019	83 c4 04	 add	 esp, 4
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4

; 33   : }

  00025	8d be a4 00 00
	00		 lea	 edi, DWORD PTR [esi+164]
  0002b	e8 00 00 00 00	 call	 ??1ASN1@@QAE@XZ		; ASN1::~ASN1
  00030	8d 7e 44	 lea	 edi, DWORD PTR [esi+68]
  00033	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7AlgorithmIdentifier@@6B@
  00039	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7ObjectIdentifier@@6B@
  0003f	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  00042	85 c0		 test	 eax, eax
  00044	74 09		 je	 SHORT $LN12@HMAC
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004c	83 c4 04	 add	 esp, 4
$LN12@HMAC:
  0004f	8b 57 44	 mov	 edx, DWORD PTR [edi+68]
  00052	52		 push	 edx
  00053	c7 47 50 00 00
	00 00		 mov	 DWORD PTR [edi+80], 0
  0005a	c7 47 54 00 00
	00 00		 mov	 DWORD PTR [edi+84], 0
  00061	c7 47 58 00 00
	00 00		 mov	 DWORD PTR [edi+88], 0
  00068	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0006d	83 c4 04	 add	 esp, 4
  00070	e8 00 00 00 00	 call	 ??1ASN1@@QAE@XZ		; ASN1::~ASN1
  00075	8b fe		 mov	 edi, esi
  00077	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Sequence@@6B@
  0007d	e8 00 00 00 00	 call	 ??1ASN1@@QAE@XZ		; ASN1::~ASN1
  00082	5f		 pop	 edi
  00083	c3		 ret	 0
??1HMAC@@QAE@XZ ENDP					; HMAC::~HMAC
PUBLIC	??0HMAC@@QAE@PAVDigest@@QBD@Z			; HMAC::HMAC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0HMAC@@QAE@PAVDigest@@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HMAC@@QAE@PAVDigest@@QBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0HMAC@@QAE@PAVDigest@@QBD@Z$1
__ehfuncinfo$??0HMAC@@QAE@PAVDigest@@QBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0HMAC@@QAE@PAVDigest@@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0HMAC@@QAE@PAVDigest@@QBD@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__cHash$ = 12						; size = 4
__strName$ = 16						; size = 4
??0HMAC@@QAE@PAVDigest@@QBD@Z PROC			; HMAC::HMAC, COMDAT

; 15   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0HMAC@@QAE@PAVDigest@@QBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	8b 44 24 24	 mov	 eax, DWORD PTR __strName$[esp+20]
  0002a	50		 push	 eax
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ??0AlgorithmIdentifier@@QAE@QBD@Z ; AlgorithmIdentifier::AlgorithmIdentifier
  00031	8b 4c 24 20	 mov	 ecx, DWORD PTR __cHash$[esp+20]
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0003a	8d 96 a4 00 00
	00		 lea	 edx, DWORD PTR [esi+164]
  00040	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+36], 0
  00048	52		 push	 edx
  00049	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7HMAC@@6B@
  0004f	89 8e a0 00 00
	00		 mov	 DWORD PTR [esi+160], ecx
  00055	e8 00 00 00 00	 call	 ??0ASN1@@QAE@QBD@Z	; ASN1::ASN1
  0005a	c6 44 24 14 01	 mov	 BYTE PTR __$EHRec$[esp+32], 1

; 16   : 	//計算用のバッファ確保
; 17   : 	Kipad		= new char[cHash->szBlock];

  0005f	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  00065	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00071	89 86 e8 00 00
	00		 mov	 DWORD PTR [esi+232], eax

; 18   : 	Kopad		= new char[cHash->szBlock + cHash->szHash];

  00077	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  0007d	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  00083	03 90 a4 00 00
	00		 add	 edx, DWORD PTR [eax+164]
  00089	83 c4 04	 add	 esp, 4
  0008c	52		 push	 edx
  0008d	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00092	89 86 ec 00 00
	00		 mov	 DWORD PTR [esi+236], eax
  00098	83 c4 04	 add	 esp, 4

; 19   : }

  0009b	8b c6		 mov	 eax, esi
  0009d	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5e		 pop	 esi
  000aa	83 c4 10	 add	 esp, 16			; 00000010H
  000ad	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0HMAC@@QAE@PAVDigest@@QBD@Z$0:
  00000	8b 75 04	 mov	 esi, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1AlgorithmIdentifier@@QAE@XZ ; AlgorithmIdentifier::~AlgorithmIdentifier
__unwindfunclet$??0HMAC@@QAE@PAVDigest@@QBD@Z$1:
  00008	8b 7d 04	 mov	 edi, DWORD PTR _this$[ebp-4]
  0000b	81 c7 a4 00 00
	00		 add	 edi, 164		; 000000a4H
  00011	e9 00 00 00 00	 jmp	 ??1ASN1@@QAE@XZ		; ASN1::~ASN1
__ehhandler$??0HMAC@@QAE@PAVDigest@@QBD@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  0001d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0HMAC@@QAE@PAVDigest@@QBD@Z
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0HMAC@@QAE@PAVDigest@@QBD@Z ENDP			; HMAC::HMAC
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\?n????j\My Project\CMS\CMS\ASN1\Algorithm\MT.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

;	COMDAT ?init@?1???0MT@@QAE@XZ@4PAKA
_DATA	SEGMENT
?init@?1???0MT@@QAE@XZ@4PAKA DD 0123H			; `MT::MT'::`2'::init
	DD	0234H
	DD	0345H
	DD	0456H
PUBLIC	?init_genrand@MT@@QAEXK@Z			; MT::init_genrand
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\mt.cpp
;	COMDAT ?init_genrand@MT@@QAEXK@Z
_TEXT	SEGMENT
?init_genrand@MT@@QAEXK@Z PROC				; MT::init_genrand, COMDAT
; _this$ = esi
; _s$ = eax

; 44   : 
; 45   : 	unsigned	int	iMT = 0;	//一旦レジスタに入れる。
; 46   : 
; 47   : 	mt[iMT++] = s & 0xffffffffUL;

  00000	89 06		 mov	 DWORD PTR [esi], eax
  00002	ba 01 00 00 00	 mov	 edx, 1
  00007	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  0000a	57		 push	 edi
  0000b	eb 03 8d 49 00	 npad	 5
$LL3@init_genra:

; 48   : 
; 49   : 	do{
; 50   : 	//	__asm	prefetchnta	mt[iMT+8]
; 51   : 		_mm_prefetch((const char *)&mt[iMT+4], 0);	//直近の配列を、L1キャッシュにフェッチしておく。

  00010	0f 18 41 f0	 prefetchnta BYTE PTR [ecx-16]

; 52   : 		_mm_prefetch((const char *)&mt[iMT+8], 1);	//そろそろのを、L2キャッシュにフェッチしておく。

  00014	0f 18 09	 prefetcht0 BYTE PTR [ecx]

; 53   : 
; 54   : 		//メモリを使わないで、レジスターだけで計算する。
; 55   : 		//変数"s"には、既に mt[iMT-1]が入っている。
; 56   : 		s = ((unsigned long)1812433253 * (s ^ (s >> 30)) + iMT) & 0xffffffffUL;

  00017	8b f8		 mov	 edi, eax
  00019	c1 ef 1e	 shr	 edi, 30			; 0000001eH
  0001c	33 f8		 xor	 edi, eax
  0001e	69 ff 65 89 07
	6c		 imul	 edi, 1812433253		; 6c078965H
  00024	03 fa		 add	 edi, edx
  00026	8b c7		 mov	 eax, edi

; 57   : 	
; 58   : 		//配列変数への書き込みは、この一回だけに。
; 59   : 		mt[iMT++] = s;

  00028	89 41 e0	 mov	 DWORD PTR [ecx-32], eax
  0002b	42		 inc	 edx
  0002c	83 c1 04	 add	 ecx, 4

; 60   : 
; 61   : 	} while (iMT < MT_N);

  0002f	81 fa 70 02 00
	00		 cmp	 edx, 624		; 00000270H
  00035	72 d9		 jb	 SHORT $LL3@init_genra

; 62   : 
; 63   : 	mti = iMT;

  00037	89 96 c0 09 00
	00		 mov	 DWORD PTR [esi+2496], edx
  0003d	5f		 pop	 edi

; 64   : }

  0003e	c3		 ret	 0
?init_genrand@MT@@QAEXK@Z ENDP				; MT::init_genrand
PUBLIC	?genrand_int32@MT@@QAEKXZ			; MT::genrand_int32
; Function compile flags: /Ogtpy
;	COMDAT ?genrand_int32@MT@@QAEKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?genrand_int32@MT@@QAEKXZ PROC				; MT::genrand_int32, COMDAT

; 142  : {

  00000	53		 push	 ebx
  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _this$[esp]

; 143  : 
; 144  : 	unsigned	int		iMT = mti;	//一旦レジスタに入れる。

  00005	8b 83 c0 09 00
	00		 mov	 eax, DWORD PTR [ebx+2496]

; 145  : 	unsigned	long	y;
; 146  : 	unsigned	long	n;
; 147  : 
; 148  : 	if(iMT >= MT_N){

  0000b	3d 70 02 00 00	 cmp	 eax, 624		; 00000270H
  00010	0f 82 dd 00 00
	00		 jb	 $LN8@genrand_in
  00016	55		 push	 ebp
  00017	56		 push	 esi
  00018	57		 push	 edi

; 149  : 
; 150  : 		if(iMT >= MT_N+1){		//初期化されていなかったら、初期化する。

  00019	3d 71 02 00 00	 cmp	 eax, 625		; 00000271H
  0001e	72 0c		 jb	 SHORT $LN7@genrand_in

; 151  : 			init_genrand(5489);

  00020	b8 71 15 00 00	 mov	 eax, 5489		; 00001571H
  00025	8b f3		 mov	 esi, ebx
  00027	e8 00 00 00 00	 call	 ?init_genrand@MT@@QAEXK@Z ; MT::init_genrand
$LN7@genrand_in:

; 152  : 		}
; 153  : 
; 154  : 		iMT		= 0;
; 155  : 		n		= mt[iMT];

  0002c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0002e	be e3 00 00 00	 mov	 esi, 227		; 000000e3H
  00033	8d bb 34 06 00
	00		 lea	 edi, DWORD PTR [ebx+1588]

; 156  : 		do{
; 157  : 			y = (n & UPPER_MASK);
; 158  : 			n = mt[iMT+1];			//次の値として使う。
; 159  : 			y |= (n & LOWER_MASK);
; 160  : 			mt[iMT] = (mt[iMT+MT_M]) ^ ((y)&1UL ? MATRIX_A : 0) ^ (y >> 1);
; 161  : 			iMT++;
; 162  : 		} while (iMT < MT_N-MT_M);

  00039	8b ee		 mov	 ebp, esi
  0003b	eb 03 8d 49 00	 npad	 5
$LL6@genrand_in:
  00040	8b c1		 mov	 eax, ecx
  00042	8b 8f d0 f9 ff
	ff		 mov	 ecx, DWORD PTR [edi-1584]
  00048	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0004d	8b d1		 mov	 edx, ecx
  0004f	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  00055	0b c2		 or	 eax, edx
  00057	8b d0		 mov	 edx, eax
  00059	80 e2 01	 and	 dl, 1
  0005c	0f b6 d2	 movzx	 edx, dl
  0005f	f7 da		 neg	 edx
  00061	1b d2		 sbb	 edx, edx
  00063	81 e2 df b0 08
	99		 and	 edx, -1727483681	; 9908b0dfH
  00069	d1 e8		 shr	 eax, 1
  0006b	33 d0		 xor	 edx, eax
  0006d	33 17		 xor	 edx, DWORD PTR [edi]
  0006f	83 c7 04	 add	 edi, 4
  00072	83 ee 01	 sub	 esi, 1
  00075	89 97 c8 f9 ff
	ff		 mov	 DWORD PTR [edi-1592], edx
  0007b	75 c3		 jne	 SHORT $LL6@genrand_in

; 163  : 
; 164  : 		do{
; 165  : 			y = (n & UPPER_MASK);

  0007d	8b fb		 mov	 edi, ebx
  0007f	90		 npad	 1
$LL3@genrand_in:
  00080	8b c1		 mov	 eax, ecx

; 166  : 			n = mt[iMT+1];			//次の値として使う。

  00082	8b 8f 90 03 00
	00		 mov	 ecx, DWORD PTR [edi+912]
  00088	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H

; 167  : 			y |= (n & LOWER_MASK);

  0008d	8b d1		 mov	 edx, ecx
  0008f	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  00095	0b c2		 or	 eax, edx

; 168  : 			mt[iMT] = (mt[iMT+MT_M-MT_N]) ^ ((y)&1UL ? MATRIX_A : 0) ^ (y >> 1);

  00097	8b d0		 mov	 edx, eax
  00099	80 e2 01	 and	 dl, 1
  0009c	0f b6 d2	 movzx	 edx, dl
  0009f	f7 da		 neg	 edx
  000a1	1b d2		 sbb	 edx, edx
  000a3	81 e2 df b0 08
	99		 and	 edx, -1727483681	; 9908b0dfH
  000a9	d1 e8		 shr	 eax, 1
  000ab	33 d0		 xor	 edx, eax
  000ad	33 17		 xor	 edx, DWORD PTR [edi]

; 169  : 			iMT++;

  000af	45		 inc	 ebp
  000b0	89 97 8c 03 00
	00		 mov	 DWORD PTR [edi+908], edx
  000b6	83 c7 04	 add	 edi, 4

; 170  : 		} while (iMT < MT_N-1);

  000b9	81 fd 6f 02 00
	00		 cmp	 ebp, 623		; 0000026fH
  000bf	72 bf		 jb	 SHORT $LL3@genrand_in

; 171  : 
; 172  : 			y = (n & UPPER_MASK) | (mt[0] & LOWER_MASK);

  000c1	8b 03		 mov	 eax, DWORD PTR [ebx]
  000c3	33 c1		 xor	 eax, ecx
  000c5	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  000ca	33 c1		 xor	 eax, ecx

; 173  : 			mt[MT_N-1] = (mt[MT_M-1]) ^ ((y)&1UL ? MATRIX_A : 0) ^ (y >> 1);

  000cc	8b c8		 mov	 ecx, eax
  000ce	80 e1 01	 and	 cl, 1
  000d1	0f b6 d1	 movzx	 edx, cl
  000d4	f7 da		 neg	 edx
  000d6	1b d2		 sbb	 edx, edx
  000d8	81 e2 df b0 08
	99		 and	 edx, -1727483681	; 9908b0dfH
  000de	33 93 30 06 00
	00		 xor	 edx, DWORD PTR [ebx+1584]
  000e4	d1 e8		 shr	 eax, 1
  000e6	5f		 pop	 edi
  000e7	33 d0		 xor	 edx, eax
  000e9	5e		 pop	 esi
  000ea	89 93 bc 09 00
	00		 mov	 DWORD PTR [ebx+2492], edx

; 174  : 			iMT = 0;

  000f0	33 c0		 xor	 eax, eax
  000f2	5d		 pop	 ebp
$LN8@genrand_in:

; 175  : 	}
; 176  : 
; 177  :     /* Tempering */
; 178  : 	y	= mt[iMT++];

  000f3	8b 0c 83	 mov	 ecx, DWORD PTR [ebx+eax*4]
  000f6	40		 inc	 eax

; 179  : 	mti	= iMT;

  000f7	89 83 c0 09 00
	00		 mov	 DWORD PTR [ebx+2496], eax

; 180  : 
; 181  : 	y ^= (y >> 11);

  000fd	8b c1		 mov	 eax, ecx
  000ff	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  00102	33 c8		 xor	 ecx, eax

; 182  :     y ^= (y << 7) & 0x9d2c5680UL;

  00104	8b d1		 mov	 edx, ecx
  00106	81 e2 ad 58 3a
	ff		 and	 edx, -12953427		; ff3a58adH
  0010c	c1 e2 07	 shl	 edx, 7
  0010f	33 ca		 xor	 ecx, edx

; 183  :     y ^= (y << 15) & 0xefc60000UL;

  00111	8b c1		 mov	 eax, ecx
  00113	25 8c df ff ff	 and	 eax, -8308		; ffffdf8cH
  00118	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  0011b	33 c8		 xor	 ecx, eax

; 184  :     y ^= (y >> 18);

  0011d	8b c1		 mov	 eax, ecx
  0011f	c1 e8 12	 shr	 eax, 18			; 00000012H
  00122	33 c1		 xor	 eax, ecx
  00124	5b		 pop	 ebx

; 185  : 
; 186  :     return y;
; 187  : }

  00125	c2 04 00	 ret	 4
?genrand_int32@MT@@QAEKXZ ENDP				; MT::genrand_int32
_TEXT	ENDS
PUBLIC	?init_by_array@MT@@QAEXQAKI@Z			; MT::init_by_array
; Function compile flags: /Ogtpy
;	COMDAT ?init_by_array@MT@@QAEXQAKI@Z
_TEXT	SEGMENT
_init_key$ = 8						; size = 4
?init_by_array@MT@@QAEXQAKI@Z PROC			; MT::init_by_array, COMDAT
; _this$ = eax

; 79   : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _init_key$[esp+4]
  00006	56		 push	 esi
  00007	8b f0		 mov	 esi, eax
  00009	57		 push	 edi

; 80   : 
; 81   : 	//この辺は、レジスター変数になってくれる。
; 82   : 	unsigned	int		iMT		= 0;	
; 83   : 	unsigned	int		iKey	= 0;	
; 84   : 	unsigned	int		k		= ((MT_N>key_length)? MT_N : key_length);
; 85   : 	unsigned	long	r;		//result
; 86   : 
; 87   : 	init_genrand(19650218UL);

  0000a	b8 aa d6 2b 01	 mov	 eax, 19650218		; 012bd6aaH
  0000f	33 ff		 xor	 edi, edi
  00011	bb 70 02 00 00	 mov	 ebx, 624		; 00000270H
  00016	e8 00 00 00 00	 call	 ?init_genrand@MT@@QAEXK@Z ; MT::init_genrand

; 88   : 
; 89   : 	r = mt[iMT++];		//ループ内でのメモリ読み込みを無くす為、ここで読んでおく。

  0001b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001d	b8 01 00 00 00	 mov	 eax, 1
$LL7@init_by_ar:

; 93   : 	//	__asm	prefetchnta	mt[iMT+8]
; 94   : 		_mm_prefetch((const char *)&mt[iMT+4], 0);	//直近の配列を、L1キャッシュにフェッチしておく。

  00022	0f 18 44 86 10	 prefetchnta BYTE PTR [esi+eax*4+16]

; 95   : 	//	_mm_prefetch((const char *)&mt[iMT+8], 1);	//そろそろのを、L2キャッシュにフェッチしておく。
; 96   : 
; 97   : 		//メモリを使わないで、レジスターだけで計算する。
; 98   : 		//変数"r"には、既に mt[iMT-1]が入っている。
; 99   : 		r = ((mt[iMT] ^ ((r ^ (r >> 30)) * (unsigned long)1664525)) + init_key[iKey] + iKey) & 0xffffffffUL;

  00027	8b d1		 mov	 edx, ecx
  00029	c1 ea 1e	 shr	 edx, 30			; 0000001eH
  0002c	33 d1		 xor	 edx, ecx
  0002e	69 d2 0d 66 19
	00		 imul	 edx, 1664525		; 0019660dH
  00034	33 14 86	 xor	 edx, DWORD PTR [esi+eax*4]

; 100  : 
; 101  : 		//配列変数への書き込みは、この一回だけに。
; 102  : 		mt[iMT++] = r;

  00037	40		 inc	 eax
  00038	03 54 bd 00	 add	 edx, DWORD PTR [ebp+edi*4]
  0003c	4b		 dec	 ebx
  0003d	03 d7		 add	 edx, edi
  0003f	8b ca		 mov	 ecx, edx
  00041	89 4c 86 fc	 mov	 DWORD PTR [esi+eax*4-4], ecx

; 103  : 
; 104  : 		if (iMT>=MT_N){

  00045	3d 70 02 00 00	 cmp	 eax, 624		; 00000270H
  0004a	72 05		 jb	 SHORT $LN5@init_by_ar

; 105  : 			iMT=1;

  0004c	b8 01 00 00 00	 mov	 eax, 1
$LN5@init_by_ar:

; 106  : //			mt[iMT++] = r;		//変数"r"に入っているので要らない
; 107  : 		}
; 108  : 		iKey++;

  00051	47		 inc	 edi

; 109  : 		if(iKey>=key_length){iKey=0;}

  00052	83 ff 04	 cmp	 edi, 4
  00055	72 02		 jb	 SHORT $LN17@init_by_ar
  00057	33 ff		 xor	 edi, edi
$LN17@init_by_ar:

; 90   : 						//メモリを何度もアクセスすると、メモリのキャッシュのR/Wが働く為。
; 91   : 
; 92   : 	while(k--){

  00059	85 db		 test	 ebx, ebx
  0005b	75 c5		 jne	 SHORT $LL7@init_by_ar

; 110  : 	};
; 111  : 
; 112  : 	k = MT_N-1;

  0005d	ba 6f 02 00 00	 mov	 edx, 623		; 0000026fH
$LL3@init_by_ar:

; 114  : 	//	__asm	prefetchnta	mt[iMT+8]
; 115  : 		_mm_prefetch((const char *)&mt[iMT+4], 0);	//直近の配列を、L1キャッシュにフェッチしておく。

  00062	0f 18 44 86 10	 prefetchnta BYTE PTR [esi+eax*4+16]

; 116  : 	//	_mm_prefetch((const char *)&mt[iMT+8], 1);	//そろそろのを、L2キャッシュにフェッチしておく。
; 117  : 
; 118  : 		//メモリを使わないで、レジスターだけで計算する。
; 119  : 		//変数"r"には、既に mt[iMT-1]が入っている。
; 120  : 		r = ((mt[iMT] ^ ((r ^ (r >> 30)) * (unsigned long)1566083941)) - iMT) & 0xffffffffUL;

  00067	8b f9		 mov	 edi, ecx
  00069	c1 ef 1e	 shr	 edi, 30			; 0000001eH
  0006c	33 f9		 xor	 edi, ecx
  0006e	69 ff 65 8b 58
	5d		 imul	 edi, 1566083941		; 5d588b65H
  00074	33 3c 86	 xor	 edi, DWORD PTR [esi+eax*4]
  00077	4a		 dec	 edx
  00078	2b f8		 sub	 edi, eax
  0007a	8b cf		 mov	 ecx, edi

; 121  : 
; 122  : 		mt[iMT++] = r;		//配列への書き込み。

  0007c	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx
  0007f	40		 inc	 eax

; 123  :         if (iMT>=MT_N){

  00080	3d 70 02 00 00	 cmp	 eax, 624		; 00000270H
  00085	72 05		 jb	 SHORT $LN1@init_by_ar

; 124  : 			iMT=1;

  00087	b8 01 00 00 00	 mov	 eax, 1
$LN1@init_by_ar:

; 113  : 	while(k--){

  0008c	85 d2		 test	 edx, edx
  0008e	75 d2		 jne	 SHORT $LL3@init_by_ar
  00090	5f		 pop	 edi

; 125  : //			mt[iMT++] = r;		//変数"r"に入っているので要らない
; 126  : 		}
; 127  : 	};
; 128  : 
; 129  : 	mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */ 

  00091	c7 06 00 00 00
	80		 mov	 DWORD PTR [esi], -2147483648 ; 80000000H
  00097	5e		 pop	 esi
  00098	5d		 pop	 ebp
  00099	5b		 pop	 ebx

; 130  : 
; 131  : }

  0009a	c2 04 00	 ret	 4
?init_by_array@MT@@QAEXQAKI@Z ENDP			; MT::init_by_array
_TEXT	ENDS
PUBLIC	??0MT@@QAE@QAKI@Z				; MT::MT
; Function compile flags: /Ogtpy
;	COMDAT ??0MT@@QAE@QAKI@Z
_TEXT	SEGMENT
??0MT@@QAE@QAKI@Z PROC					; MT::MT, COMDAT
; _this$ = esi
; _init_key$ = eax

; 32   : 	init_by_array(init_key, key_length);

  00000	50		 push	 eax
  00001	8b c6		 mov	 eax, esi
  00003	c7 86 c0 09 00
	00 71 02 00 00	 mov	 DWORD PTR [esi+2496], 625 ; 00000271H
  0000d	e8 00 00 00 00	 call	 ?init_by_array@MT@@QAEXQAKI@Z ; MT::init_by_array

; 33   : }

  00012	8b c6		 mov	 eax, esi
  00014	c3		 ret	 0
??0MT@@QAE@QAKI@Z ENDP					; MT::MT
END

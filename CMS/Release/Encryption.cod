; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\?n????j\My Project\CMS\CMS\ASN1\Algorithm\Encryption.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4Encryption@@6B@				; Encryption::`RTTI Complete Object Locator'
PUBLIC	?decipher_last@Encryption@@UAEHPAXI@Z		; Encryption::decipher_last
PUBLIC	?encipher_last@Encryption@@UAEHPAXI@Z		; Encryption::encipher_last
PUBLIC	?decipher@Encryption@@UAEXPAXI@Z		; Encryption::decipher
PUBLIC	?encipher@Encryption@@UAEXPAXI@Z		; Encryption::encipher
PUBLIC	?Set_Key@Encryption@@UAEXPAX@Z			; Encryption::Set_Key
PUBLIC	?Clear_Key@Encryption@@UAEXXZ			; Encryption::Clear_Key
PUBLIC	?encrypt_ecb@Encryption@@UAEXPAX@Z		; Encryption::encrypt_ecb
PUBLIC	?decrypt_ecb@Encryption@@UAEXPAX@Z		; Encryption::decrypt_ecb
PUBLIC	??_7Encryption@@6B@				; Encryption::`vftable'
;	COMDAT ??_7Encryption@@6B@
CONST	SEGMENT
??_7Encryption@@6B@ DD FLAT:??_R4Encryption@@6B@	; Encryption::`vftable'
	DD	FLAT:?encodeBER@Sequence@@UAEXXZ
	DD	FLAT:?Get_BERcode@ASN1@@UAEPBDXZ
	DD	FLAT:?Get_BERsize@ASN1@@UAEIXZ
	DD	FLAT:?Set_Key@Encryption@@UAEXPAX@Z
	DD	FLAT:?Clear_Key@Encryption@@UAEXXZ
	DD	FLAT:?init@Encryption@@UAEXXZ
	DD	FLAT:?encrypt@Encryption@@UAEXPAX@Z
	DD	FLAT:?decrypt@Encryption@@UAEXPAX@Z
	DD	FLAT:?encrypt_ecb@Encryption@@UAEXPAX@Z
	DD	FLAT:?decrypt_ecb@Encryption@@UAEXPAX@Z
	DD	FLAT:?SetIV@Encryption@@UAEXPAX@Z
	DD	FLAT:?encipher@Encryption@@UAEXPAXI@Z
	DD	FLAT:?decipher@Encryption@@UAEXPAXI@Z
	DD	FLAT:?encipher_last@Encryption@@UAEHPAXI@Z
	DD	FLAT:?decipher_last@Encryption@@UAEHPAXI@Z
	DD	FLAT:?KeyWrap@Encryption@@UAEHPAXI@Z
	DD	FLAT:?KeyUnWrap@Encryption@@UAEHPAXI@Z
	DD	FLAT:?GetKey@Encryption@@UAEPAXXZ
	DD	FLAT:?GetEncrptedKey@Encryption@@UAEPAXXZ
CONST	ENDS
;	COMDAT ??_R4Encryption@@6B@
rdata$r	SEGMENT
??_R4Encryption@@6B@ DD 00H				; Encryption::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVEncryption@@@8
	DD	FLAT:??_R3Encryption@@8
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\encryption.h
;	COMDAT ?Clear_Key@Encryption@@UAEXXZ
_TEXT	SEGMENT
?Clear_Key@Encryption@@UAEXXZ PROC			; Encryption::Clear_Key, COMDAT
; _this$ = ecx

; 42   : 	virtual	void	Clear_Key(){};				//暗号鍵 Zero化

  00000	c3		 ret	 0
?Clear_Key@Encryption@@UAEXXZ ENDP			; Encryption::Clear_Key
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?encrypt_ecb@Encryption@@UAEXPAX@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?encrypt_ecb@Encryption@@UAEXPAX@Z PROC			; Encryption::encrypt_ecb, COMDAT
; _this$ = ecx

; 46   : 	virtual	void	encrypt_ecb(void *data){};	//暗号 ECB Mode

  00000	c2 04 00	 ret	 4
?encrypt_ecb@Encryption@@UAEXPAX@Z ENDP			; Encryption::encrypt_ecb
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?decrypt_ecb@Encryption@@UAEXPAX@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?decrypt_ecb@Encryption@@UAEXPAX@Z PROC			; Encryption::decrypt_ecb, COMDAT
; _this$ = ecx

; 47   : 	virtual	void	decrypt_ecb(void *data){};	//復号 ECB Mode

  00000	c2 04 00	 ret	 4
?decrypt_ecb@Encryption@@UAEXPAX@Z ENDP			; Encryption::decrypt_ecb
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Set_Key@Encryption@@UAEXPAX@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
?Set_Key@Encryption@@UAEXPAX@Z PROC			; Encryption::Set_Key, COMDAT
; _this$ = ecx

; 41   : 	virtual	void	Set_Key(void *key){};		//暗号鍵 設定

  00000	c2 04 00	 ret	 4
?Set_Key@Encryption@@UAEXPAX@Z ENDP			; Encryption::Set_Key
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\encryption.cpp
_TEXT	ENDS
;	COMDAT ?decipher_last@Encryption@@UAEHPAXI@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
_iSize$ = 12						; size = 4
?decipher_last@Encryption@@UAEHPAXI@Z PROC		; Encryption::decipher_last, COMDAT
; _this$ = ecx

; 123  : {

  00000	53		 push	 ebx

; 124  : 	unsigned	char*	cData		= (unsigned	char*)data;
; 125  : 	unsigned	int		n			= 0;
; 126  : 
; 127  : 	unsigned	char	cPadData;
; 128  : 	unsigned	char	cntPadData;
; 129  : 
; 130  : 	//復号
; 131  : 	while(iSize > 0){

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _data$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 10	 mov	 ebp, DWORD PTR _iSize$[esp+4]
  0000a	56		 push	 esi
  0000b	33 f6		 xor	 esi, esi
  0000d	57		 push	 edi
  0000e	8b f9		 mov	 edi, ecx
  00010	85 ed		 test	 ebp, ebp
  00012	76 19		 jbe	 SHORT $LN5@decipher_l
$LL6@decipher_l:

; 132  : 		decrypt(&cData[n]);

  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00019	8d 0c 1e	 lea	 ecx, DWORD PTR [esi+ebx]
  0001c	51		 push	 ecx
  0001d	8b cf		 mov	 ecx, edi
  0001f	ff d2		 call	 edx

; 133  : 		n		+= szBlock;

  00021	8b 87 a0 00 00
	00		 mov	 eax, DWORD PTR [edi+160]
  00027	03 f0		 add	 esi, eax

; 134  : 		iSize	-= szBlock;

  00029	2b e8		 sub	 ebp, eax
  0002b	75 e7		 jne	 SHORT $LL6@decipher_l
$LN5@decipher_l:

; 135  : 	}
; 136  : 
; 137  : 	//最後のBlockは、Paddingを含む。
; 138  : 	n--;

  0002d	4e		 dec	 esi

; 139  : 	cPadData	= cData[n];

  0002e	8a 0c 1e	 mov	 cl, BYTE PTR [esi+ebx]
  00031	5f		 pop	 edi
  00032	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  00035	5e		 pop	 esi
  00036	5d		 pop	 ebp

; 140  : 	cntPadData	= cPadData;

  00037	8a d1		 mov	 dl, cl
  00039	5b		 pop	 ebx
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL4@decipher_l:

; 141  : 
; 142  : 	//Paddingのチェック
; 143  : 	do{
; 144  : 		if(cData[n] != cPadData){	return(-1);	}

  00040	38 08		 cmp	 BYTE PTR [eax], cl
  00042	75 0c		 jne	 SHORT $LN11@decipher_l

; 145  : 		n--;

  00044	48		 dec	 eax

; 146  : 		cntPadData--;

  00045	80 c2 ff	 add	 dl, 255			; 000000ffH

; 147  : 	} while(cntPadData>0);

  00048	75 f6		 jne	 SHORT $LL4@decipher_l

; 148  : 	return(cPadData);

  0004a	0f b6 c1	 movzx	 eax, cl

; 149  : }

  0004d	c2 08 00	 ret	 8
$LN11@decipher_l:

; 141  : 
; 142  : 	//Paddingのチェック
; 143  : 	do{
; 144  : 		if(cData[n] != cPadData){	return(-1);	}

  00050	83 c8 ff	 or	 eax, -1

; 149  : }

  00053	c2 08 00	 ret	 8
?decipher_last@Encryption@@UAEHPAXI@Z ENDP		; Encryption::decipher_last
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?decipher@Encryption@@UAEXPAXI@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
_iSize$ = 12						; size = 4
?decipher@Encryption@@UAEXPAXI@Z PROC			; Encryption::decipher, COMDAT
; _this$ = ecx

; 103  : {

  00000	53		 push	 ebx

; 104  : 	unsigned	char*	cData		= (unsigned	char*)data;
; 105  : 	unsigned	int		n			= 0;
; 106  : 
; 107  : 	while(n < iSize){

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _iSize$[esp]
  00005	56		 push	 esi
  00006	33 f6		 xor	 esi, esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	85 db		 test	 ebx, ebx
  0000d	76 1d		 jbe	 SHORT $LN1@decipher
  0000f	55		 push	 ebp
  00010	8b 6c 24 14	 mov	 ebp, DWORD PTR _data$[esp+12]
$LL2@decipher:

; 108  : 		decrypt(&cData[n]);

  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00019	8d 0c 2e	 lea	 ecx, DWORD PTR [esi+ebp]
  0001c	51		 push	 ecx
  0001d	8b cf		 mov	 ecx, edi
  0001f	ff d2		 call	 edx

; 109  : 		n	+=	szBlock;

  00021	03 b7 a0 00 00
	00		 add	 esi, DWORD PTR [edi+160]
  00027	3b f3		 cmp	 esi, ebx
  00029	72 e9		 jb	 SHORT $LL2@decipher
  0002b	5d		 pop	 ebp
$LN1@decipher:
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx

; 110  : 	}
; 111  : }

  0002f	c2 08 00	 ret	 8
?decipher@Encryption@@UAEXPAXI@Z ENDP			; Encryption::decipher
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?encipher_last@Encryption@@UAEHPAXI@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
_iSize$ = 12						; size = 4
?encipher_last@Encryption@@UAEHPAXI@Z PROC		; Encryption::encipher_last, COMDAT
; _this$ = ecx

; 58   : {

  00000	53		 push	 ebx

; 59   : 	unsigned	char*	cData		= (unsigned	char*)data;
; 60   : 	unsigned	int		n			= 0;
; 61   : 
; 62   : 	unsigned	int		ptPadding;
; 63   : 	unsigned	char	cPadData;
; 64   : 	unsigned	char	cntPadData;
; 65   : 
; 66   : 	//暗号（最終ブロック直前まで）
; 67   : 	while(iSize >= szBlock){

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _iSize$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 0c	 mov	 ebp, DWORD PTR _data$[esp+4]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f1		 mov	 esi, ecx
  0000e	33 ff		 xor	 edi, edi
  00010	3b 9e a0 00 00
	00		 cmp	 ebx, DWORD PTR [esi+160]
  00016	72 1f		 jb	 SHORT $LN5@encipher_l
$LL6@encipher_l:

; 68   : 		encrypt(&cData[n]);

  00018	8b 06		 mov	 eax, DWORD PTR [esi]
  0001a	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0001d	8d 0c 2f	 lea	 ecx, DWORD PTR [edi+ebp]
  00020	51		 push	 ecx
  00021	8b ce		 mov	 ecx, esi
  00023	ff d2		 call	 edx

; 69   : 		n		+= szBlock;

  00025	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]

; 70   : 		iSize	-= szBlock;

  0002b	2b d8		 sub	 ebx, eax
  0002d	03 f8		 add	 edi, eax
  0002f	3b d8		 cmp	 ebx, eax
  00031	73 e5		 jae	 SHORT $LL6@encipher_l
  00033	89 5c 24 18	 mov	 DWORD PTR _iSize$[esp+12], ebx
$LN5@encipher_l:

; 71   : 	}
; 72   : 
; 73   : 	//Padding処理(PKCS#7)を実施
; 74   : 	ptPadding	= n + ((n%szBlock)?-1:szBlock-1);

  00037	8b 8e a0 00 00
	00		 mov	 ecx, DWORD PTR [esi+160]
  0003d	33 d2		 xor	 edx, edx
  0003f	8b c7		 mov	 eax, edi
  00041	f7 f1		 div	 ecx
  00043	85 d2		 test	 edx, edx
  00045	74 05		 je	 SHORT $LN9@encipher_l
  00047	83 c8 ff	 or	 eax, -1
  0004a	eb 03		 jmp	 SHORT $LN10@encipher_l
$LN9@encipher_l:
  0004c	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
$LN10@encipher_l:

; 75   : 	cPadData	= szBlock - iSize;

  0004f	8b 54 24 18	 mov	 edx, DWORD PTR _iSize$[esp+12]
  00053	8a d9		 mov	 bl, cl
  00055	2a da		 sub	 bl, dl
  00057	03 c7		 add	 eax, edi

; 76   : 	cntPadData	= cPadData;

  00059	8a cb		 mov	 cl, bl
  0005b	03 c5		 add	 eax, ebp
  0005d	8d 49 00	 npad	 3
$LL4@encipher_l:

; 77   : 	do{
; 78   : 		cData[ptPadding] = cPadData;

  00060	88 18		 mov	 BYTE PTR [eax], bl

; 79   : 		ptPadding--;

  00062	48		 dec	 eax

; 80   : 		cntPadData--;

  00063	80 c1 ff	 add	 cl, 255			; 000000ffH

; 81   : 	} while(cntPadData>0);

  00066	75 f8		 jne	 SHORT $LL4@encipher_l

; 82   : 
; 83   : 	//暗号（最終）
; 84   : 	if(iSize == szBlock){

  00068	3b 96 a0 00 00
	00		 cmp	 edx, DWORD PTR [esi+160]
  0006e	75 13		 jne	 SHORT $LN1@encipher_l

; 85   : 		encrypt(&cData[n]);

  00070	8b 06		 mov	 eax, DWORD PTR [esi]
  00072	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00075	8d 0c 2f	 lea	 ecx, DWORD PTR [edi+ebp]
  00078	51		 push	 ecx
  00079	8b ce		 mov	 ecx, esi
  0007b	ff d2		 call	 edx

; 86   : 		n += szBlock;

  0007d	03 be a0 00 00
	00		 add	 edi, DWORD PTR [esi+160]
$LN1@encipher_l:

; 87   : 	}
; 88   : 	encrypt(&cData[n]);

  00083	8b 06		 mov	 eax, DWORD PTR [esi]
  00085	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00088	03 fd		 add	 edi, ebp
  0008a	57		 push	 edi
  0008b	8b ce		 mov	 ecx, esi
  0008d	ff d2		 call	 edx
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5d		 pop	 ebp

; 89   : 	n += szBlock;
; 90   : 
; 91   : 	return(cPadData);

  00092	0f b6 c3	 movzx	 eax, bl
  00095	5b		 pop	 ebx

; 92   : }

  00096	c2 08 00	 ret	 8
?encipher_last@Encryption@@UAEHPAXI@Z ENDP		; Encryption::encipher_last
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?encipher@Encryption@@UAEXPAXI@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
_iSize$ = 12						; size = 4
?encipher@Encryption@@UAEXPAXI@Z PROC			; Encryption::encipher, COMDAT
; _this$ = ecx

; 39   : {

  00000	53		 push	 ebx

; 40   : 	unsigned	char*	cData		= (unsigned	char*)data;
; 41   : 	unsigned	int		n			= 0;
; 42   : 
; 43   : 	while(n < iSize){

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _iSize$[esp]
  00005	56		 push	 esi
  00006	33 f6		 xor	 esi, esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	85 db		 test	 ebx, ebx
  0000d	76 1d		 jbe	 SHORT $LN1@encipher
  0000f	55		 push	 ebp
  00010	8b 6c 24 14	 mov	 ebp, DWORD PTR _data$[esp+12]
$LL2@encipher:

; 44   : 		encrypt(&cData[n]);

  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00019	8d 0c 2e	 lea	 ecx, DWORD PTR [esi+ebp]
  0001c	51		 push	 ecx
  0001d	8b cf		 mov	 ecx, edi
  0001f	ff d2		 call	 edx

; 45   : 		n	+=	szBlock;

  00021	03 b7 a0 00 00
	00		 add	 esi, DWORD PTR [edi+160]
  00027	3b f3		 cmp	 esi, ebx
  00029	72 e9		 jb	 SHORT $LL2@encipher
  0002b	5d		 pop	 ebp
$LN1@encipher:
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx

; 46   : 	}
; 47   : }

  0002f	c2 08 00	 ret	 8
?encipher@Encryption@@UAEXPAXI@Z ENDP			; Encryption::encipher
PUBLIC	??1Encryption@@QAE@XZ				; Encryption::~Encryption
; Function compile flags: /Ogtpy
;	COMDAT ??1Encryption@@QAE@XZ
_TEXT	SEGMENT
??1Encryption@@QAE@XZ PROC				; Encryption::~Encryption, COMDAT
; _this$ = esi

; 25   : {

  00000	57		 push	 edi

; 26   : 	//クラスを解放する前に、鍵スケジュールを０クリアする。
; 27   : 	Clear_Key();
; 28   : }

  00001	8d 7e 44	 lea	 edi, DWORD PTR [esi+68]
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7AlgorithmIdentifier@@6B@
  0000a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7ObjectIdentifier@@6B@
  00010	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  00013	85 c0		 test	 eax, eax
  00015	74 09		 je	 SHORT $LN14@Encryption@3
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN14@Encryption@3:
  00020	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  00023	50		 push	 eax
  00024	c7 47 50 00 00
	00 00		 mov	 DWORD PTR [edi+80], 0
  0002b	c7 47 54 00 00
	00 00		 mov	 DWORD PTR [edi+84], 0
  00032	c7 47 58 00 00
	00 00		 mov	 DWORD PTR [edi+88], 0
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 04	 add	 esp, 4
  00041	e8 00 00 00 00	 call	 ??1ASN1@@QAE@XZ		; ASN1::~ASN1
  00046	8b fe		 mov	 edi, esi
  00048	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Sequence@@6B@
  0004e	e8 00 00 00 00	 call	 ??1ASN1@@QAE@XZ		; ASN1::~ASN1
  00053	5f		 pop	 edi
  00054	c3		 ret	 0
??1Encryption@@QAE@XZ ENDP				; Encryption::~Encryption
PUBLIC	??0Encryption@@QAE@QBD@Z			; Encryption::Encryption
; Function compile flags: /Ogtpy
;	COMDAT ??0Encryption@@QAE@QBD@Z
_TEXT	SEGMENT
??0Encryption@@QAE@QBD@Z PROC				; Encryption::Encryption, COMDAT
; _this$ = esi
; __strName$ = eax

; 14   : {

  00000	51		 push	 ecx
  00001	50		 push	 eax
  00002	56		 push	 esi
  00003	e8 00 00 00 00	 call	 ??0AlgorithmIdentifier@@QAE@QBD@Z ; AlgorithmIdentifier::AlgorithmIdentifier
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Encryption@@6B@

; 15   : }

  0000e	8b c6		 mov	 eax, esi
  00010	59		 pop	 ecx
  00011	c3		 ret	 0
??0Encryption@@QAE@QBD@Z ENDP				; Encryption::Encryption
END

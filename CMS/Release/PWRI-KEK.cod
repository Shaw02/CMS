; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\?n????j\My Project\CMS\CMS\ASN1\Algorithm\PWRI-KEK.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?KeyUnWrap@PWRI_KEK@@UAEHPAXI@Z			; PWRI_KEK::KeyUnWrap
PUBLIC	?KeyWrap@PWRI_KEK@@UAEHPAXI@Z			; PWRI_KEK::KeyWrap
PUBLIC	?Clear_Key@PWRI_KEK@@UAEXXZ			; PWRI_KEK::Clear_Key
PUBLIC	?Set_Key@PWRI_KEK@@UAEXPAX@Z			; PWRI_KEK::Set_Key
PUBLIC	??_R4PWRI_KEK@@6B@				; PWRI_KEK::`RTTI Complete Object Locator'
PUBLIC	??_R3PWRI_KEK@@8				; PWRI_KEK::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2PWRI_KEK@@8				; PWRI_KEK::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@PWRI_KEK@@8			; PWRI_KEK::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVPWRI_KEK@@@8				; PWRI_KEK `RTTI Type Descriptor'
PUBLIC	?GetKey@PWRI_KEK@@UAEPAXXZ			; PWRI_KEK::GetKey
PUBLIC	?GetEncrptedKey@PWRI_KEK@@UAEPAXXZ		; PWRI_KEK::GetEncrptedKey
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?oid@PWRI_KEK@@2PAIA				; PWRI_KEK::oid
PUBLIC	??_7PWRI_KEK@@6B@				; PWRI_KEK::`vftable'
;	COMDAT ??_7PWRI_KEK@@6B@
CONST	SEGMENT
??_7PWRI_KEK@@6B@ DD FLAT:??_R4PWRI_KEK@@6B@		; PWRI_KEK::`vftable'
	DD	FLAT:?encodeBER@Sequence@@UAEXXZ
	DD	FLAT:?Get_BERcode@ASN1@@UAEPBDXZ
	DD	FLAT:?Get_BERsize@ASN1@@UAEIXZ
	DD	FLAT:?Set_Key@PWRI_KEK@@UAEXPAX@Z
	DD	FLAT:?Clear_Key@PWRI_KEK@@UAEXXZ
	DD	FLAT:?init@Encryption@@UAEXXZ
	DD	FLAT:?encrypt@Encryption@@UAEXPAX@Z
	DD	FLAT:?decrypt@Encryption@@UAEXPAX@Z
	DD	FLAT:?encrypt_ecb@Encryption@@UAEXPAX@Z
	DD	FLAT:?decrypt_ecb@Encryption@@UAEXPAX@Z
	DD	FLAT:?SetIV@Encryption@@UAEXPAX@Z
	DD	FLAT:?encipher@Encryption@@UAEXPAXI@Z
	DD	FLAT:?decipher@Encryption@@UAEXPAXI@Z
	DD	FLAT:?encipher_last@Encryption@@UAEHPAXI@Z
	DD	FLAT:?decipher_last@Encryption@@UAEHPAXI@Z
	DD	FLAT:?KeyWrap@PWRI_KEK@@UAEHPAXI@Z
	DD	FLAT:?KeyUnWrap@PWRI_KEK@@UAEHPAXI@Z
	DD	FLAT:?GetKey@PWRI_KEK@@UAEPAXXZ
	DD	FLAT:?GetEncrptedKey@PWRI_KEK@@UAEPAXXZ
CONST	ENDS
;	COMDAT ??_R4PWRI_KEK@@6B@
rdata$r	SEGMENT
??_R4PWRI_KEK@@6B@ DD 00H				; PWRI_KEK::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVPWRI_KEK@@@8
	DD	FLAT:??_R3PWRI_KEK@@8
rdata$r	ENDS
;	COMDAT ??_R3PWRI_KEK@@8
rdata$r	SEGMENT
??_R3PWRI_KEK@@8 DD 00H					; PWRI_KEK::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2PWRI_KEK@@8
rdata$r	ENDS
;	COMDAT ??_R2PWRI_KEK@@8
rdata$r	SEGMENT
??_R2PWRI_KEK@@8 DD FLAT:??_R1A@?0A@EA@PWRI_KEK@@8	; PWRI_KEK::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Encryption@@8
	DD	FLAT:??_R1A@?0A@EA@AlgorithmIdentifier@@8
	DD	FLAT:??_R1A@?0A@EA@Sequence@@8
	DD	FLAT:??_R1A@?0A@EA@ASN1@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@PWRI_KEK@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@PWRI_KEK@@8 DD FLAT:??_R0?AVPWRI_KEK@@@8	; PWRI_KEK::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3PWRI_KEK@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVPWRI_KEK@@@8
_DATA	SEGMENT
??_R0?AVPWRI_KEK@@@8 DD FLAT:??_7type_info@@6B@		; PWRI_KEK `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVPWRI_KEK@@', 00H
?oid@PWRI_KEK@@2PAIA DD 01H				; PWRI_KEK::oid
	DD	02H
	DD	0348H
	DD	01bb8dH
	DD	01H
	DD	09H
	DD	010H
	DD	03H
	DD	09H
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\pwri-kek.cpp
;	COMDAT ?Set_Key@PWRI_KEK@@UAEXPAX@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
?Set_Key@PWRI_KEK@@UAEXPAX@Z PROC			; PWRI_KEK::Set_Key, COMDAT
; _this$ = ecx

; 73   : 	keyWrapAlgorithm->Set_Key(key);

  00000	8b 89 a8 00 00
	00		 mov	 ecx, DWORD PTR [ecx+168]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0000b	ff e0		 jmp	 eax
?Set_Key@PWRI_KEK@@UAEXPAX@Z ENDP			; PWRI_KEK::Set_Key
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\pwri-kek.h
;	COMDAT ?GetKey@PWRI_KEK@@UAEPAXXZ
_TEXT	SEGMENT
?GetKey@PWRI_KEK@@UAEPAXXZ PROC				; PWRI_KEK::GetKey, COMDAT
; _this$ = ecx

; 69   : 			void*	GetKey(){return((void *)strKey.c_str());};

  00000	83 b9 c4 00 00
	00 10		 cmp	 DWORD PTR [ecx+196], 16	; 00000010H
  00007	72 07		 jb	 SHORT $LN7@GetKey
  00009	8b 81 b0 00 00
	00		 mov	 eax, DWORD PTR [ecx+176]
  0000f	c3		 ret	 0
$LN7@GetKey:
  00010	8d 81 b0 00 00
	00		 lea	 eax, DWORD PTR [ecx+176]
  00016	c3		 ret	 0
?GetKey@PWRI_KEK@@UAEPAXXZ ENDP				; PWRI_KEK::GetKey
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetEncrptedKey@PWRI_KEK@@UAEPAXXZ
_TEXT	SEGMENT
?GetEncrptedKey@PWRI_KEK@@UAEPAXXZ PROC			; PWRI_KEK::GetEncrptedKey, COMDAT
; _this$ = ecx

; 70   : 			void*	GetEncrptedKey(){return((void *)strEncrptedKey.c_str());};

  00000	83 b9 e0 00 00
	00 10		 cmp	 DWORD PTR [ecx+224], 16	; 00000010H
  00007	72 07		 jb	 SHORT $LN7@GetEncrpte
  00009	8b 81 cc 00 00
	00		 mov	 eax, DWORD PTR [ecx+204]
  0000f	c3		 ret	 0
$LN7@GetEncrpte:
  00010	8d 81 cc 00 00
	00		 lea	 eax, DWORD PTR [ecx+204]
  00016	c3		 ret	 0
?GetEncrptedKey@PWRI_KEK@@UAEPAXXZ ENDP			; PWRI_KEK::GetEncrptedKey
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\pwri-kek.cpp
_TEXT	ENDS
;	COMDAT ?Clear_Key@PWRI_KEK@@UAEXXZ
_TEXT	SEGMENT
?Clear_Key@PWRI_KEK@@UAEXXZ PROC			; PWRI_KEK::Clear_Key, COMDAT
; _this$ = ecx

; 45   : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 46   : 	unsigned	i;
; 47   : 
; 48   : 	keyWrapAlgorithm->Clear_Key();

  00004	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0000f	57		 push	 edi
  00010	ff d2		 call	 edx

; 49   : 
; 50   : 	i = strKey.size();

  00012	8b be c0 00 00
	00		 mov	 edi, DWORD PTR [esi+192]

; 51   : 	while(i > 0){

  00018	bb 10 00 00 00	 mov	 ebx, 16			; 00000010H
  0001d	85 ff		 test	 edi, edi
  0001f	76 2c		 jbe	 SHORT $LN3@Clear_Key@2
$LL4@Clear_Key@2:

; 52   : 		i--;

  00021	4f		 dec	 edi

; 53   : 		strKey[i] = 0;

  00022	3b be c0 00 00
	00		 cmp	 edi, DWORD PTR [esi+192]
  00028	76 05		 jbe	 SHORT $LN9@Clear_Key@2
  0002a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN9@Clear_Key@2:
  0002f	39 9e c4 00 00
	00		 cmp	 DWORD PTR [esi+196], ebx
  00035	72 08		 jb	 SHORT $LN14@Clear_Key@2
  00037	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  0003d	eb 06		 jmp	 SHORT $LN15@Clear_Key@2
$LN14@Clear_Key@2:
  0003f	8d 86 b0 00 00
	00		 lea	 eax, DWORD PTR [esi+176]
$LN15@Clear_Key@2:
  00045	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  00049	85 ff		 test	 edi, edi
  0004b	77 d4		 ja	 SHORT $LL4@Clear_Key@2
$LN3@Clear_Key@2:

; 54   : 	}
; 55   : 
; 56   : 	i = strEncrptedKey.size();

  0004d	8b be dc 00 00
	00		 mov	 edi, DWORD PTR [esi+220]

; 57   : 	while(i > 0){

  00053	85 ff		 test	 edi, edi
  00055	76 2c		 jbe	 SHORT $LN1@Clear_Key@2
$LL2@Clear_Key@2:

; 58   : 		i--;

  00057	4f		 dec	 edi

; 59   : 		strKey[i] = 0;

  00058	3b be c0 00 00
	00		 cmp	 edi, DWORD PTR [esi+192]
  0005e	76 05		 jbe	 SHORT $LN18@Clear_Key@2
  00060	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN18@Clear_Key@2:
  00065	39 9e c4 00 00
	00		 cmp	 DWORD PTR [esi+196], ebx
  0006b	72 08		 jb	 SHORT $LN23@Clear_Key@2
  0006d	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  00073	eb 06		 jmp	 SHORT $LN24@Clear_Key@2
$LN23@Clear_Key@2:
  00075	8d 86 b0 00 00
	00		 lea	 eax, DWORD PTR [esi+176]
$LN24@Clear_Key@2:
  0007b	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  0007f	85 ff		 test	 edi, edi
  00081	77 d4		 ja	 SHORT $LL2@Clear_Key@2
$LN1@Clear_Key@2:
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx

; 60   : 	}
; 61   : 
; 62   : }

  00086	c3		 ret	 0
?Clear_Key@PWRI_KEK@@UAEXXZ ENDP			; PWRI_KEK::Clear_Key
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx
; __Newsize$ = eax

; 1682 : 		if (_Newsize <= _Mysize)

  00000	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00003	3b c2		 cmp	 eax, edx
  00005	77 09		 ja	 SHORT $LN2@resize

; 1683 : 			erase(_Newsize);

  00007	6a ff		 push	 -1
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1686 : 		}

  0000f	c3		 ret	 0
$LN2@resize:

; 1684 : 		else
; 1685 : 			append(_Newsize - _Mysize, _Ch);

  00010	6a 00		 push	 0
  00012	2b c2		 sub	 eax, edx
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1686 : 		}

  0001a	c3		 ret	 0
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx
; __Newsize$ = eax

; 1677 : 		resize(_Newsize, _Elem());

  00000	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00003	3b c2		 cmp	 eax, edx
  00005	77 09		 ja	 SHORT $LN4@resize@2
  00007	6a ff		 push	 -1
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1678 : 		}

  0000f	c3		 ret	 0

; 1677 : 		resize(_Newsize, _Elem());

$LN4@resize@2:
  00010	6a 00		 push	 0
  00012	2b c2		 sub	 eax, edx
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1678 : 		}

  0001a	c3		 ret	 0
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\pwri-kek.cpp
_TEXT	ENDS
;	COMDAT ?KeyUnWrap@PWRI_KEK@@UAEHPAXI@Z
_TEXT	SEGMENT
_cBuff0$ = -4						; size = 4
_data$ = 8						; size = 4
_szData$ = 12						; size = 4
?KeyUnWrap@PWRI_KEK@@UAEHPAXI@Z PROC			; PWRI_KEK::KeyUnWrap, COMDAT
; _this$ = ecx

; 150  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 151  : //	unsigned	char*	cData	= (unsigned char*)data;
; 152  : 
; 153  : 	unsigned	int		szKEK;
; 154  : 	unsigned	int		szKEB	= keyWrapAlgorithm->szBlock;

  00007	8b 87 a8 00 00
	00		 mov	 eax, DWORD PTR [edi+168]
  0000d	8b 98 a0 00 00
	00		 mov	 ebx, DWORD PTR [eax+160]

; 155  : 
; 156  : 	unsigned	int		i;
; 157  : 	unsigned	int		n		= szData / szKEB;		//ブロック数
; 158  : 	unsigned	int		ptData	= szData - (szKEB*2);

  00013	8b 44 24 1c	 mov	 eax, DWORD PTR _szData$[esp+16]

; 159  : 
; 160  : 	unsigned	char*	cBuff0;		//暗号化用のバッファ
; 161  : 	unsigned	char*	cBuff;		//暗号化用のバッファ（アライメント）
; 162  : 
; 163  : 	cBuff0	= new unsigned char [szData + szKEB];

  00017	8d 14 03	 lea	 edx, DWORD PTR [ebx+eax]
  0001a	8d 0c 1b	 lea	 ecx, DWORD PTR [ebx+ebx]
  0001d	8b e8		 mov	 ebp, eax
  0001f	52		 push	 edx
  00020	2b e9		 sub	 ebp, ecx
  00022	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00027	8b f0		 mov	 esi, eax

; 164  : 	cBuff	= cBuff0 + szKEB - ((int)cBuff0 % szKEB) - (((int)cBuff0 % szKEB)?0:szKEB);

  00029	33 d2		 xor	 edx, edx
  0002b	f7 f3		 div	 ebx

; 165  : 
; 166  : 	memcpy(cBuff, data, szData);

  0002d	8b 4c 24 20	 mov	 ecx, DWORD PTR _szData$[esp+20]
  00031	89 74 24 14	 mov	 DWORD PTR _cBuff0$[esp+24], esi
  00035	51		 push	 ecx
  00036	8b c2		 mov	 eax, edx
  00038	f7 d8		 neg	 eax
  0003a	1b c0		 sbb	 eax, eax
  0003c	f7 d0		 not	 eax
  0003e	23 c3		 and	 eax, ebx
  00040	2b f0		 sub	 esi, eax
  00042	2b f2		 sub	 esi, edx
  00044	8b 54 24 20	 mov	 edx, DWORD PTR _data$[esp+24]
  00048	52		 push	 edx
  00049	03 f3		 add	 esi, ebx
  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 _memcpy

; 167  : 
; 168  : 	//Using the n-1'th ciphertext block as the IV,
; 169  : 	keyWrapAlgorithm->SetIV(&cBuff[ptData]);

  00051	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
  00057	8b 01		 mov	 eax, DWORD PTR [ecx]
  00059	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0005c	83 c4 10	 add	 esp, 16			; 00000010H
  0005f	8d 14 2e	 lea	 edx, DWORD PTR [esi+ebp]
  00062	52		 push	 edx
  00063	ff d0		 call	 eax

; 170  : 
; 171  : 	//decrypt the n'th ciphertext block.
; 172  : 	ptData += szKEB;
; 173  : 	keyWrapAlgorithm->decrypt(&cBuff[ptData]);

  00065	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
  0006b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006d	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00070	03 eb		 add	 ebp, ebx
  00072	03 ee		 add	 ebp, esi
  00074	55		 push	 ebp
  00075	ff d0		 call	 eax

; 174  : 
; 175  : 	//Using the decrypted n'th ciphertext block as the IV,
; 176  : 	keyWrapAlgorithm->SetIV(&cBuff[ptData]);

  00077	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
  0007d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007f	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00082	55		 push	 ebp
  00083	ff d0		 call	 eax

; 177  : 
; 178  : 	//decrypt the 1st ... n-1'th ciphertext blocks.
; 179  : 	keyWrapAlgorithm->decipher(cBuff, szData-szKEB);

  00085	8b 6c 24 1c	 mov	 ebp, DWORD PTR _szData$[esp+16]
  00089	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
  0008f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00091	8b 52 30	 mov	 edx, DWORD PTR [edx+48]
  00094	8b c5		 mov	 eax, ebp
  00096	2b c3		 sub	 eax, ebx
  00098	50		 push	 eax
  00099	56		 push	 esi
  0009a	ff d2		 call	 edx

; 180  : 
; 181  : 	//Decrypt the inner layer of encryption using the KEK.
; 182  : 	keyWrapAlgorithm->init();

  0009c	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
  000a2	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a4	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000a7	ff d2		 call	 edx

; 183  : 	keyWrapAlgorithm->decipher(cBuff, szData);

  000a9	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
  000af	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b1	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  000b4	55		 push	 ebp
  000b5	56		 push	 esi
  000b6	ff d2		 call	 edx

; 184  : 
; 185  : 	//Check
; 186  : 	if(	((cBuff[1] ^ 0xFF) == cBuff[4])
; 187  : 	 &&	((cBuff[2] ^ 0xFF) == cBuff[5])
; 188  : 	 &&	((cBuff[3] ^ 0xFF) == cBuff[6])){

  000b8	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  000bb	f6 d0		 not	 al
  000bd	3a 46 04	 cmp	 al, BYTE PTR [esi+4]
  000c0	75 74		 jne	 SHORT $LN4@KeyUnWrap
  000c2	8a 4e 02	 mov	 cl, BYTE PTR [esi+2]
  000c5	f6 d1		 not	 cl
  000c7	3a 4e 05	 cmp	 cl, BYTE PTR [esi+5]
  000ca	75 6a		 jne	 SHORT $LN4@KeyUnWrap
  000cc	8a 56 03	 mov	 dl, BYTE PTR [esi+3]
  000cf	f6 d2		 not	 dl
  000d1	3a 56 06	 cmp	 dl, BYTE PTR [esi+6]
  000d4	75 60		 jne	 SHORT $LN4@KeyUnWrap

; 189  : 		szKEK = cBuff[0];

  000d6	0f b6 2e	 movzx	 ebp, BYTE PTR [esi]

; 190  : 		strKey.resize(szKEK);

  000d9	8b 87 c0 00 00
	00		 mov	 eax, DWORD PTR [edi+192]
  000df	8d 9f ac 00 00
	00		 lea	 ebx, DWORD PTR [edi+172]
  000e5	3b e8		 cmp	 ebp, eax
  000e7	77 0c		 ja	 SHORT $LN10@KeyUnWrap
  000e9	6a ff		 push	 -1
  000eb	55		 push	 ebp
  000ec	8b cb		 mov	 ecx, ebx
  000ee	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  000f3	eb 0e		 jmp	 SHORT $LN9@KeyUnWrap
$LN10@KeyUnWrap:
  000f5	8b cd		 mov	 ecx, ebp
  000f7	2b c8		 sub	 ecx, eax
  000f9	6a 00		 push	 0
  000fb	51		 push	 ecx
  000fc	8b cb		 mov	 ecx, ebx
  000fe	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN9@KeyUnWrap:

; 191  : 		i = 0;

  00103	33 ff		 xor	 edi, edi

; 192  : 		while(i < szKEK){

  00105	85 ed		 test	 ebp, ebp
  00107	76 30		 jbe	 SHORT $LN1@KeyUnWrap
  00109	8d a4 24 00 00
	00 00		 npad	 7
$LL3@KeyUnWrap:

; 193  : 			strKey[i] = cBuff[4 + i];

  00110	3b 7b 14	 cmp	 edi, DWORD PTR [ebx+20]
  00113	76 05		 jbe	 SHORT $LN13@KeyUnWrap
  00115	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN13@KeyUnWrap:
  0011a	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  0011e	72 05		 jb	 SHORT $LN18@KeyUnWrap
  00120	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00123	eb 03		 jmp	 SHORT $LN19@KeyUnWrap
$LN18@KeyUnWrap:
  00125	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
$LN19@KeyUnWrap:
  00128	8a 54 3e 04	 mov	 dl, BYTE PTR [esi+edi+4]
  0012c	88 14 38	 mov	 BYTE PTR [eax+edi], dl

; 194  : 			i++;

  0012f	47		 inc	 edi
  00130	3b fd		 cmp	 edi, ebp
  00132	72 dc		 jb	 SHORT $LL3@KeyUnWrap

; 195  : 		}
; 196  : 	} else {

  00134	eb 03		 jmp	 SHORT $LN1@KeyUnWrap
$LN4@KeyUnWrap:

; 197  : 		szKEK = -1;

  00136	83 cd ff	 or	 ebp, -1
$LN1@KeyUnWrap:

; 198  : 	}
; 199  : 
; 200  : 	delete	cBuff0;

  00139	8b 44 24 10	 mov	 eax, DWORD PTR _cBuff0$[esp+20]
  0013d	50		 push	 eax
  0013e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00143	83 c4 04	 add	 esp, 4
  00146	5f		 pop	 edi
  00147	5e		 pop	 esi

; 201  : 
; 202  : 	return(szKEK);

  00148	8b c5		 mov	 eax, ebp
  0014a	5d		 pop	 ebp
  0014b	5b		 pop	 ebx

; 203  : }

  0014c	59		 pop	 ecx
  0014d	c2 08 00	 ret	 8
?KeyUnWrap@PWRI_KEK@@UAEHPAXI@Z ENDP			; PWRI_KEK::KeyUnWrap
; Function compile flags: /Ogtpy
;	COMDAT ?KeyWrap@PWRI_KEK@@UAEHPAXI@Z
_TEXT	SEGMENT
$T66788 = -44						; size = 4
_this$ = -40						; size = 4
_cBuff0$ = -36						; size = 4
_result$66780 = -32					; size = 32
_i$66783 = 8						; size = 4
_CEK$ = 8						; size = 4
tv496 = 12						; size = 4
_szCEK$ = 12						; size = 4
?KeyWrap@PWRI_KEK@@UAEHPAXI@Z PROC			; PWRI_KEK::KeyWrap, COMDAT
; _this$ = ecx

; 86   : {

  00000	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 87   : 	unsigned	char*	cCEK	= (unsigned char*)CEK;
; 88   : 
; 89   : 	unsigned	int		szECEK	= szCEK + 4;
; 90   : 	unsigned	int		szKEB	= keyWrapAlgorithm->szBlock;

  00003	8b 81 a8 00 00
	00		 mov	 eax, DWORD PTR [ecx+168]
  00009	53		 push	 ebx
  0000a	8b 5c 24 38	 mov	 ebx, DWORD PTR _szCEK$[esp+44]
  0000e	55		 push	 ebp
  0000f	56		 push	 esi
  00010	83 c3 04	 add	 ebx, 4
  00013	57		 push	 edi
  00014	8b b8 a0 00 00
	00		 mov	 edi, DWORD PTR [eax+160]

; 91   : 
; 92   : 	unsigned	int	i,j;
; 93   : 
; 94   : 	unsigned	char*	cBuff0;		//暗号化用のバッファ
; 95   : 	unsigned	char*	cBuff;		//暗号化用のバッファ（アライメント）
; 96   : 
; 97   : 	//ラップされたコンテンツ用暗号鍵"CEK"のサイズ
; 98   : 	szECEK  += szKEB - (szECEK % szKEB) - ((szECEK % szKEB)?0:szKEB);

  0001a	33 d2		 xor	 edx, edx
  0001c	8b c3		 mov	 eax, ebx
  0001e	f7 f7		 div	 edi
  00020	89 4c 24 14	 mov	 DWORD PTR _this$[esp+60], ecx
  00024	8b c7		 mov	 eax, edi
  00026	8b ca		 mov	 ecx, edx
  00028	f7 d9		 neg	 ecx
  0002a	1b c9		 sbb	 ecx, ecx
  0002c	f7 d1		 not	 ecx
  0002e	23 cf		 and	 ecx, edi
  00030	2b c1		 sub	 eax, ecx
  00032	2b c2		 sub	 eax, edx
  00034	03 d8		 add	 ebx, eax

; 99   : 
; 100  : 	//暗号用のバッファを確保。アライメントも考慮する。
; 101  : 	cBuff0	= new unsigned char [szECEK + szKEB];

  00036	8d 0c 1f	 lea	 ecx, DWORD PTR [edi+ebx]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 102  : 	cBuff	= cBuff0 + szKEB - ((int)cBuff0 % szKEB) - (((int)cBuff0 % szKEB)?0:szKEB);

  0003f	33 d2		 xor	 edx, edx
  00041	8b f0		 mov	 esi, eax
  00043	f7 f7		 div	 edi

; 103  : 
; 104  : 	//コンテンツ用暗号鍵"CEK"のSize
; 105  : 	cBuff[0] = szCEK & 0xFF;

  00045	8b 4c 24 48	 mov	 ecx, DWORD PTR _szCEK$[esp+60]
  00049	83 c4 04	 add	 esp, 4
  0004c	89 74 24 18	 mov	 DWORD PTR _cBuff0$[esp+60], esi
  00050	8b c2		 mov	 eax, edx
  00052	f7 d8		 neg	 eax
  00054	1b c0		 sbb	 eax, eax
  00056	f7 d0		 not	 eax
  00058	23 c7		 and	 eax, edi
  0005a	2b f0		 sub	 esi, eax

; 106  : 
; 107  : 	//Check
; 108  : 	cBuff[1] = 0xFF ^ cCEK[0];

  0005c	8b 44 24 40	 mov	 eax, DWORD PTR _CEK$[esp+56]
  00060	2b f2		 sub	 esi, edx
  00062	03 f7		 add	 esi, edi
  00064	88 0e		 mov	 BYTE PTR [esi], cl
  00066	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00069	f6 d2		 not	 dl
  0006b	88 56 01	 mov	 BYTE PTR [esi+1], dl

; 109  : 	cBuff[2] = 0xFF ^ cCEK[1];

  0006e	0f b6 50 01	 movzx	 edx, BYTE PTR [eax+1]
  00072	f6 d2		 not	 dl
  00074	88 56 02	 mov	 BYTE PTR [esi+2], dl

; 110  : 	cBuff[3] = 0xFF ^ cCEK[2];

  00077	0f b6 50 02	 movzx	 edx, BYTE PTR [eax+2]
  0007b	f6 d2		 not	 dl

; 111  : 
; 112  : 	//CEK
; 113  : 	i = 0;

  0007d	33 ed		 xor	 ebp, ebp
  0007f	88 56 03	 mov	 BYTE PTR [esi+3], dl

; 114  : 	while(i < szCEK){

  00082	85 c9		 test	 ecx, ecx
  00084	76 0c		 jbe	 SHORT $LN3@KeyWrap
$LL4@KeyWrap:

; 115  : 		cBuff[4+i] = cCEK[i];

  00086	8a 14 28	 mov	 dl, BYTE PTR [eax+ebp]
  00089	88 54 2e 04	 mov	 BYTE PTR [esi+ebp+4], dl

; 116  : 		i++;

  0008d	45		 inc	 ebp
  0008e	3b e9		 cmp	 ebp, ecx
  00090	72 f4		 jb	 SHORT $LL4@KeyWrap
$LN3@KeyWrap:

; 117  : 	}
; 118  : 	i += 4;

  00092	83 c5 04	 add	 ebp, 4

; 119  : 
; 120  : 	//Random Padding
; 121  : 	j = 0;
; 122  : 	while(i < szECEK){

  00095	3b eb		 cmp	 ebp, ebx
  00097	0f 83 81 00 00
	00		 jae	 $LN1@KeyWrap
  0009d	8d 49 00	 npad	 3
$LL2@KeyWrap:

; 123  : 		cBuff[i] = cRandom->get_int();

  000a0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?cRandom@@3PAVMT_SHA@@A ; cRandom
  000a6	8d 87 e0 0a 00
	00		 lea	 eax, DWORD PTR [edi+2784]
  000ac	89 7c 24 10	 mov	 DWORD PTR $T66788[esp+60], edi
  000b0	c7 44 24 40 10
	00 00 00	 mov	 DWORD PTR _i$66783[esp+56], 16 ; 00000010H
  000b8	89 44 24 44	 mov	 DWORD PTR tv496[esp+56], eax
  000bc	8d 64 24 00	 npad	 4
$LL11@KeyWrap:
  000c0	ff 4c 24 40	 dec	 DWORD PTR _i$66783[esp+56]
  000c4	83 6c 24 44 04	 sub	 DWORD PTR tv496[esp+56], 4
  000c9	57		 push	 edi
  000ca	e8 00 00 00 00	 call	 ?genrand_int32@MT@@QAEKXZ ; MT::genrand_int32
  000cf	83 7c 24 40 00	 cmp	 DWORD PTR _i$66783[esp+56], 0
  000d4	8b 4c 24 44	 mov	 ecx, DWORD PTR tv496[esp+56]
  000d8	89 01		 mov	 DWORD PTR [ecx], eax
  000da	75 e4		 jne	 SHORT $LL11@KeyWrap
  000dc	8b 97 c4 09 00
	00		 mov	 edx, DWORD PTR [edi+2500]
  000e2	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000e5	81 c7 c4 09 00
	00		 add	 edi, 2500		; 000009c4H
  000eb	8b cf		 mov	 ecx, edi
  000ed	ff d0		 call	 eax
  000ef	8b 44 24 10	 mov	 eax, DWORD PTR $T66788[esp+60]
  000f3	8b 17		 mov	 edx, DWORD PTR [edi]
  000f5	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  000f8	6a 40		 push	 64			; 00000040H
  000fa	05 a0 0a 00 00	 add	 eax, 2720		; 00000aa0H
  000ff	50		 push	 eax
  00100	8b cf		 mov	 ecx, edi
  00102	ff d2		 call	 edx
  00104	8b 07		 mov	 eax, DWORD PTR [edi]
  00106	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00109	8d 4c 24 1c	 lea	 ecx, DWORD PTR _result$66780[esp+60]
  0010d	51		 push	 ecx
  0010e	8b cf		 mov	 ecx, edi
  00110	ff d2		 call	 edx
  00112	8a 44 24 1c	 mov	 al, BYTE PTR _result$66780[esp+60]
  00116	88 04 2e	 mov	 BYTE PTR [esi+ebp], al

; 124  : 		j++;
; 125  : 		i++;

  00119	45		 inc	 ebp
  0011a	3b eb		 cmp	 ebp, ebx
  0011c	72 82		 jb	 SHORT $LL2@KeyWrap
$LN1@KeyWrap:

; 126  : 	}
; 127  : 
; 128  : 	//Key Wrap
; 129  : 	keyWrapAlgorithm->init();

  0011e	8b 7c 24 14	 mov	 edi, DWORD PTR _this$[esp+60]
  00122	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
  00128	8b 11		 mov	 edx, DWORD PTR [ecx]
  0012a	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0012d	ff d0		 call	 eax

; 130  : 	keyWrapAlgorithm->encipher(cBuff, szECEK);

  0012f	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
  00135	8b 11		 mov	 edx, DWORD PTR [ecx]
  00137	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0013a	53		 push	 ebx
  0013b	56		 push	 esi
  0013c	ff d0		 call	 eax

; 131  : 	keyWrapAlgorithm->encipher(cBuff, szECEK);

  0013e	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
  00144	8b 11		 mov	 edx, DWORD PTR [ecx]
  00146	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00149	53		 push	 ebx
  0014a	56		 push	 esi
  0014b	ff d0		 call	 eax

; 132  : 
; 133  : 	strEncrptedKey.resize(szECEK);

  0014d	8b 87 dc 00 00
	00		 mov	 eax, DWORD PTR [edi+220]
  00153	81 c7 c8 00 00
	00		 add	 edi, 200		; 000000c8H
  00159	3b d8		 cmp	 ebx, eax
  0015b	77 0c		 ja	 SHORT $LN17@KeyWrap
  0015d	6a ff		 push	 -1
  0015f	53		 push	 ebx
  00160	8b cf		 mov	 ecx, edi
  00162	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00167	eb 0e		 jmp	 SHORT $LN16@KeyWrap
$LN17@KeyWrap:
  00169	8b cb		 mov	 ecx, ebx
  0016b	2b c8		 sub	 ecx, eax
  0016d	6a 00		 push	 0
  0016f	51		 push	 ecx
  00170	8b cf		 mov	 ecx, edi
  00172	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN16@KeyWrap:

; 134  : 	strEncrptedKey.assign((char *)cBuff, szECEK);

  00177	53		 push	 ebx
  00178	56		 push	 esi
  00179	8b cf		 mov	 ecx, edi
  0017b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 135  : 
; 136  : 	delete	cBuff0;

  00180	8b 54 24 18	 mov	 edx, DWORD PTR _cBuff0$[esp+60]
  00184	52		 push	 edx
  00185	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0018a	83 c4 04	 add	 esp, 4
  0018d	5f		 pop	 edi
  0018e	5e		 pop	 esi
  0018f	5d		 pop	 ebp

; 137  : 
; 138  : 	return(szECEK);

  00190	8b c3		 mov	 eax, ebx
  00192	5b		 pop	 ebx

; 139  : }

  00193	83 c4 2c	 add	 esp, 44			; 0000002cH
  00196	c2 08 00	 ret	 8
?KeyWrap@PWRI_KEK@@UAEHPAXI@Z ENDP			; PWRI_KEK::KeyWrap
PUBLIC	?Get_Encryption@PWRI_KEK@@QAEPAVEncryption@@IT__m128i@@@Z ; PWRI_KEK::Get_Encryption
; Function compile flags: /Ogtpy
;	COMDAT ?Get_Encryption@PWRI_KEK@@QAEPAVEncryption@@IT__m128i@@@Z
_TEXT	SEGMENT
_IV$ = -16						; size = 16
_mode$ = 8						; size = 4
?Get_Encryption@PWRI_KEK@@QAEPAVEncryption@@IT__m128i@@@Z PROC ; PWRI_KEK::Get_Encryption, COMDAT
; _IV$ = xmm0

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	83 ec 10	 sub	 esp, 16			; 00000010H

; 234  : 
; 235  : 	Encryption*	cKE;
; 236  : 
; 237  : 	//暗号アルゴリズム＆利用モードの設定
; 238  : 	switch(mode){

  00009	8b 45 08	 mov	 eax, DWORD PTR _mode$[ebp]
  0000c	48		 dec	 eax
  0000d	66 0f 7f 04 24	 movdqa	 XMMWORD PTR _IV$[esp+16], xmm0
  00012	83 f8 03	 cmp	 eax, 3
  00015	77 6d		 ja	 SHORT $LN1@Get_Encryp@2
  00017	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN10@Get_Encryp@2[eax*4]
$LN5@Get_Encryp@2:

; 239  : 		//追加の暗号アルゴリズムがある場合は、ここに追加。
; 240  : 		//DES-CBC
; 241  : 		case(1):
; 242  : 			ke_DES_CBC.Set_DES(IV.m128i_i64[0]);

  0001e	8b 44 24 04	 mov	 eax, DWORD PTR _IV$[esp+20]
  00022	8b 0c 24	 mov	 ecx, DWORD PTR _IV$[esp+16]
  00025	50		 push	 eax
  00026	51		 push	 ecx
  00027	68 00 00 00 00	 push	 OFFSET ?ke_DES_CBC@PWRI_KEK@@2VDES_CBC@@A ; PWRI_KEK::ke_DES_CBC
  0002c	e8 00 00 00 00	 call	 ?Set_DES@DES_CBC@@QAEX_K@Z ; DES_CBC::Set_DES

; 243  : 			cKE = &ke_DES_CBC;

  00031	b8 00 00 00 00	 mov	 eax, OFFSET ?ke_DES_CBC@PWRI_KEK@@2VDES_CBC@@A ; PWRI_KEK::ke_DES_CBC

; 264  : 			break;
; 265  : 	}
; 266  : 	return(cKE);
; 267  : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
$LN4@Get_Encryp@2:

; 244  : 			break;
; 245  : 		//DES-EDE3-CBC
; 246  : 		case(2):
; 247  : 			ke_TDES_CBC.Set_DES(IV.m128i_i64[0]);

  0003c	8b 54 24 04	 mov	 edx, DWORD PTR _IV$[esp+20]
  00040	8b 04 24	 mov	 eax, DWORD PTR _IV$[esp+16]
  00043	52		 push	 edx
  00044	50		 push	 eax
  00045	68 00 00 00 00	 push	 OFFSET ?ke_TDES_CBC@PWRI_KEK@@2VDES_EDE3_CBC@@A ; PWRI_KEK::ke_TDES_CBC
  0004a	e8 00 00 00 00	 call	 ?Set_DES@DES_EDE3_CBC@@QAEX_K@Z ; DES_EDE3_CBC::Set_DES

; 248  : 			cKE = &ke_TDES_CBC;

  0004f	b8 00 00 00 00	 mov	 eax, OFFSET ?ke_TDES_CBC@PWRI_KEK@@2VDES_EDE3_CBC@@A ; PWRI_KEK::ke_TDES_CBC

; 264  : 			break;
; 265  : 	}
; 266  : 	return(cKE);
; 267  : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
$LN3@Get_Encryp@2:

; 249  : 			break;
; 250  : 		//AES-CBC-128
; 251  : 		case(3):
; 252  : 			ke_AES_CBC128.Set_AES(IV);

  0005a	68 00 00 00 00	 push	 OFFSET ?ke_AES_CBC128@PWRI_KEK@@2VAES_CBC128@@A ; PWRI_KEK::ke_AES_CBC128
  0005f	e8 00 00 00 00	 call	 ?Set_AES@AES_CBC@@QAEXT__m128i@@@Z ; AES_CBC::Set_AES

; 253  : 			cKE = &ke_AES_CBC128;

  00064	b8 00 00 00 00	 mov	 eax, OFFSET ?ke_AES_CBC128@PWRI_KEK@@2VAES_CBC128@@A ; PWRI_KEK::ke_AES_CBC128

; 264  : 			break;
; 265  : 	}
; 266  : 	return(cKE);
; 267  : }

  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
$LN2@Get_Encryp@2:

; 254  : 			break;
; 255  : 		//AES-CBC-192
; 256  : 		case(4):
; 257  : 			ke_AES_CBC192.Set_AES(IV);

  0006f	68 00 00 00 00	 push	 OFFSET ?ke_AES_CBC192@PWRI_KEK@@2VAES_CBC192@@A ; PWRI_KEK::ke_AES_CBC192
  00074	e8 00 00 00 00	 call	 ?Set_AES@AES_CBC@@QAEXT__m128i@@@Z ; AES_CBC::Set_AES

; 258  : 			cKE = &ke_AES_CBC192;

  00079	b8 00 00 00 00	 mov	 eax, OFFSET ?ke_AES_CBC192@PWRI_KEK@@2VAES_CBC192@@A ; PWRI_KEK::ke_AES_CBC192

; 264  : 			break;
; 265  : 	}
; 266  : 	return(cKE);
; 267  : }

  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
$LN1@Get_Encryp@2:

; 259  : 			break;
; 260  : 		//AES-CBC-256
; 261  : 		default:
; 262  : 			ke_AES_CBC256.Set_AES(IV);

  00084	68 00 00 00 00	 push	 OFFSET ?ke_AES_CBC256@PWRI_KEK@@2VAES_CBC256@@A ; PWRI_KEK::ke_AES_CBC256
  00089	e8 00 00 00 00	 call	 ?Set_AES@AES_CBC@@QAEXT__m128i@@@Z ; AES_CBC::Set_AES

; 263  : 			cKE = &ke_AES_CBC256;

  0008e	b8 00 00 00 00	 mov	 eax, OFFSET ?ke_AES_CBC256@PWRI_KEK@@2VAES_CBC256@@A ; PWRI_KEK::ke_AES_CBC256

; 264  : 			break;
; 265  : 	}
; 266  : 	return(cKE);
; 267  : }

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 04 00	 ret	 4
  00099	8d 49 00	 npad	 3
$LN10@Get_Encryp@2:
  0009c	00 00 00 00	 DD	 $LN5@Get_Encryp@2
  000a0	00 00 00 00	 DD	 $LN4@Get_Encryp@2
  000a4	00 00 00 00	 DD	 $LN3@Get_Encryp@2
  000a8	00 00 00 00	 DD	 $LN2@Get_Encryp@2
?Get_Encryption@PWRI_KEK@@QAEPAVEncryption@@IT__m128i@@@Z ENDP ; PWRI_KEK::Get_Encryption
_TEXT	ENDS
PUBLIC	?Set_PWRI_KEK@PWRI_KEK@@QAEXIT__m128i@@@Z	; PWRI_KEK::Set_PWRI_KEK
; Function compile flags: /Ogtpy
;	COMDAT ?Set_PWRI_KEK@PWRI_KEK@@QAEXIT__m128i@@@Z
_TEXT	SEGMENT
$T94197 = -20						; size = 4
$T94207 = -20						; size = 4
_IV$ = -16						; size = 16
_mode$ = 8						; size = 4
?Set_PWRI_KEK@PWRI_KEK@@QAEXIT__m128i@@@Z PROC		; PWRI_KEK::Set_PWRI_KEK, COMDAT
; _this$ = esi
; _IV$ = xmm0

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	57		 push	 edi

; 214  : 	//ASN.1の定義
; 215  : 	Set();			//oid

  0000a	8d 7e 28	 lea	 edi, DWORD PTR [esi+40]
  0000d	8b c7		 mov	 eax, edi
  0000f	66 0f 7f 44 24
	10		 movdqa	 XMMWORD PTR _IV$[esp+32], xmm0
  00015	e8 00 00 00 00	 call	 ?clear@?$vector@PAVASN1@@V?$allocator@PAVASN1@@@std@@@std@@QAEXXZ ; std::vector<ASN1 *,std::allocator<ASN1 *> >::clear
  0001a	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T94197[esp+32]
  0001e	8d 46 44	 lea	 eax, DWORD PTR [esi+68]
  00021	51		 push	 ecx
  00022	89 44 24 10	 mov	 DWORD PTR $T94197[esp+36], eax
  00026	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVASN1@@V?$allocator@PAVASN1@@@std@@@std@@QAEXABQAVASN1@@@Z ; std::vector<ASN1 *,std::allocator<ASN1 *> >::push_back

; 216  : //	EncryptionAlgorithm = _algorithm;
; 217  : 	keyWrapAlgorithm	= Get_Encryption(mode,IV);

  0002b	8b 55 08	 mov	 edx, DWORD PTR _mode$[ebp]
  0002e	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR _IV$[esp+32]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ?Get_Encryption@PWRI_KEK@@QAEPAVEncryption@@IT__m128i@@@Z ; PWRI_KEK::Get_Encryption
  0003a	89 86 a8 00 00
	00		 mov	 DWORD PTR [esi+168], eax

; 218  : 	Set_Construct(keyWrapAlgorithm);

  00040	89 44 24 0c	 mov	 DWORD PTR $T94207[esp+32], eax
  00044	8d 44 24 0c	 lea	 eax, DWORD PTR $T94207[esp+32]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVASN1@@V?$allocator@PAVASN1@@@std@@@std@@QAEXABQAVASN1@@@Z ; std::vector<ASN1 *,std::allocator<ASN1 *> >::push_back

; 219  : 
; 220  : 	szKey = keyWrapAlgorithm->szKey;

  0004e	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  00054	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0005a	89 96 a4 00 00
	00		 mov	 DWORD PTR [esi+164], edx

; 221  : }

  00060	5f		 pop	 edi
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?Set_PWRI_KEK@PWRI_KEK@@QAEXIT__m128i@@@Z ENDP		; PWRI_KEK::Set_PWRI_KEK
PUBLIC	??0PWRI_KEK@@QAE@QBD@Z				; PWRI_KEK::PWRI_KEK
;	COMDAT xdata$x
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\algorithmidentifier.cpp
xdata$x	SEGMENT
__unwindtable$??0PWRI_KEK@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0PWRI_KEK@@QAE@QBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0PWRI_KEK@@QAE@QBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0PWRI_KEK@@QAE@QBD@Z$2
__ehfuncinfo$??0PWRI_KEK@@QAE@QBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0PWRI_KEK@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\pwri-kek.cpp
xdata$x	ENDS
;	COMDAT ??0PWRI_KEK@@QAE@QBD@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0PWRI_KEK@@QAE@QBD@Z PROC				; PWRI_KEK::PWRI_KEK, COMDAT

; 22   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0PWRI_KEK@@QAE@QBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_08LIMCBOKO@PWRI?9KEK?$AA@
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ??0AlgorithmIdentifier@@QAE@QBD@Z ; AlgorithmIdentifier::AlgorithmIdentifier
  00031	33 c0		 xor	 eax, eax
  00033	89 44 24 14	 mov	 DWORD PTR __$EHRec$[esp+32], eax
  00037	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7PWRI_KEK@@6B@
  0003d	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00042	89 8e c4 00 00
	00		 mov	 DWORD PTR [esi+196], ecx
  00048	89 86 c0 00 00
	00		 mov	 DWORD PTR [esi+192], eax
  0004e	88 86 b0 00 00
	00		 mov	 BYTE PTR [esi+176], al
  00054	89 8e e0 00 00
	00		 mov	 DWORD PTR [esi+224], ecx
  0005a	89 86 dc 00 00
	00		 mov	 DWORD PTR [esi+220], eax
  00060	88 86 cc 00 00
	00		 mov	 BYTE PTR [esi+204], al

; 23   : 	Set_oid(oid,sizeof(oid)/sizeof(int));

  00066	6a 09		 push	 9
  00068	68 00 00 00 00	 push	 OFFSET ?oid@PWRI_KEK@@2PAIA ; PWRI_KEK::oid
  0006d	8d 46 44	 lea	 eax, DWORD PTR [esi+68]
  00070	c6 44 24 1c 02	 mov	 BYTE PTR __$EHRec$[esp+40], 2
  00075	e8 00 00 00 00	 call	 ?Set@ObjectIdentifier@@QAEXQAII@Z ; ObjectIdentifier::Set

; 24   : }

  0007a	8b c6		 mov	 eax, esi
  0007c	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	5e		 pop	 esi
  00089	83 c4 10	 add	 esp, 16			; 00000010H
  0008c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0PWRI_KEK@@QAE@QBD@Z$0:
  00000	8b 75 04	 mov	 esi, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1Encryption@@QAE@XZ	; Encryption::~Encryption
__unwindfunclet$??0PWRI_KEK@@QAE@QBD@Z$1:
  00008	8b 4d 04	 mov	 ecx, DWORD PTR _this$[ebp-4]
  0000b	81 c1 ac 00 00
	00		 add	 ecx, 172		; 000000acH
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0PWRI_KEK@@QAE@QBD@Z$2:
  00016	8b 4d 04	 mov	 ecx, DWORD PTR _this$[ebp-4]
  00019	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  0001f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0PWRI_KEK@@QAE@QBD@Z:
  00024	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00028	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  0002b	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0PWRI_KEK@@QAE@QBD@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0PWRI_KEK@@QAE@QBD@Z ENDP				; PWRI_KEK::PWRI_KEK
; Function compile flags: /Ogtpy
;	COMDAT ??__E?ke_DES_CBC@PWRI_KEK@@2VDES_CBC@@A@@YAXXZ
text$yc	SEGMENT
??__E?ke_DES_CBC@PWRI_KEK@@2VDES_CBC@@A@@YAXXZ PROC	; `dynamic initializer for 'PWRI_KEK::ke_DES_CBC'', COMDAT

; 6    : 	DES_CBC			PWRI_KEK::ke_DES_CBC;

  00000	68 00 00 00 00	 push	 OFFSET ?ke_DES_CBC@PWRI_KEK@@2VDES_CBC@@A ; PWRI_KEK::ke_DES_CBC
  00005	e8 00 00 00 00	 call	 ??0DES_CBC@@QAE@QBD@Z	; DES_CBC::DES_CBC
  0000a	68 00 00 00 00	 push	 OFFSET ??__F?ke_DES_CBC@PWRI_KEK@@2VDES_CBC@@A@@YAXXZ ; `dynamic atexit destructor for 'PWRI_KEK::ke_DES_CBC''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__E?ke_DES_CBC@PWRI_KEK@@2VDES_CBC@@A@@YAXXZ ENDP	; `dynamic initializer for 'PWRI_KEK::ke_DES_CBC''
; Function compile flags: /Ogtpy
text$yc	ENDS
;	COMDAT ??__E?ke_TDES_CBC@PWRI_KEK@@2VDES_EDE3_CBC@@A@@YAXXZ
text$yc	SEGMENT
??__E?ke_TDES_CBC@PWRI_KEK@@2VDES_EDE3_CBC@@A@@YAXXZ PROC ; `dynamic initializer for 'PWRI_KEK::ke_TDES_CBC'', COMDAT

; 7    : 	DES_EDE3_CBC	PWRI_KEK::ke_TDES_CBC;

  00000	68 00 00 00 00	 push	 OFFSET ?ke_TDES_CBC@PWRI_KEK@@2VDES_EDE3_CBC@@A ; PWRI_KEK::ke_TDES_CBC
  00005	e8 00 00 00 00	 call	 ??0DES_EDE3_CBC@@QAE@QBD@Z ; DES_EDE3_CBC::DES_EDE3_CBC
  0000a	68 00 00 00 00	 push	 OFFSET ??__F?ke_TDES_CBC@PWRI_KEK@@2VDES_EDE3_CBC@@A@@YAXXZ ; `dynamic atexit destructor for 'PWRI_KEK::ke_TDES_CBC''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__E?ke_TDES_CBC@PWRI_KEK@@2VDES_EDE3_CBC@@A@@YAXXZ ENDP ; `dynamic initializer for 'PWRI_KEK::ke_TDES_CBC''
; Function compile flags: /Ogtpy
text$yc	ENDS
;	COMDAT ??__E?ke_AES_CBC128@PWRI_KEK@@2VAES_CBC128@@A@@YAXXZ
text$yc	SEGMENT
??__E?ke_AES_CBC128@PWRI_KEK@@2VAES_CBC128@@A@@YAXXZ PROC ; `dynamic initializer for 'PWRI_KEK::ke_AES_CBC128'', COMDAT

; 8    : 	AES_CBC128		PWRI_KEK::ke_AES_CBC128;		//SIMDを使う関係で、

  00000	68 00 00 00 00	 push	 OFFSET ?ke_AES_CBC128@PWRI_KEK@@2VAES_CBC128@@A ; PWRI_KEK::ke_AES_CBC128
  00005	e8 00 00 00 00	 call	 ??0AES_CBC128@@QAE@QBD@Z ; AES_CBC128::AES_CBC128
  0000a	68 00 00 00 00	 push	 OFFSET ??__F?ke_AES_CBC128@PWRI_KEK@@2VAES_CBC128@@A@@YAXXZ ; `dynamic atexit destructor for 'PWRI_KEK::ke_AES_CBC128''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__E?ke_AES_CBC128@PWRI_KEK@@2VAES_CBC128@@A@@YAXXZ ENDP ; `dynamic initializer for 'PWRI_KEK::ke_AES_CBC128''
; Function compile flags: /Ogtpy
text$yc	ENDS
;	COMDAT ??__E?ke_AES_CBC192@PWRI_KEK@@2VAES_CBC192@@A@@YAXXZ
text$yc	SEGMENT
??__E?ke_AES_CBC192@PWRI_KEK@@2VAES_CBC192@@A@@YAXXZ PROC ; `dynamic initializer for 'PWRI_KEK::ke_AES_CBC192'', COMDAT

; 9    : 	AES_CBC192		PWRI_KEK::ke_AES_CBC192;		//staticに置く必要あり。

  00000	68 00 00 00 00	 push	 OFFSET ?ke_AES_CBC192@PWRI_KEK@@2VAES_CBC192@@A ; PWRI_KEK::ke_AES_CBC192
  00005	e8 00 00 00 00	 call	 ??0AES_CBC192@@QAE@QBD@Z ; AES_CBC192::AES_CBC192
  0000a	68 00 00 00 00	 push	 OFFSET ??__F?ke_AES_CBC192@PWRI_KEK@@2VAES_CBC192@@A@@YAXXZ ; `dynamic atexit destructor for 'PWRI_KEK::ke_AES_CBC192''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__E?ke_AES_CBC192@PWRI_KEK@@2VAES_CBC192@@A@@YAXXZ ENDP ; `dynamic initializer for 'PWRI_KEK::ke_AES_CBC192''
; Function compile flags: /Ogtpy
text$yc	ENDS
;	COMDAT ??__E?ke_AES_CBC256@PWRI_KEK@@2VAES_CBC256@@A@@YAXXZ
text$yc	SEGMENT
??__E?ke_AES_CBC256@PWRI_KEK@@2VAES_CBC256@@A@@YAXXZ PROC ; `dynamic initializer for 'PWRI_KEK::ke_AES_CBC256'', COMDAT

; 10   : 	AES_CBC256		PWRI_KEK::ke_AES_CBC256;		//(__declspec(align(16)))

  00000	68 00 00 00 00	 push	 OFFSET ?ke_AES_CBC256@PWRI_KEK@@2VAES_CBC256@@A ; PWRI_KEK::ke_AES_CBC256
  00005	e8 00 00 00 00	 call	 ??0AES_CBC256@@QAE@QBD@Z ; AES_CBC256::AES_CBC256
  0000a	68 00 00 00 00	 push	 OFFSET ??__F?ke_AES_CBC256@PWRI_KEK@@2VAES_CBC256@@A@@YAXXZ ; `dynamic atexit destructor for 'PWRI_KEK::ke_AES_CBC256''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__E?ke_AES_CBC256@PWRI_KEK@@2VAES_CBC256@@A@@YAXXZ ENDP ; `dynamic initializer for 'PWRI_KEK::ke_AES_CBC256''
; Function compile flags: /Ogtpy
;	COMDAT ??__F?ke_DES_CBC@PWRI_KEK@@2VDES_CBC@@A@@YAXXZ
text$yd	SEGMENT
??__F?ke_DES_CBC@PWRI_KEK@@2VDES_CBC@@A@@YAXXZ PROC	; `dynamic atexit destructor for 'PWRI_KEK::ke_DES_CBC'', COMDAT
  00000	56		 push	 esi
  00001	be 00 00 00 00	 mov	 esi, OFFSET ?ke_DES_CBC@PWRI_KEK@@2VDES_CBC@@A ; PWRI_KEK::ke_DES_CBC
  00006	e8 00 00 00 00	 call	 ??1DES_CBC@@QAE@XZ	; DES_CBC::~DES_CBC
  0000b	5e		 pop	 esi
  0000c	c3		 ret	 0
??__F?ke_DES_CBC@PWRI_KEK@@2VDES_CBC@@A@@YAXXZ ENDP	; `dynamic atexit destructor for 'PWRI_KEK::ke_DES_CBC''
; Function compile flags: /Ogtpy
;	COMDAT ??__F?ke_AES_CBC256@PWRI_KEK@@2VAES_CBC256@@A@@YAXXZ
text$yd	SEGMENT
??__F?ke_AES_CBC256@PWRI_KEK@@2VAES_CBC256@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'PWRI_KEK::ke_AES_CBC256'', COMDAT
  00000	56		 push	 esi
  00001	be 00 00 00 00	 mov	 esi, OFFSET ?ke_AES_CBC256@PWRI_KEK@@2VAES_CBC256@@A ; PWRI_KEK::ke_AES_CBC256
  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ke_AES_CBC256@PWRI_KEK@@2VAES_CBC256@@A, OFFSET ??_7AES_CBC256@@6B@
  00010	e8 00 00 00 00	 call	 ??1AES_CBC@@QAE@XZ	; AES_CBC::~AES_CBC
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??__F?ke_AES_CBC256@PWRI_KEK@@2VAES_CBC256@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'PWRI_KEK::ke_AES_CBC256''
; Function compile flags: /Ogtpy
text$yd	ENDS
;	COMDAT ??__F?ke_AES_CBC192@PWRI_KEK@@2VAES_CBC192@@A@@YAXXZ
text$yd	SEGMENT
??__F?ke_AES_CBC192@PWRI_KEK@@2VAES_CBC192@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'PWRI_KEK::ke_AES_CBC192'', COMDAT
  00000	56		 push	 esi
  00001	be 00 00 00 00	 mov	 esi, OFFSET ?ke_AES_CBC192@PWRI_KEK@@2VAES_CBC192@@A ; PWRI_KEK::ke_AES_CBC192
  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ke_AES_CBC192@PWRI_KEK@@2VAES_CBC192@@A, OFFSET ??_7AES_CBC192@@6B@
  00010	e8 00 00 00 00	 call	 ??1AES_CBC@@QAE@XZ	; AES_CBC::~AES_CBC
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??__F?ke_AES_CBC192@PWRI_KEK@@2VAES_CBC192@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'PWRI_KEK::ke_AES_CBC192''
; Function compile flags: /Ogtpy
text$yd	ENDS
;	COMDAT ??__F?ke_AES_CBC128@PWRI_KEK@@2VAES_CBC128@@A@@YAXXZ
text$yd	SEGMENT
??__F?ke_AES_CBC128@PWRI_KEK@@2VAES_CBC128@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'PWRI_KEK::ke_AES_CBC128'', COMDAT
  00000	56		 push	 esi
  00001	be 00 00 00 00	 mov	 esi, OFFSET ?ke_AES_CBC128@PWRI_KEK@@2VAES_CBC128@@A ; PWRI_KEK::ke_AES_CBC128
  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ke_AES_CBC128@PWRI_KEK@@2VAES_CBC128@@A, OFFSET ??_7AES_CBC128@@6B@
  00010	e8 00 00 00 00	 call	 ??1AES_CBC@@QAE@XZ	; AES_CBC::~AES_CBC
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??__F?ke_AES_CBC128@PWRI_KEK@@2VAES_CBC128@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'PWRI_KEK::ke_AES_CBC128''
; Function compile flags: /Ogtpy
text$yd	ENDS
;	COMDAT ??__F?ke_TDES_CBC@PWRI_KEK@@2VDES_EDE3_CBC@@A@@YAXXZ
text$yd	SEGMENT
??__F?ke_TDES_CBC@PWRI_KEK@@2VDES_EDE3_CBC@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'PWRI_KEK::ke_TDES_CBC'', COMDAT
  00000	56		 push	 esi
  00001	be 00 00 00 00	 mov	 esi, OFFSET ?ke_TDES_CBC@PWRI_KEK@@2VDES_EDE3_CBC@@A ; PWRI_KEK::ke_TDES_CBC
  00006	e8 00 00 00 00	 call	 ??1DES_EDE3_CBC@@QAE@XZ	; DES_EDE3_CBC::~DES_EDE3_CBC
  0000b	5e		 pop	 esi
  0000c	c3		 ret	 0
??__F?ke_TDES_CBC@PWRI_KEK@@2VDES_EDE3_CBC@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'PWRI_KEK::ke_TDES_CBC''
PUBLIC	?ke_AES_CBC256@PWRI_KEK@@2VAES_CBC256@@A	; PWRI_KEK::ke_AES_CBC256
PUBLIC	?ke_AES_CBC192@PWRI_KEK@@2VAES_CBC192@@A	; PWRI_KEK::ke_AES_CBC192
PUBLIC	?ke_AES_CBC128@PWRI_KEK@@2VAES_CBC128@@A	; PWRI_KEK::ke_AES_CBC128
PUBLIC	?ke_TDES_CBC@PWRI_KEK@@2VDES_EDE3_CBC@@A	; PWRI_KEK::ke_TDES_CBC
PUBLIC	?ke_DES_CBC@PWRI_KEK@@2VDES_CBC@@A		; PWRI_KEK::ke_DES_CBC
?ke_AES_CBC256@PWRI_KEK@@2VAES_CBC256@@A DB 0220H DUP (?) ; PWRI_KEK::ke_AES_CBC256
?ke_AES_CBC192@PWRI_KEK@@2VAES_CBC192@@A DB 0220H DUP (?) ; PWRI_KEK::ke_AES_CBC192
?ke_AES_CBC128@PWRI_KEK@@2VAES_CBC128@@A DB 0220H DUP (?) ; PWRI_KEK::ke_AES_CBC128
?ke_TDES_CBC@PWRI_KEK@@2VDES_EDE3_CBC@@A DB 02a0H DUP (?) ; PWRI_KEK::ke_TDES_CBC
?ke_DES_CBC@PWRI_KEK@@2VDES_CBC@@A DB 01a0H DUP (?)	; PWRI_KEK::ke_DES_CBC
?ke_DES_CBC$initializer$@PWRI_KEK@@2P6AXXZA DD FLAT:??__E?ke_DES_CBC@PWRI_KEK@@2VDES_CBC@@A@@YAXXZ ; PWRI_KEK::ke_DES_CBC$initializer$
?ke_TDES_CBC$initializer$@PWRI_KEK@@2P6AXXZA DD FLAT:??__E?ke_TDES_CBC@PWRI_KEK@@2VDES_EDE3_CBC@@A@@YAXXZ ; PWRI_KEK::ke_TDES_CBC$initializer$
?ke_AES_CBC128$initializer$@PWRI_KEK@@2P6AXXZA DD FLAT:??__E?ke_AES_CBC128@PWRI_KEK@@2VAES_CBC128@@A@@YAXXZ ; PWRI_KEK::ke_AES_CBC128$initializer$
?ke_AES_CBC192$initializer$@PWRI_KEK@@2P6AXXZA DD FLAT:??__E?ke_AES_CBC192@PWRI_KEK@@2VAES_CBC192@@A@@YAXXZ ; PWRI_KEK::ke_AES_CBC192$initializer$
?ke_AES_CBC256$initializer$@PWRI_KEK@@2P6AXXZA DD FLAT:??__E?ke_AES_CBC256@PWRI_KEK@@2VAES_CBC256@@A@@YAXXZ ; PWRI_KEK::ke_AES_CBC256$initializer$
END

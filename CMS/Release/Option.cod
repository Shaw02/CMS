; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\?n????j\My Project\CMS\CMS\Option.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??_C@_0BO@FGFACEGB@Detect?5SSE2?5instruction?5sets?4?$AA@ ; `string'
PUBLIC	??_C@_0CA@PLKEFNGL@Detect?5AES?9NI?5instruction?5sets?4?$AA@ ; `string'
PUBLIC	??_C@_0BP@CIOEEPIA@SIMD?5instruction?5do?5not?5found?4?$AA@ ; `string'
PUBLIC	??_C@_04BDEACGK@?1T?$CFd?$AA@			; `string'
PUBLIC	??_C@_02ONHILPGA@?1T?$AA@			; `string'
PUBLIC	??_C@_04CMCFBKHP@?1M?$CFd?$AA@			; `string'
PUBLIC	??_C@_02HGHIBGHI@?1M?$AA@			; `string'
PUBLIC	??_C@_0BD@ECJIPPDP@?1W?5None?5pass?9word?4?$AA@	; `string'
PUBLIC	??_C@_0BH@CBPMFIGH@?1W?5Too?5many?5pass?5word?4?$AA@ ; `string'
PUBLIC	??_C@_0BD@INABCOHK@?1F?5None?5file?9name?4?$AA@	; `string'
PUBLIC	??_C@_03FKKADAIK@?4p7?$AA@			; `string'
PUBLIC	??_C@_0BO@HMGAGHIF@?1F?5Too?5many?5cipher?9file?9name?4?$AA@ ; `string'
PUBLIC	??_C@_04BLOKCCPB@?4key?$AA@			; `string'
PUBLIC	??_C@_0BI@ILHMDGBL@?1F?5Too?5many?5cipher?9key?4?$AA@ ; `string'
PUBLIC	??_C@_02JFIMMPLD@?1F?$AA@			; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_0BK@BHDOHMIE@Too?5many?5plain?9file?9name?4?$AA@ ; `string'
PUBLIC	??_C@_0CMP@FNKCBDKH@CMS?$IBiRFC?45652?5?$IB?$JF?5PKCS?$CD7?$IBjutility@ ; `string'
PUBLIC	??_C@_0BJ@OJODEHJ@?$IDI?$IDv?$IDV?$ID?$IH?$ID?$JD?$IC?$KK?$JFs?$JA?$LD?$IC?E?$IC?$LH?$IBB?$IBF?$AA@ ; `string'
EXTRN	_sscanf_s:PROC
EXTRN	?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cerr
;	COMDAT ??_C@_0BJ@OJODEHJ@?$IDI?$IDv?$IDV?$ID?$IH?$ID?$JD?$IC?$KK?$JFs?$JA?$LD?$IC?E?$IC?$LH?$IBB?$IBF?$AA@
CONST	SEGMENT
??_C@_0BJ@OJODEHJ@?$IDI?$IDv?$IDV?$ID?$IH?$ID?$JD?$IC?$KK?$JFs?$JA?$LD?$IC?E?$IC?$LH?$IBB?$IBF?$AA@ DB 083H
	DB	'I', 083H, 'v', 083H, 'V', 083H, 087H, 083H, 093H, 082H, 0aaH, 095H
	DB	's', 090H, 0b3H, 082H, 0c5H, 082H, 0b7H, 081H, 'B', 081H, 'F', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CMP@FNKCBDKH@CMS?$IBiRFC?45652?5?$IB?$JF?5PKCS?$CD7?$IBjutility@
CONST	SEGMENT
??_C@_0CMP@FNKCBDKH@CMS?$IBiRFC?45652?5?$IB?$JF?5PKCS?$CD7?$IBjutility@ DB 'C'
	DB	'MS', 081H, 'iRFC.5652 ', 081H, 095H, ' PKCS#7', 081H, 'jutili'
	DB	'ty', 0aH, 'Copyright (C) S.W. (A.Watanabe) 2011-2013', 0aH, 0aH
	DB	'CMS [ /options ] [filename]', 0aH, 0aH, '  --- Common option '
	DB	'---', 0aH, '  filename', 09H, 09H, 'File name of Plain-Text.', 0aH
	DB	'  /Fc[file(.p7 )]', 09H, 'File name of Cipher-Text. (Default '
	DB	'= [filename].p7)', 0aH, '  /Fk[file(.key)]', 09H, 'File name '
	DB	'of Cipher-Key. (Default = [filename].key)', 0aH, '  /W[PW]', 09H
	DB	09H, 'Cipher-Key is SHA-256 hash of this PW(Pass Word).', 0aH, ' '
	DB	' /H', 09H, 09H, 09H, 'help', 0aH, '  /T[n]', 09H, 09H, 09H, 'T'
	DB	'ype.', 0aH, 09H, 09H, 09H, '   3 : Enveloped Data(default)', 0aH
	DB	09H, 09H, 09H, '   6 : Encryption Data', 0aH, 0aH, '  --- Deci'
	DB	'pher option ---', 0aH, '  /D', 09H, 09H, 09H, 'Decipher (Defa'
	DB	'ult)', 0aH, 0aH, '  --- Encipher option ---', 0aH, '  /E', 09H
	DB	09H, 09H, 'Encipher', 0aH, '  /M[n]', 09H, 09H, 09H, 'Block ci'
	DB	'pher modes of operation.', 0aH, 09H, 09H, 09H, '   1 : DES-CB'
	DB	'C', 0aH, 09H, 09H, 09H, '   2 : 3-DES-CBC', 0aH, 09H, 09H, 09H
	DB	'   3 : AES-CBC 128-bit', 0aH, 09H, 09H, 09H, '   4 : AES-CBC '
	DB	'192-bit', 0aH, 09H, 09H, 09H, '   5 : AES-CBC 256-bit(default'
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BHDOHMIE@Too?5many?5plain?9file?9name?4?$AA@
CONST	SEGMENT
??_C@_0BK@BHDOHMIE@Too?5many?5plain?9file?9name?4?$AA@ DB 'Too many plain'
	DB	'-file-name.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JFIMMPLD@?1F?$AA@
CONST	SEGMENT
??_C@_02JFIMMPLD@?1F?$AA@ DB '/F', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ILHMDGBL@?1F?5Too?5many?5cipher?9key?4?$AA@
CONST	SEGMENT
??_C@_0BI@ILHMDGBL@?1F?5Too?5many?5cipher?9key?4?$AA@ DB '/F Too many cip'
	DB	'her-key.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04BLOKCCPB@?4key?$AA@
CONST	SEGMENT
??_C@_04BLOKCCPB@?4key?$AA@ DB '.key', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HMGAGHIF@?1F?5Too?5many?5cipher?9file?9name?4?$AA@
CONST	SEGMENT
??_C@_0BO@HMGAGHIF@?1F?5Too?5many?5cipher?9file?9name?4?$AA@ DB '/F Too m'
	DB	'any cipher-file-name.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FKKADAIK@?4p7?$AA@
CONST	SEGMENT
??_C@_03FKKADAIK@?4p7?$AA@ DB '.p7', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@INABCOHK@?1F?5None?5file?9name?4?$AA@
CONST	SEGMENT
??_C@_0BD@INABCOHK@?1F?5None?5file?9name?4?$AA@ DB '/F None file-name.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CBPMFIGH@?1W?5Too?5many?5pass?5word?4?$AA@
CONST	SEGMENT
??_C@_0BH@CBPMFIGH@?1W?5Too?5many?5pass?5word?4?$AA@ DB '/W Too many pass'
	DB	' word.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ECJIPPDP@?1W?5None?5pass?9word?4?$AA@
CONST	SEGMENT
??_C@_0BD@ECJIPPDP@?1W?5None?5pass?9word?4?$AA@ DB '/W None pass-word.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02HGHIBGHI@?1M?$AA@
CONST	SEGMENT
??_C@_02HGHIBGHI@?1M?$AA@ DB '/M', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CMCFBKHP@?1M?$CFd?$AA@
CONST	SEGMENT
??_C@_04CMCFBKHP@?1M?$CFd?$AA@ DB '/M%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02ONHILPGA@?1T?$AA@
CONST	SEGMENT
??_C@_02ONHILPGA@?1T?$AA@ DB '/T', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BDEACGK@?1T?$CFd?$AA@
CONST	SEGMENT
??_C@_04BDEACGK@?1T?$CFd?$AA@ DB '/T%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CIOEEPIA@SIMD?5instruction?5do?5not?5found?4?$AA@
CONST	SEGMENT
??_C@_0BP@CIOEEPIA@SIMD?5instruction?5do?5not?5found?4?$AA@ DB 'SIMD inst'
	DB	'ruction do not found.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PLKEFNGL@Detect?5AES?9NI?5instruction?5sets?4?$AA@
CONST	SEGMENT
??_C@_0CA@PLKEFNGL@Detect?5AES?9NI?5instruction?5sets?4?$AA@ DB 'Detect A'
	DB	'ES-NI instruction sets.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FGFACEGB@Detect?5SSE2?5instruction?5sets?4?$AA@
CONST	SEGMENT
??_C@_0BO@FGFACEGB@Detect?5SSE2?5instruction?5sets?4?$AA@ DB 'Detect SSE2'
	DB	' instruction sets.', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; __Ptr$ = edx

; 993  : 		_DEBUG_POINTER(_Ptr);
; 994  : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00000	8b c2		 mov	 eax, edx
  00002	56		 push	 esi
  00003	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL5@append@4:
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	40		 inc	 eax
  00009	84 c9		 test	 cl, cl
  0000b	75 f9		 jne	 SHORT $LL5@append@4
  0000d	2b c6		 sub	 eax, esi
  0000f	50		 push	 eax
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR _this$[esp+4]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0001a	5e		 pop	 esi

; 995  : 		}

  0001b	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx
; __Ch$ = eax

; 941  : 		return (append((size_type)1, _Ch));

  00000	50		 push	 eax
  00001	6a 01		 push	 1
  00003	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 942  : 		}

  00008	c3		 ret	 0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; __Ptr$ = edx

; 936  : 		return (append(_Ptr));

  00000	8b c2		 mov	 eax, edx
  00002	56		 push	 esi
  00003	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL7@operator@32:
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	40		 inc	 eax
  00009	84 c9		 test	 cl, cl
  0000b	75 f9		 jne	 SHORT $LL7@operator@32
  0000d	2b c6		 sub	 eax, esi
  0000f	50		 push	 eax
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR _this$[esp+4]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0001a	5e		 pop	 esi

; 937  : 		}

  0001b	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
PUBLIC	??1OPSW@@QAE@XZ					; OPSW::~OPSW
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\option.cpp
;	COMDAT ??1OPSW@@QAE@XZ
_TEXT	SEGMENT
??1OPSW@@QAE@XZ PROC					; OPSW::~OPSW, COMDAT
; _this$ = esi

; 257  : OPSW::~OPSW(){

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 258  : 
; 259  : };

  00002	bd 10 00 00 00	 mov	 ebp, 16			; 00000010H
  00007	57		 push	 edi
  00008	39 ae 80 00 00
	00		 cmp	 DWORD PTR [esi+128], ebp
  0000e	72 0c		 jb	 SHORT $LN19@OPSW
  00010	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00019	83 c4 04	 add	 esp, 4
$LN19@OPSW:
  0001c	33 db		 xor	 ebx, ebx
  0001e	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
  00023	89 be 80 00 00
	00		 mov	 DWORD PTR [esi+128], edi
  00029	89 5e 7c	 mov	 DWORD PTR [esi+124], ebx
  0002c	88 5e 6c	 mov	 BYTE PTR [esi+108], bl
  0002f	39 6e 64	 cmp	 DWORD PTR [esi+100], ebp
  00032	72 0c		 jb	 SHORT $LN45@OPSW
  00034	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003d	83 c4 04	 add	 esp, 4
$LN45@OPSW:
  00040	89 7e 64	 mov	 DWORD PTR [esi+100], edi
  00043	89 5e 60	 mov	 DWORD PTR [esi+96], ebx
  00046	88 5e 50	 mov	 BYTE PTR [esi+80], bl
  00049	39 6e 48	 cmp	 DWORD PTR [esi+72], ebp
  0004c	72 0c		 jb	 SHORT $LN71@OPSW
  0004e	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00057	83 c4 04	 add	 esp, 4
$LN71@OPSW:
  0005a	89 7e 48	 mov	 DWORD PTR [esi+72], edi
  0005d	89 5e 44	 mov	 DWORD PTR [esi+68], ebx
  00060	88 5e 34	 mov	 BYTE PTR [esi+52], bl
  00063	39 6e 2c	 cmp	 DWORD PTR [esi+44], ebp
  00066	72 0c		 jb	 SHORT $LN97@OPSW
  00068	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00071	83 c4 04	 add	 esp, 4
$LN97@OPSW:
  00074	89 7e 2c	 mov	 DWORD PTR [esi+44], edi
  00077	5f		 pop	 edi
  00078	89 5e 28	 mov	 DWORD PTR [esi+40], ebx
  0007b	5d		 pop	 ebp
  0007c	88 5e 18	 mov	 BYTE PTR [esi+24], bl
  0007f	5b		 pop	 ebx
  00080	c3		 ret	 0
??1OPSW@@QAE@XZ ENDP					; OPSW::~OPSW
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx
; __Right$ = eax

; 916  : 		return (assign(_Right));

  00000	6a ff		 push	 -1
  00002	6a 00		 push	 0
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 917  : 		}

  0000a	c3		 ret	 0
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?opError@OPSW@@QAEXPBD@Z			; OPSW::opError
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\option.cpp
;	COMDAT ?opError@OPSW@@QAEXPBD@Z
_TEXT	SEGMENT
?opError@OPSW@@QAEXPBD@Z PROC				; OPSW::opError, COMDAT
; _stErrMsg$ = eax

; 308  : void OPSW::opError(const char *stErrMsg){

  00000	51		 push	 ecx

; 309  : 
; 310  : 	cerr << "オプションが不正です。：" << stErrMsg << endl;

  00001	50		 push	 eax
  00002	51		 push	 ecx
  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@OJODEHJ@?$IDI?$IDv?$IDV?$ID?$IH?$ID?$JD?$IC?$KK?$JFs?$JA?$LD?$IC?E?$IC?$LH?$IBB?$IBF?$AA@
  00008	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  0000d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 311  : 	exit(EXIT_FAILURE);

  00024	6a 01		 push	 1
  00026	e8 00 00 00 00	 call	 _exit
$LN6@opError:
$LN5@opError:
  0002b	cc		 int	 3
?opError@OPSW@@QAEXPBD@Z ENDP				; OPSW::opError
_TEXT	ENDS
PUBLIC	?print_help@OPSW@@QAEXXZ			; OPSW::print_help
; Function compile flags: /Ogtpy
;	COMDAT ?print_help@OPSW@@QAEXXZ
_TEXT	SEGMENT
?print_help@OPSW@@QAEXXZ PROC				; OPSW::print_help, COMDAT

; 268  : void	OPSW::print_help(){

  00000	51		 push	 ecx

; 269  : 
; 270  : 	cout	<<	"CMS（RFC.5652 ＆ PKCS#7）utility\n"
; 271  : 				"Copyright (C) S.W. (A.Watanabe) 2011-2013\n"
; 272  : 				"\n"
; 273  : 				"CMS [ /options ] [filename]\n"
; 274  : 				"\n"
; 275  : 				"  --- Common option ---\n"
; 276  : 				"  filename		File name of Plain-Text.\n"
; 277  : 				"  /Fc[file(.p7 )]	File name of Cipher-Text. (Default = [filename].p7)\n"
; 278  : 				"  /Fk[file(.key)]	File name of Cipher-Key. (Default = [filename].key)\n"
; 279  : 				"  /W[PW]		Cipher-Key is SHA-256 hash of this PW(Pass Word).\n"
; 280  : 				"  /H			help\n"
; 281  : 				"  /T[n]			Type.\n"
; 282  : 				"			   3 : Enveloped Data(default)\n"
; 283  : 				"			   6 : Encryption Data\n"
; 284  : 				"\n"
; 285  : 				"  --- Decipher option ---\n"
; 286  : 				"  /D			Decipher (Default)\n"
; 287  : 				"\n"
; 288  : 				"  --- Encipher option ---\n"
; 289  : 				"  /E			Encipher\n"
; 290  : 				"  /M[n]			Block cipher modes of operation.\n"
; 291  : 				"			   1 : DES-CBC\n"
; 292  : 				"			   2 : 3-DES-CBC\n"
; 293  : 				"			   3 : AES-CBC 128-bit\n"
; 294  : 				"			   4 : AES-CBC 192-bit\n"
; 295  : 				"			   5 : AES-CBC 256-bit(default)\n" << endl;

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_0CMP@FNKCBDKH@CMS?$IBiRFC?45652?5?$IB?$JF?5PKCS?$CD7?$IBjutility@
  00006	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  0000b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 296  : 
; 297  : 	exit(EXIT_SUCCESS);

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 _exit
$LN6@print_help:
$LN5@print_help:
  00020	cc		 int	 3
?print_help@OPSW@@QAEXXZ ENDP				; OPSW::print_help
_TEXT	ENDS
PUBLIC	??0OPSW@@QAE@HQAPAD@Z				; OPSW::OPSW
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$??0OPSW@@QAE@HQAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0OPSW@@QAE@HQAPAD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0OPSW@@QAE@HQAPAD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0OPSW@@QAE@HQAPAD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0OPSW@@QAE@HQAPAD@Z$3
__ehfuncinfo$??0OPSW@@QAE@HQAPAD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0OPSW@@QAE@HQAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\option.cpp
xdata$x	ENDS
;	COMDAT ??0OPSW@@QAE@HQAPAD@Z
_TEXT	SEGMENT
_iCount$ = -28						; size = 4
_cOption$ = -24						; size = 1
_iOptionChk$ = -20					; size = 4
tv1383 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_argc$ = 12						; size = 4
_argv$ = 16						; size = 4
_iFlagFilnameExt$ = 19					; size = 1
??0OPSW@@QAE@HQAPAD@Z PROC				; OPSW::OPSW, COMDAT

; 22   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0OPSW@@QAE@HQAPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  0002b	33 c0		 xor	 eax, eax
  0002d	c7 46 04 05 00
	00 00		 mov	 DWORD PTR [esi+4], 5
  00034	c7 46 08 03 00
	00 00		 mov	 DWORD PTR [esi+8], 3
  0003b	c7 46 0c e8 03
	00 00		 mov	 DWORD PTR [esi+12], 1000 ; 000003e8H
  00042	c6 46 10 01	 mov	 BYTE PTR [esi+16], 1
  00046	88 46 11	 mov	 BYTE PTR [esi+17], al
  00049	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  0004e	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  00051	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00054	88 46 18	 mov	 BYTE PTR [esi+24], al
  00057	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  0005a	89 4e 48	 mov	 DWORD PTR [esi+72], ecx
  0005d	89 46 44	 mov	 DWORD PTR [esi+68], eax
  00060	88 46 34	 mov	 BYTE PTR [esi+52], al
  00063	89 4e 64	 mov	 DWORD PTR [esi+100], ecx
  00066	89 46 60	 mov	 DWORD PTR [esi+96], eax
  00069	88 46 50	 mov	 BYTE PTR [esi+80], al
  0006c	89 8e 80 00 00
	00		 mov	 DWORD PTR [esi+128], ecx
  00072	89 46 7c	 mov	 DWORD PTR [esi+124], eax
  00075	88 46 6c	 mov	 BYTE PTR [esi+108], al
  00078	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 23   : 
; 24   : 	//----------------------------------
; 25   : 	//■Local 変数
; 26   : 	int		iCount;				//whileのカウント用
; 27   : 	int		iResult;
; 28   : 
; 29   : 	//Option処理用
; 30   : 	int		iOptionChk;			//オプションチェック用　ポインタ
; 31   : 	char	cOption;			//オプションチェック用　文字
; 32   : 	char	iFlagFilnameExt;	//拡張子あったかのフラグ
; 33   : 
; 34   : 	//----------------------------------------------------
; 35   : 	//SIMD命令のチェック
; 36   : 	fSIMD = ChkSIMD();

  0007c	53		 push	 ebx
  0007d	51		 push	 ecx
  0007e	52		 push	 edx
  0007f	b8 01 00 00 00	 mov	 eax, 1
  00084	0f a2		 cpuid
  00086	f7 c1 00 00 00
	02		 test	 ecx, 33554432		; 02000000H
  0008c	75 16		 jne	 SHORT $ChkSIMD_AESNI$102122
  0008e	f7 c2 00 00 00
	04		 test	 edx, 67108864		; 04000000H
  00094	75 07		 jne	 SHORT $ChkSIMD_SSE2$102123
  00096	b8 00 00 00 00	 mov	 eax, 0
  0009b	eb 0c		 jmp	 SHORT $ChkSIMD_END$102124
$ChkSIMD_SSE2$102123:
  0009d	b8 01 00 00 00	 mov	 eax, 1
  000a2	eb 05		 jmp	 SHORT $ChkSIMD_END$102124
$ChkSIMD_AESNI$102122:
  000a4	b8 02 00 00 00	 mov	 eax, 2
$ChkSIMD_END$102124:
  000a9	5a		 pop	 edx
  000aa	59		 pop	 ecx
  000ab	5b		 pop	 ebx

; 37   : 	switch(fSIMD){

  000ac	bf 01 00 00 00	 mov	 edi, 1
  000b1	89 06		 mov	 DWORD PTR [esi], eax
  000b3	2b c7		 sub	 eax, edi
  000b5	74 2a		 je	 SHORT $LN55@OPSW@2
  000b7	2b c7		 sub	 eax, edi
  000b9	74 1f		 je	 SHORT $LN54@OPSW@2

; 44   : 		default:
; 45   : 			cout << "SIMD instruction do not found." << endl;

  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@CIOEEPIA@SIMD?5instruction?5do?5not?5found?4?$AA@
  000c0	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  000c5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 46   : 			exit(-1);

  000d3	6a ff		 push	 -1
  000d5	e8 00 00 00 00	 call	 _exit
$LN437@OPSW@2:
$LN54@OPSW@2:

; 40   : 			break;
; 41   : 		case(2):
; 42   : 			cout << "Detect AES-NI instruction sets." << endl;

  000da	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@PLKEFNGL@Detect?5AES?9NI?5instruction?5sets?4?$AA@

; 43   : 			break;

  000df	eb 05		 jmp	 SHORT $LN432@OPSW@2
$LN55@OPSW@2:

; 38   : 		case(1):
; 39   : 			cout << "Detect SSE2 instruction sets." << endl;

  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FGFACEGB@Detect?5SSE2?5instruction?5sets?4?$AA@
$LN432@OPSW@2:
  000e6	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  000eb	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
  000f6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 47   : 			break;
; 48   : 	}
; 49   : 
; 50   : 	//----------------------------------
; 51   : 	//■オプション処理
; 52   : 	iCount=1;	//コマンド名は飛ばす

  000f9	89 7d e4	 mov	 DWORD PTR _iCount$[ebp], edi

; 53   : 	while(iCount!=argc)

  000fc	39 7d 0c	 cmp	 DWORD PTR _argc$[ebp], edi
  000ff	0f 84 49 03 00
	00		 je	 $LN51@OPSW@2
  00105	8b 45 10	 mov	 eax, DWORD PTR _argv$[ebp]
  00108	83 c0 04	 add	 eax, 4
  0010b	89 45 f0	 mov	 DWORD PTR tv1383[ebp], eax
  0010e	8b ff		 npad	 2
$LL52@OPSW@2:

; 54   : 	{
; 55   : 		//--------------
; 56   : 		//オプションスイッチにスラッシュがあるか確認
; 57   : 		if((argv[iCount][0]=='/')||(argv[iCount][0]=='-')){

  00110	8b 4d f0	 mov	 ecx, DWORD PTR tv1383[ebp]
  00113	8b 01		 mov	 eax, DWORD PTR [ecx]
  00115	8a 08		 mov	 cl, BYTE PTR [eax]
  00117	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  0011a	0f 84 e7 00 00
	00		 je	 $LN49@OPSW@2
  00120	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  00123	0f 84 de 00 00
	00		 je	 $LN49@OPSW@2

; 183  : 					break;
; 184  : 			};
; 185  : 
; 186  : 		} else{
; 187  : 
; 188  : 			//--------------
; 189  : 			//◆ファイル名	（スラッシュが無かった場合の処理）
; 190  : 			//既に指定されている？
; 191  : 			if(strBINname.empty()){

  00129	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0012c	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  00130	0f 85 88 03 00
	00		 jne	 $LN10@OPSW@2

; 192  : 				iFlagFilnameExt=0;		//拡張子の有無　Reset
; 193  : 				iOptionChk=0;		
; 194  : 				while((cOption=argv[iCount][iOptionChk])!=0)

  00136	8a d9		 mov	 bl, cl
  00138	c6 45 13 00	 mov	 BYTE PTR _iFlagFilnameExt$[ebp], 0
  0013c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iOptionChk$[ebp], 0
  00143	84 db		 test	 bl, bl
  00145	0f 84 aa 00 00
	00		 je	 $LN424@OPSW@2
  0014b	eb 03 8d 49 00	 npad	 5
$LL9@OPSW@2:

; 195  : 				{
; 196  : 					strBINname+=cOption;

  00150	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  00153	83 c8 ff	 or	 eax, -1
  00156	2b 47 28	 sub	 eax, DWORD PTR [edi+40]
  00159	83 c7 14	 add	 edi, 20			; 00000014H
  0015c	83 f8 01	 cmp	 eax, 1
  0015f	77 05		 ja	 SHORT $LN307@OPSW@2
  00161	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN307@OPSW@2:
  00166	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  00169	46		 inc	 esi
  0016a	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0016d	76 05		 jbe	 SHORT $LN315@OPSW@2
  0016f	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN315@OPSW@2:
  00174	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00177	3b c6		 cmp	 eax, esi
  00179	73 20		 jae	 SHORT $LN314@OPSW@2
  0017b	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  0017e	51		 push	 ecx
  0017f	56		 push	 esi
  00180	8b cf		 mov	 ecx, edi
  00182	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00187	85 f6		 test	 esi, esi
$LN433@OPSW@2:
  00189	76 40		 jbe	 SHORT $LN382@OPSW@2
  0018b	83 7f 18 10	 cmp	 DWORD PTR [edi+24], 16	; 00000010H
  0018f	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00192	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00195	72 20		 jb	 SHORT $LN366@OPSW@2
  00197	8b 08		 mov	 ecx, DWORD PTR [eax]
  00199	eb 1e		 jmp	 SHORT $LN367@OPSW@2
$LN314@OPSW@2:
  0019b	85 f6		 test	 esi, esi
  0019d	75 ea		 jne	 SHORT $LN433@OPSW@2
  0019f	89 77 14	 mov	 DWORD PTR [edi+20], esi
  001a2	83 f8 10	 cmp	 eax, 16			; 00000010H
  001a5	72 08		 jb	 SHORT $LN356@OPSW@2
  001a7	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  001aa	c6 07 00	 mov	 BYTE PTR [edi], 0
  001ad	eb 1c		 jmp	 SHORT $LN382@OPSW@2
$LN356@OPSW@2:
  001af	83 c7 04	 add	 edi, 4
  001b2	c6 07 00	 mov	 BYTE PTR [edi], 0
  001b5	eb 14		 jmp	 SHORT $LN382@OPSW@2
$LN366@OPSW@2:
  001b7	8b c8		 mov	 ecx, eax
$LN367@OPSW@2:
  001b9	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  001bc	83 7f 18 10	 cmp	 DWORD PTR [edi+24], 16	; 00000010H
  001c0	89 77 14	 mov	 DWORD PTR [edi+20], esi
  001c3	72 02		 jb	 SHORT $LN380@OPSW@2
  001c5	8b 00		 mov	 eax, DWORD PTR [eax]
$LN380@OPSW@2:
  001c7	c6 04 30 00	 mov	 BYTE PTR [eax+esi], 0
$LN382@OPSW@2:

; 197  : 					if(cOption=='.'){iFlagFilnameExt=1;};

  001cb	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001ce	75 04		 jne	 SHORT $LN7@OPSW@2
  001d0	c6 45 13 01	 mov	 BYTE PTR _iFlagFilnameExt$[ebp], 1
$LN7@OPSW@2:

; 198  : 					iOptionChk++;

  001d4	8b 45 ec	 mov	 eax, DWORD PTR _iOptionChk$[ebp]
  001d7	8b 55 f0	 mov	 edx, DWORD PTR tv1383[ebp]
  001da	8b 0a		 mov	 ecx, DWORD PTR [edx]
  001dc	8a 5c 08 01	 mov	 bl, BYTE PTR [eax+ecx+1]
  001e0	40		 inc	 eax
  001e1	89 45 ec	 mov	 DWORD PTR _iOptionChk$[ebp], eax
  001e4	84 db		 test	 bl, bl
  001e6	0f 85 64 ff ff
	ff		 jne	 $LL9@OPSW@2

; 199  : 				};
; 200  : 				if(iFlagFilnameExt==0){

  001ec	38 5d 13	 cmp	 BYTE PTR _iFlagFilnameExt$[ebp], bl
  001ef	0f 85 42 02 00
	00		 jne	 $LN286@OPSW@2
$LN424@OPSW@2:

; 201  : 					strBINname+=".";

  001f5	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001f8	6a 01		 push	 1
  001fa	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4?$AA@
  001ff	83 c0 14	 add	 eax, 20			; 00000014H

; 202  : 				};
; 203  : 			} else {

  00202	e9 2b 02 00 00	 jmp	 $LN434@OPSW@2
$LN49@OPSW@2:

; 58   : 
; 59   : 			//--------------
; 60   : 			//◆Option Switch	（スラッシュがあった場合の処理）
; 61   : 			switch(argv[iCount][1]){

  00207	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  0020b	83 c1 c1	 add	 ecx, -63		; ffffffc1H
  0020e	83 f9 38	 cmp	 ecx, 56			; 00000038H
  00211	0f 87 ed 02 00
	00		 ja	 $LN12@OPSW@2
  00217	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN427@OPSW@2[ecx]
  0021e	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN436@OPSW@2[edx*4]
$LN46@OPSW@2:

; 62   : 				//--------
; 63   : 				//Help表示
; 64   : 				case 'h' :
; 65   : 				case 'H' :
; 66   : 				case '?' :
; 67   : 					fHelp=1;

  00225	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00228	c6 40 11 01	 mov	 BYTE PTR [eax+17], 1

; 68   : 					break;

  0022c	e9 06 02 00 00	 jmp	 $LN286@OPSW@2
$LN45@OPSW@2:

; 69   : 				//--------
; 70   : 				//Decode
; 71   : 				case 'd' :
; 72   : 				case 'D' :
; 73   : 					cDecipher = 1;

  00231	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00234	c6 41 10 01	 mov	 BYTE PTR [ecx+16], 1

; 74   : 					break;

  00238	e9 fa 01 00 00	 jmp	 $LN286@OPSW@2
$LN44@OPSW@2:

; 75   : 				//--------
; 76   : 				//Decode
; 77   : 				case 'e' :
; 78   : 				case 'E' :
; 79   : 					cDecipher = 0;

  0023d	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00240	c6 42 10 00	 mov	 BYTE PTR [edx+16], 0

; 80   : 					break;

  00244	e9 ee 01 00 00	 jmp	 $LN286@OPSW@2
$LN43@OPSW@2:

; 81   : 				//--------
; 82   : 				//ファイルの指定
; 83   : 				case 'T' :
; 84   : 					iResult=sscanf_s(argv[iCount],"/T%d",&iType);

  00249	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0024c	83 c1 08	 add	 ecx, 8
  0024f	51		 push	 ecx
  00250	68 00 00 00 00	 push	 OFFSET ??_C@_04BDEACGK@?1T?$CFd?$AA@
  00255	50		 push	 eax
  00256	e8 00 00 00 00	 call	 _sscanf_s
  0025b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 85   : 					if((iResult==NULL)||(iResult==EOF)){

  0025e	85 c0		 test	 eax, eax
  00260	74 09		 je	 SHORT $LN414@OPSW@2
  00262	83 f8 ff	 cmp	 eax, -1
  00265	0f 85 cc 01 00
	00		 jne	 $LN286@OPSW@2
$LN414@OPSW@2:

; 86   : 						opError("/T");

  0026b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_02ONHILPGA@?1T?$AA@
  00270	e8 00 00 00 00	 call	 ?opError@OPSW@@QAEXPBD@Z ; OPSW::opError
$LN438@OPSW@2:
$LN40@OPSW@2:

; 87   : 						break;
; 88   : 					};
; 89   : 					break;
; 90   : 				//--------
; 91   : 				//鍵の指定
; 92   : 				case 'M' :
; 93   : 					iResult=sscanf_s(argv[iCount],"/M%d",&iMode);

  00275	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00278	83 c1 04	 add	 ecx, 4
  0027b	51		 push	 ecx
  0027c	68 00 00 00 00	 push	 OFFSET ??_C@_04CMCFBKHP@?1M?$CFd?$AA@
  00281	50		 push	 eax
  00282	e8 00 00 00 00	 call	 _sscanf_s
  00287	83 c4 0c	 add	 esp, 12			; 0000000cH

; 94   : 					if((iResult==NULL)||(iResult==EOF)){

  0028a	85 c0		 test	 eax, eax
  0028c	74 09		 je	 SHORT $LN415@OPSW@2
  0028e	83 f8 ff	 cmp	 eax, -1
  00291	0f 85 a0 01 00
	00		 jne	 $LN286@OPSW@2
$LN415@OPSW@2:

; 95   : 						opError("/M");

  00297	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_02HGHIBGHI@?1M?$AA@
  0029c	e8 00 00 00 00	 call	 ?opError@OPSW@@QAEXPBD@Z ; OPSW::opError
$LN439@OPSW@2:
$LN37@OPSW@2:

; 96   : 						break;
; 97   : 					};
; 98   : 					break;
; 99   : 				//--------
; 100  : 				//パスワードの指定
; 101  : 				case 'w' :
; 102  : 				case 'W' :
; 103  : 					//先に、キーワードが書いてあるかチェック。
; 104  : 					if(argv[iCount][2]==0){

  002a1	8a 40 02	 mov	 al, BYTE PTR [eax+2]
  002a4	84 c0		 test	 al, al
  002a6	0f 84 1c 02 00
	00		 je	 $LN416@OPSW@2

; 106  : 						break;
; 107  : 					};
; 108  : 					//既に指定されている？
; 109  : 					if(strKeyWord.empty()){

  002ac	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002af	83 79 7c 00	 cmp	 DWORD PTR [ecx+124], 0
  002b3	0f 85 19 02 00
	00		 jne	 $LN35@OPSW@2

; 110  : 						iOptionChk=0;

  002b9	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iOptionChk$[ebp], 0

; 111  : 						while((cOption=argv[iCount][iOptionChk+2])!=0)

  002c0	8a d8		 mov	 bl, al
$LL34@OPSW@2:

; 112  : 						{
; 113  : 							strKeyWord+=cOption;

  002c2	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  002c5	83 ca ff	 or	 edx, -1
  002c8	2b 57 7c	 sub	 edx, DWORD PTR [edi+124]
  002cb	83 c7 68	 add	 edi, 104		; 00000068H
  002ce	83 fa 01	 cmp	 edx, 1
  002d1	77 05		 ja	 SHORT $LN205@OPSW@2
  002d3	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN205@OPSW@2:
  002d8	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  002db	46		 inc	 esi
  002dc	83 fe fe	 cmp	 esi, -2			; fffffffeH
  002df	76 05		 jbe	 SHORT $LN213@OPSW@2
  002e1	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@SAXXZ ; std::_String_base::_Xlen
$LN213@OPSW@2:
  002e6	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  002e9	3b c6		 cmp	 eax, esi
  002eb	73 26		 jae	 SHORT $LN212@OPSW@2
  002ed	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  002f0	50		 push	 eax
  002f1	56		 push	 esi
  002f2	8b cf		 mov	 ecx, edi
  002f4	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  002f9	85 f6		 test	 esi, esi
$LN435@OPSW@2:
  002fb	76 46		 jbe	 SHORT $LN280@OPSW@2
  002fd	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00300	8b 7a 7c	 mov	 edi, DWORD PTR [edx+124]
  00303	83 c2 68	 add	 edx, 104		; 00000068H
  00306	83 7a 18 10	 cmp	 DWORD PTR [edx+24], 16	; 00000010H
  0030a	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  0030d	72 20		 jb	 SHORT $LN264@OPSW@2
  0030f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00311	eb 1e		 jmp	 SHORT $LN265@OPSW@2
$LN212@OPSW@2:
  00313	85 f6		 test	 esi, esi
  00315	75 e4		 jne	 SHORT $LN435@OPSW@2
  00317	89 77 14	 mov	 DWORD PTR [edi+20], esi
  0031a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0031d	72 08		 jb	 SHORT $LN254@OPSW@2
  0031f	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  00322	c6 07 00	 mov	 BYTE PTR [edi], 0
  00325	eb 1c		 jmp	 SHORT $LN280@OPSW@2
$LN254@OPSW@2:
  00327	83 c7 04	 add	 edi, 4
  0032a	c6 07 00	 mov	 BYTE PTR [edi], 0
  0032d	eb 14		 jmp	 SHORT $LN280@OPSW@2
$LN264@OPSW@2:
  0032f	8b c8		 mov	 ecx, eax
$LN265@OPSW@2:
  00331	88 1c 39	 mov	 BYTE PTR [ecx+edi], bl
  00334	83 7a 18 10	 cmp	 DWORD PTR [edx+24], 16	; 00000010H
  00338	89 72 14	 mov	 DWORD PTR [edx+20], esi
  0033b	72 02		 jb	 SHORT $LN278@OPSW@2
  0033d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN278@OPSW@2:
  0033f	c6 04 30 00	 mov	 BYTE PTR [eax+esi], 0
$LN280@OPSW@2:

; 114  : 							iOptionChk++;

  00343	8b 45 ec	 mov	 eax, DWORD PTR _iOptionChk$[ebp]
  00346	8b 4d f0	 mov	 ecx, DWORD PTR tv1383[ebp]
  00349	8b 11		 mov	 edx, DWORD PTR [ecx]
  0034b	8a 5c 02 03	 mov	 bl, BYTE PTR [edx+eax+3]
  0034f	40		 inc	 eax
  00350	89 45 ec	 mov	 DWORD PTR _iOptionChk$[ebp], eax
  00353	84 db		 test	 bl, bl
  00355	0f 85 67 ff ff
	ff		 jne	 $LL34@OPSW@2

; 118  : 						break;
; 119  : 					};
; 120  : 					break;

  0035b	e9 d7 00 00 00	 jmp	 $LN286@OPSW@2
$LN31@OPSW@2:

; 121  : 				//--------
; 122  : 				//ファイルの指定
; 123  : 				case 'f' :
; 124  : 				case 'F' :
; 125  : 					//先に、ファイル名が書いてあるかチェック。
; 126  : 					if(argv[iCount][3]==0){

  00360	8a 58 03	 mov	 bl, BYTE PTR [eax+3]
  00363	84 db		 test	 bl, bl
  00365	0f 84 71 01 00
	00		 je	 $LN417@OPSW@2

; 128  : 						break;
; 129  : 					};
; 130  : 					switch(argv[iCount][2]){

  0036b	8a 40 02	 mov	 al, BYTE PTR [eax+2]
  0036e	3c 63		 cmp	 al, 99			; 00000063H
  00370	74 6f		 je	 SHORT $LN27@OPSW@2
  00372	3c 6b		 cmp	 al, 107			; 0000006bH
  00374	0f 85 6c 01 00
	00		 jne	 $LN418@OPSW@2

; 149  : 								break;
; 150  : 							};
; 151  : 							break;
; 152  : 						//--------
; 153  : 						//暗号鍵ファイルの指定
; 154  : 						case 'k' :
; 155  : 							//既に指定されている？
; 156  : 							if(strKEYname.empty()){

  0037a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0037d	83 78 60 00	 cmp	 DWORD PTR [eax+96], 0
  00381	0f 85 69 01 00
	00		 jne	 $LN19@OPSW@2

; 157  : 								iMode = -1;				//鍵が指定された。
; 158  : 								iFlagFilnameExt=0;		//拡張子の有無　Reset
; 159  : 								iOptionChk=0;
; 160  : 								while((cOption=argv[iCount][iOptionChk+3])!=0)

  00387	8b 4d f0	 mov	 ecx, DWORD PTR tv1383[ebp]
  0038a	8b f8		 mov	 edi, eax
  0038c	c7 47 04 ff ff
	ff ff		 mov	 DWORD PTR [edi+4], -1
  00393	8b 11		 mov	 edx, DWORD PTR [ecx]
  00395	8a 5a 03	 mov	 bl, BYTE PTR [edx+3]
  00398	33 f6		 xor	 esi, esi
  0039a	c6 45 13 00	 mov	 BYTE PTR _iFlagFilnameExt$[ebp], 0
  0039e	88 5d e8	 mov	 BYTE PTR _cOption$[ebp], bl
  003a1	84 db		 test	 bl, bl
  003a3	74 30		 je	 SHORT $LN425@OPSW@2
$LL18@OPSW@2:

; 161  : 								{
; 162  : 									strKEYname+=cOption;

  003a5	8b 45 e8	 mov	 eax, DWORD PTR _cOption$[ebp]
  003a8	50		 push	 eax
  003a9	6a 01		 push	 1
  003ab	8d 4f 4c	 lea	 ecx, DWORD PTR [edi+76]
  003ae	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 163  : 									if(cOption=='.'){iFlagFilnameExt=1;};

  003b3	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  003b6	75 04		 jne	 SHORT $LN16@OPSW@2
  003b8	c6 45 13 01	 mov	 BYTE PTR _iFlagFilnameExt$[ebp], 1
$LN16@OPSW@2:

; 157  : 								iMode = -1;				//鍵が指定された。
; 158  : 								iFlagFilnameExt=0;		//拡張子の有無　Reset
; 159  : 								iOptionChk=0;
; 160  : 								while((cOption=argv[iCount][iOptionChk+3])!=0)

  003bc	8b 4d f0	 mov	 ecx, DWORD PTR tv1383[ebp]
  003bf	8b 11		 mov	 edx, DWORD PTR [ecx]
  003c1	8a 5c 32 04	 mov	 bl, BYTE PTR [edx+esi+4]

; 164  : 									iOptionChk++;

  003c5	46		 inc	 esi
  003c6	88 5d e8	 mov	 BYTE PTR _cOption$[ebp], bl
  003c9	84 db		 test	 bl, bl
  003cb	75 d8		 jne	 SHORT $LL18@OPSW@2

; 165  : 								};
; 166  : 								if(iFlagFilnameExt==0){

  003cd	38 5d 13	 cmp	 BYTE PTR _iFlagFilnameExt$[ebp], bl
  003d0	75 65		 jne	 SHORT $LN286@OPSW@2
  003d2	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
$LN425@OPSW@2:

; 167  : 									strKEYname+=".key";

  003d5	6a 04		 push	 4
  003d7	68 00 00 00 00	 push	 OFFSET ??_C@_04BLOKCCPB@?4key?$AA@
  003dc	8d 47 4c	 lea	 eax, DWORD PTR [edi+76]

; 171  : 								break;
; 172  : 							};
; 173  : 							break;

  003df	eb 51		 jmp	 SHORT $LN434@OPSW@2
$LN27@OPSW@2:

; 131  : 						//--------
; 132  : 						//暗号文ファイルの指定
; 133  : 						case 'c' :
; 134  : 							//既に指定されている？
; 135  : 							if(strAESname.empty()){

  003e1	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  003e4	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  003e8	0f 85 0c 01 00
	00		 jne	 $LN26@OPSW@2

; 136  : 								iFlagFilnameExt=0;		//拡張子の有無　Reset

  003ee	c6 45 13 00	 mov	 BYTE PTR _iFlagFilnameExt$[ebp], 0

; 137  : 								iOptionChk=0;

  003f2	33 f6		 xor	 esi, esi

; 138  : 								while((cOption=argv[iCount][iOptionChk+3])!=0)

  003f4	88 5d e8	 mov	 BYTE PTR _cOption$[ebp], bl
$LL25@OPSW@2:

; 139  : 								{
; 140  : 									strAESname+=cOption;

  003f7	8b 4d e8	 mov	 ecx, DWORD PTR _cOption$[ebp]
  003fa	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  003fd	51		 push	 ecx
  003fe	83 c7 30	 add	 edi, 48			; 00000030H
  00401	6a 01		 push	 1
  00403	8b cf		 mov	 ecx, edi
  00405	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 141  : 									if(cOption=='.'){iFlagFilnameExt=1;};

  0040a	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  0040d	75 04		 jne	 SHORT $LN23@OPSW@2
  0040f	c6 45 13 01	 mov	 BYTE PTR _iFlagFilnameExt$[ebp], 1
$LN23@OPSW@2:

; 138  : 								while((cOption=argv[iCount][iOptionChk+3])!=0)

  00413	8b 55 f0	 mov	 edx, DWORD PTR tv1383[ebp]
  00416	8b 02		 mov	 eax, DWORD PTR [edx]
  00418	8a 5c 30 04	 mov	 bl, BYTE PTR [eax+esi+4]

; 142  : 									iOptionChk++;

  0041c	46		 inc	 esi
  0041d	88 5d e8	 mov	 BYTE PTR _cOption$[ebp], bl
  00420	84 db		 test	 bl, bl
  00422	75 d3		 jne	 SHORT $LL25@OPSW@2

; 143  : 								};
; 144  : 								if(iFlagFilnameExt==0){

  00424	38 5d 13	 cmp	 BYTE PTR _iFlagFilnameExt$[ebp], bl
  00427	75 0e		 jne	 SHORT $LN286@OPSW@2

; 145  : 									strAESname+=".p7";

  00429	6a 03		 push	 3
  0042b	68 00 00 00 00	 push	 OFFSET ??_C@_03FKKADAIK@?4p7?$AA@
  00430	8b c7		 mov	 eax, edi
$LN434@OPSW@2:
  00432	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN286@OPSW@2:

; 205  : 				break;
; 206  : 			};
; 207  : 
; 208  : 		};
; 209  : 
; 210  : 		//--------------
; 211  : 		//◆次のオプション
; 212  : 		iCount++;

  00437	8b 45 e4	 mov	 eax, DWORD PTR _iCount$[ebp]
  0043a	83 45 f0 04	 add	 DWORD PTR tv1383[ebp], 4
  0043e	40		 inc	 eax
  0043f	89 45 e4	 mov	 DWORD PTR _iCount$[ebp], eax
  00442	3b 45 0c	 cmp	 eax, DWORD PTR _argc$[ebp]
  00445	0f 85 c5 fc ff
	ff		 jne	 $LL52@OPSW@2

; 128  : 						break;
; 129  : 					};
; 130  : 					switch(argv[iCount][2]){

  0044b	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
$LN51@OPSW@2:

; 213  : 	};
; 214  : 
; 215  : 	//----------------------------------
; 216  : 	//◆オプションで指定された事を処理する。
; 217  : 
; 218  : 	//--------------
; 219  : 	//ヘルプ表示
; 220  : 	//ファイル名が書かれなかった場合も、ヘルプを表示する。
; 221  : 	if((fHelp==1)||(strBINname.empty())){print_help();};

  0044e	80 7e 11 01	 cmp	 BYTE PTR [esi+17], 1
  00452	0f 84 b6 00 00
	00		 je	 $LN3@OPSW@2
  00458	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  0045c	0f 84 ac 00 00
	00		 je	 $LN3@OPSW@2

; 222  : 
; 223  : 	//--------------
; 224  : 	//出力ファイルの指定が無かった場合
; 225  : 	if(strAESname.empty()){

  00462	83 7e 44 00	 cmp	 DWORD PTR [esi+68], 0
  00466	75 1d		 jne	 SHORT $LN2@OPSW@2

; 226  : 		strAESname = strBINname;

  00468	6a ff		 push	 -1
  0046a	6a 00		 push	 0
  0046c	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  0046f	8d 7e 30	 lea	 edi, DWORD PTR [esi+48]
  00472	50		 push	 eax
  00473	8b cf		 mov	 ecx, edi
  00475	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 227  : 		strAESname+=".p7";

  0047a	57		 push	 edi
  0047b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_03FKKADAIK@?4p7?$AA@
  00480	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN2@OPSW@2:

; 228  : 	};
; 229  : 
; 230  : 	//--------------
; 231  : 	// 鍵 ファイルの指定が無かった場合
; 232  : 	if(strKEYname.empty()){

  00485	83 7e 60 00	 cmp	 DWORD PTR [esi+96], 0
  00489	75 1d		 jne	 SHORT $LN1@OPSW@2

; 233  : 		strKEYname = strBINname;

  0048b	6a ff		 push	 -1
  0048d	6a 00		 push	 0
  0048f	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00492	8d 7e 4c	 lea	 edi, DWORD PTR [esi+76]
  00495	50		 push	 eax
  00496	8b cf		 mov	 ecx, edi
  00498	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 234  : 		strKEYname+=".key";

  0049d	57		 push	 edi
  0049e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04BLOKCCPB@?4key?$AA@
  004a3	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN1@OPSW@2:

; 235  : 	};
; 236  : 
; 237  : 	//--------------
; 238  : 	//
; 239  : 
; 240  : 	//	to do	その他のオプションを追加したときは、この辺に追記する。
; 241  : 
; 242  : 	//----------
; 243  : 	//Debug用 表示
; 244  : //	cout << "Plain-Text	= " << strBINname << endl;
; 245  : //	cout << "Chiper-Text	= " << strAESname << endl;
; 246  : //	cout << "Chiper-Key	= " << strKEYname << endl;
; 247  : 
; 248  : };

  004a8	8b c6		 mov	 eax, esi
  004aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004b4	59		 pop	 ecx
  004b5	5f		 pop	 edi
  004b6	5e		 pop	 esi
  004b7	5b		 pop	 ebx
  004b8	8b e5		 mov	 esp, ebp
  004ba	5d		 pop	 ebp
  004bb	c2 0c 00	 ret	 12			; 0000000cH
$LN10@OPSW@2:

; 204  : 				opError("Too many plain-file-name.");

  004be	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BK@BHDOHMIE@Too?5many?5plain?9file?9name?4?$AA@
  004c3	e8 00 00 00 00	 call	 ?opError@OPSW@@QAEXPBD@Z ; OPSW::opError
$LN440@OPSW@2:
$LN416@OPSW@2:

; 105  : 						opError("/W None pass-word.");

  004c8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BD@ECJIPPDP@?1W?5None?5pass?9word?4?$AA@
  004cd	e8 00 00 00 00	 call	 ?opError@OPSW@@QAEXPBD@Z ; OPSW::opError
$LN441@OPSW@2:
$LN35@OPSW@2:

; 115  : 						};
; 116  : 					} else {
; 117  : 						opError("/W Too many pass word.");

  004d2	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BH@CBPMFIGH@?1W?5Too?5many?5pass?5word?4?$AA@
  004d7	e8 00 00 00 00	 call	 ?opError@OPSW@@QAEXPBD@Z ; OPSW::opError
$LN442@OPSW@2:
$LN417@OPSW@2:

; 127  : 						opError("/F None file-name.");

  004dc	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BD@INABCOHK@?1F?5None?5file?9name?4?$AA@
  004e1	e8 00 00 00 00	 call	 ?opError@OPSW@@QAEXPBD@Z ; OPSW::opError
$LN443@OPSW@2:
$LN418@OPSW@2:

; 174  : 						default :
; 175  : 							opError("/F");

  004e6	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_02JFIMMPLD@?1F?$AA@
  004eb	e8 00 00 00 00	 call	 ?opError@OPSW@@QAEXPBD@Z ; OPSW::opError
$LN444@OPSW@2:
$LN19@OPSW@2:

; 168  : 								};
; 169  : 							} else {
; 170  : 								opError("/F Too many cipher-key.");

  004f0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BI@ILHMDGBL@?1F?5Too?5many?5cipher?9key?4?$AA@
  004f5	e8 00 00 00 00	 call	 ?opError@OPSW@@QAEXPBD@Z ; OPSW::opError
$LN445@OPSW@2:
$LN26@OPSW@2:

; 146  : 								};
; 147  : 							} else {
; 148  : 								opError("/F Too many cipher-file-name.");

  004fa	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BO@HMGAGHIF@?1F?5Too?5many?5cipher?9file?9name?4?$AA@
  004ff	e8 00 00 00 00	 call	 ?opError@OPSW@@QAEXPBD@Z ; OPSW::opError
$LN446@OPSW@2:
$LN12@OPSW@2:

; 176  : 							break;
; 177  : 					};
; 178  : 					break;
; 179  : 				//--------
; 180  : 				//デフォルト
; 181  : 				default :
; 182  : 					opError("");

  00504	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00509	e8 00 00 00 00	 call	 ?opError@OPSW@@QAEXPBD@Z ; OPSW::opError
$LN447@OPSW@2:
$LN3@OPSW@2:

; 213  : 	};
; 214  : 
; 215  : 	//----------------------------------
; 216  : 	//◆オプションで指定された事を処理する。
; 217  : 
; 218  : 	//--------------
; 219  : 	//ヘルプ表示
; 220  : 	//ファイル名が書かれなかった場合も、ヘルプを表示する。
; 221  : 	if((fHelp==1)||(strBINname.empty())){print_help();};

  0050e	68 00 00 00 00	 push	 OFFSET ??_C@_0CMP@FNKCBDKH@CMS?$IBiRFC?45652?5?$IB?$JF?5PKCS?$CD7?$IBjutility@
  00513	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  00518	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0051d	50		 push	 eax
  0051e	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
  00523	83 c4 0c	 add	 esp, 12			; 0000000cH
  00526	6a 00		 push	 0
  00528	e8 00 00 00 00	 call	 _exit
$LN448@OPSW@2:
$LN431@OPSW@2:
  0052d	8d 49 00	 npad	 3
$LN436@OPSW@2:

; 235  : 	};
; 236  : 
; 237  : 	//--------------
; 238  : 	//
; 239  : 
; 240  : 	//	to do	その他のオプションを追加したときは、この辺に追記する。
; 241  : 
; 242  : 	//----------
; 243  : 	//Debug用 表示
; 244  : //	cout << "Plain-Text	= " << strBINname << endl;
; 245  : //	cout << "Chiper-Text	= " << strAESname << endl;
; 246  : //	cout << "Chiper-Key	= " << strKEYname << endl;
; 247  : 
; 248  : };

  00530	00 00 00 00	 DD	 $LN46@OPSW@2
  00534	00 00 00 00	 DD	 $LN45@OPSW@2
  00538	00 00 00 00	 DD	 $LN44@OPSW@2
  0053c	00 00 00 00	 DD	 $LN31@OPSW@2
  00540	00 00 00 00	 DD	 $LN40@OPSW@2
  00544	00 00 00 00	 DD	 $LN43@OPSW@2
  00548	00 00 00 00	 DD	 $LN37@OPSW@2
  0054c	00 00 00 00	 DD	 $LN12@OPSW@2
$LN427@OPSW@2:
  00550	00		 DB	 0
  00551	07		 DB	 7
  00552	07		 DB	 7
  00553	07		 DB	 7
  00554	07		 DB	 7
  00555	01		 DB	 1
  00556	02		 DB	 2
  00557	03		 DB	 3
  00558	07		 DB	 7
  00559	00		 DB	 0
  0055a	07		 DB	 7
  0055b	07		 DB	 7
  0055c	07		 DB	 7
  0055d	07		 DB	 7
  0055e	04		 DB	 4
  0055f	07		 DB	 7
  00560	07		 DB	 7
  00561	07		 DB	 7
  00562	07		 DB	 7
  00563	07		 DB	 7
  00564	07		 DB	 7
  00565	05		 DB	 5
  00566	07		 DB	 7
  00567	07		 DB	 7
  00568	06		 DB	 6
  00569	07		 DB	 7
  0056a	07		 DB	 7
  0056b	07		 DB	 7
  0056c	07		 DB	 7
  0056d	07		 DB	 7
  0056e	07		 DB	 7
  0056f	07		 DB	 7
  00570	07		 DB	 7
  00571	07		 DB	 7
  00572	07		 DB	 7
  00573	07		 DB	 7
  00574	07		 DB	 7
  00575	01		 DB	 1
  00576	02		 DB	 2
  00577	03		 DB	 3
  00578	07		 DB	 7
  00579	00		 DB	 0
  0057a	07		 DB	 7
  0057b	07		 DB	 7
  0057c	07		 DB	 7
  0057d	07		 DB	 7
  0057e	07		 DB	 7
  0057f	07		 DB	 7
  00580	07		 DB	 7
  00581	07		 DB	 7
  00582	07		 DB	 7
  00583	07		 DB	 7
  00584	07		 DB	 7
  00585	07		 DB	 7
  00586	07		 DB	 7
  00587	07		 DB	 7
  00588	06		 DB	 6
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0OPSW@@QAE@HQAPAD@Z$0:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 14	 add	 ecx, 20			; 00000014H
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0OPSW@@QAE@HQAPAD@Z$1:
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 30	 add	 ecx, 48			; 00000030H
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0OPSW@@QAE@HQAPAD@Z$2:
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0OPSW@@QAE@HQAPAD@Z$3:
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 68	 add	 ecx, 104		; 00000068H
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0OPSW@@QAE@HQAPAD@Z:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0OPSW@@QAE@HQAPAD@Z
  00042	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0OPSW@@QAE@HQAPAD@Z ENDP				; OPSW::OPSW
END

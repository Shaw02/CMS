; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\?n????j\My Project\CMS\CMS\ASN1\Algorithm\AES_CBC.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?decipher_last@AES_CBC@@UAEHPAXI@Z		; AES_CBC::decipher_last
PUBLIC	?encipher_last@AES_CBC@@UAEHPAXI@Z		; AES_CBC::encipher_last
PUBLIC	?decipher@AES_CBC@@UAEXPAXI@Z			; AES_CBC::decipher
PUBLIC	?encipher@AES_CBC@@UAEXPAXI@Z			; AES_CBC::encipher
PUBLIC	?SetIV@AES_CBC@@UAEXPAX@Z			; AES_CBC::SetIV
PUBLIC	?decrypt@AES_CBC@@UAEXPAX@Z			; AES_CBC::decrypt
PUBLIC	?encrypt@AES_CBC@@UAEXPAX@Z			; AES_CBC::encrypt
PUBLIC	??_R4AES_CBC@@6B@				; AES_CBC::`RTTI Complete Object Locator'
PUBLIC	??_R3AES_CBC@@8					; AES_CBC::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2AES_CBC@@8					; AES_CBC::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@AES_CBC@@8			; AES_CBC::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVAES_CBC@@@8				; AES_CBC `RTTI Type Descriptor'
PUBLIC	?init@AES_CBC@@UAEXXZ				; AES_CBC::init
PUBLIC	??_7AES_CBC@@6B@				; AES_CBC::`vftable'
;	COMDAT ??_7AES_CBC@@6B@
CONST	SEGMENT
??_7AES_CBC@@6B@ DD FLAT:??_R4AES_CBC@@6B@		; AES_CBC::`vftable'
	DD	FLAT:?encodeBER@Sequence@@UAEXXZ
	DD	FLAT:?Get_BERcode@ASN1@@UAEPBDXZ
	DD	FLAT:?Get_BERsize@ASN1@@UAEIXZ
	DD	FLAT:?Set_Key@AES@@UAEXPAX@Z
	DD	FLAT:?Clear_Key@AES@@UAEXXZ
	DD	FLAT:?init@AES_CBC@@UAEXXZ
	DD	FLAT:?encrypt@AES_CBC@@UAEXPAX@Z
	DD	FLAT:?decrypt@AES_CBC@@UAEXPAX@Z
	DD	FLAT:?encrypt_ecb@AES@@UAEXPAX@Z
	DD	FLAT:?decrypt_ecb@AES@@UAEXPAX@Z
	DD	FLAT:?SetIV@AES_CBC@@UAEXPAX@Z
	DD	FLAT:?encipher@AES_CBC@@UAEXPAXI@Z
	DD	FLAT:?decipher@AES_CBC@@UAEXPAXI@Z
	DD	FLAT:?encipher_last@AES_CBC@@UAEHPAXI@Z
	DD	FLAT:?decipher_last@AES_CBC@@UAEHPAXI@Z
	DD	FLAT:?KeyWrap@Encryption@@UAEHPAXI@Z
	DD	FLAT:?KeyUnWrap@Encryption@@UAEHPAXI@Z
	DD	FLAT:?GetKey@Encryption@@UAEPAXXZ
	DD	FLAT:?GetEncrptedKey@Encryption@@UAEPAXXZ
CONST	ENDS
;	COMDAT ??_R4AES_CBC@@6B@
rdata$r	SEGMENT
??_R4AES_CBC@@6B@ DD 00H				; AES_CBC::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVAES_CBC@@@8
	DD	FLAT:??_R3AES_CBC@@8
rdata$r	ENDS
;	COMDAT ??_R3AES_CBC@@8
rdata$r	SEGMENT
??_R3AES_CBC@@8 DD 00H					; AES_CBC::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	06H
	DD	FLAT:??_R2AES_CBC@@8
rdata$r	ENDS
;	COMDAT ??_R2AES_CBC@@8
rdata$r	SEGMENT
??_R2AES_CBC@@8 DD FLAT:??_R1A@?0A@EA@AES_CBC@@8	; AES_CBC::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@AES@@8
	DD	FLAT:??_R1A@?0A@EA@Encryption@@8
	DD	FLAT:??_R1A@?0A@EA@AlgorithmIdentifier@@8
	DD	FLAT:??_R1A@?0A@EA@Sequence@@8
	DD	FLAT:??_R1A@?0A@EA@ASN1@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@AES_CBC@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AES_CBC@@8 DD FLAT:??_R0?AVAES_CBC@@@8	; AES_CBC::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3AES_CBC@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVAES_CBC@@@8
_DATA	SEGMENT
??_R0?AVAES_CBC@@@8 DD FLAT:??_7type_info@@6B@		; AES_CBC `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAES_CBC@@', 00H
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\aes_cbc.cpp
;	COMDAT ?SetIV@AES_CBC@@UAEXPAX@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?SetIV@AES_CBC@@UAEXPAX@Z PROC				; AES_CBC::SetIV, COMDAT
; _this$ = ecx

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H

; 38   : 	vector = _mm_load_si128((__m128i*)data);

  00006	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00009	66 0f 6f 00	 movdqa	 xmm0, XMMWORD PTR [eax]
  0000d	66 0f 7f 81 b0
	01 00 00	 movdqa	 XMMWORD PTR [ecx+432], xmm0

; 39   : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?SetIV@AES_CBC@@UAEXPAX@Z ENDP				; AES_CBC::SetIV
PUBLIC	_data$GSCopy$
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT ?decipher_last@AES_CBC@@UAEHPAXI@Z
_TEXT	SEGMENT
_data$GSCopy$ = -36					; size = 4
$T39180 = -32						; size = 16
__$ArrayPad$ = -4					; size = 4
_data$ = 8						; size = 4
_iSize$ = 12						; size = 4
?decipher_last@AES_CBC@@UAEHPAXI@Z PROC			; AES_CBC::decipher_last, COMDAT
; _this$ = ecx

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	83 ec 24	 sub	 esp, 36			; 00000024H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 20	 mov	 DWORD PTR __$ArrayPad$[esp+36], eax

; 246  : 	}
; 247  : 
; 248  : 	//最後のBlockは、Paddingを含む。
; 249  : 	n--;

  00014	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00017	53		 push	 ebx
  00018	8b 5d 0c	 mov	 ebx, DWORD PTR _iSize$[ebp]
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8b f1		 mov	 esi, ecx
  0001f	33 ff		 xor	 edi, edi
  00021	80 be a2 01 00
	00 01		 cmp	 BYTE PTR [esi+418], 1
  00028	89 44 24 0c	 mov	 DWORD PTR _data$GSCopy$[esp+48], eax
  0002c	75 50		 jne	 SHORT $LN17@decipher_l@2
  0002e	8b 8e a0 00 00
	00		 mov	 ecx, DWORD PTR [esi+160]
  00034	03 c9		 add	 ecx, ecx
  00036	03 c9		 add	 ecx, ecx
  00038	3b d9		 cmp	 ebx, ecx
  0003a	76 42		 jbe	 SHORT $LN17@decipher_l@2
$LN8@decipher_l@2:

; 223  : 	__m128i				temp;
; 224  : 
; 225  : 	unsigned	char*	cData		= (unsigned	char*)data;
; 226  : 	unsigned	int		n			= 0;
; 227  : 
; 228  : 	unsigned	char	cPadData;
; 229  : 	unsigned	char	cntPadData;
; 230  : 
; 231  : 	//復号
; 232  : 	if(aesni == true){
; 233  : 		while(iSize > szBlock * 4){
; 234  : 			vector = InvCipher_CBC4((__m128i*)&cData[n], vector);

  0003c	8b 54 24 0c	 mov	 edx, DWORD PTR _data$GSCopy$[esp+48]
  00040	66 0f 6f 86 b0
	01 00 00	 movdqa	 xmm0, XMMWORD PTR [esi+432]
  00048	8d 44 24 10	 lea	 eax, DWORD PTR $T39180[esp+48]
  0004c	03 d7		 add	 edx, edi
  0004e	50		 push	 eax
  0004f	8b ce		 mov	 ecx, esi
  00051	e8 00 00 00 00	 call	 ?InvCipher_CBC4@AES@@IAE?AT__m128i@@PAT2@T2@@Z ; AES::InvCipher_CBC4
  00056	66 0f 6f 00	 movdqa	 xmm0, XMMWORD PTR [eax]

; 235  : 			n		+= szBlock * 4;

  0005a	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  00060	66 0f 7f 86 b0
	01 00 00	 movdqa	 XMMWORD PTR [esi+432], xmm0
  00068	8b 8e a0 00 00
	00		 mov	 ecx, DWORD PTR [esi+160]
  0006e	03 c0		 add	 eax, eax
  00070	03 c0		 add	 eax, eax
  00072	03 c9		 add	 ecx, ecx

; 236  : 			iSize	-= szBlock * 4;

  00074	2b d8		 sub	 ebx, eax
  00076	03 c9		 add	 ecx, ecx
  00078	03 f8		 add	 edi, eax
  0007a	3b d9		 cmp	 ebx, ecx
  0007c	77 be		 ja	 SHORT $LN8@decipher_l@2
$LN17@decipher_l@2:

; 237  : 		}
; 238  : 	}
; 239  : 
; 240  : 	while(iSize > 0){

  0007e	85 db		 test	 ebx, ebx
  00080	76 58		 jbe	 SHORT $LN5@decipher_l@2
$LN6@decipher_l@2:

; 241  : 		temp = _mm_xor_si128(InvCipher(_mm_load_si128((__m128i*)&cData[n])), vector);

  00082	80 be a2 01 00
	00 00		 cmp	 BYTE PTR [esi+418], 0
  00089	8b 54 24 0c	 mov	 edx, DWORD PTR _data$GSCopy$[esp+48]
  0008d	66 0f 6f 04 3a	 movdqa	 xmm0, XMMWORD PTR [edx+edi]
  00092	8a 8e a1 01 00
	00		 mov	 cl, BYTE PTR [esi+417]
  00098	8d 96 b0 00 00
	00		 lea	 edx, DWORD PTR [esi+176]
  0009e	75 07		 jne	 SHORT $LN13@decipher_l@2
  000a0	e8 00 00 00 00	 call	 @AES_SSE_InvCipher@24
  000a5	eb 05		 jmp	 SHORT $LN12@decipher_l@2
$LN13@decipher_l@2:
  000a7	e8 00 00 00 00	 call	 @AES_NI_InvCipher@24
$LN12@decipher_l@2:
  000ac	66 0f 6f 8e b0
	01 00 00	 movdqa	 xmm1, XMMWORD PTR [esi+432]

; 242  : 		vector	= _mm_load_si128((__m128i*)&cData[n]);

  000b4	8b 44 24 0c	 mov	 eax, DWORD PTR _data$GSCopy$[esp+48]
  000b8	66 0f ef c1	 pxor	 xmm0, xmm1
  000bc	66 0f 6f 0c 38	 movdqa	 xmm1, XMMWORD PTR [eax+edi]
  000c1	66 0f 7f 8e b0
	01 00 00	 movdqa	 XMMWORD PTR [esi+432], xmm1

; 243  : 		_mm_store_si128((__m128i*)&cData[n], temp);

  000c9	66 0f 7f 04 38	 movdqa	 XMMWORD PTR [eax+edi], xmm0

; 244  : 		n		+= szBlock;

  000ce	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  000d4	03 f8		 add	 edi, eax

; 245  : 		iSize	-= szBlock;

  000d6	2b d8		 sub	 ebx, eax
  000d8	75 a8		 jne	 SHORT $LN6@decipher_l@2
$LN5@decipher_l@2:

; 250  : 	cPadData	= cData[n];

  000da	8b 44 24 0c	 mov	 eax, DWORD PTR _data$GSCopy$[esp+48]
  000de	4f		 dec	 edi
  000df	03 f8		 add	 edi, eax
  000e1	8a 07		 mov	 al, BYTE PTR [edi]

; 251  : 	cntPadData	= cPadData;

  000e3	8a c8		 mov	 cl, al
$LL4@decipher_l@2:

; 252  : 
; 253  : 	//Paddingのチェック
; 254  : 	do{
; 255  : 		if(cData[n] != cPadData){	return(-1);	}

  000e5	38 07		 cmp	 BYTE PTR [edi], al
  000e7	75 1d		 jne	 SHORT $LN19@decipher_l@2

; 256  : 		n--;

  000e9	4f		 dec	 edi

; 257  : 		cntPadData--;

  000ea	80 c1 ff	 add	 cl, 255			; 000000ffH

; 258  : 	} while(cntPadData>0);

  000ed	75 f6		 jne	 SHORT $LL4@decipher_l@2

; 259  : 
; 260  : 	return(cPadData);

  000ef	0f b6 c0	 movzx	 eax, al

; 261  : }

  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx
  000f5	8b 4c 24 20	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+36]
  000f9	33 cc		 xor	 ecx, esp
  000fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 08 00	 ret	 8
$LN19@decipher_l@2:
  00106	8b 4c 24 2c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+48]
  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx
  0010d	33 cc		 xor	 ecx, esp
  0010f	83 c8 ff	 or	 eax, -1
  00112	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c2 08 00	 ret	 8
?decipher_last@AES_CBC@@UAEHPAXI@Z ENDP			; AES_CBC::decipher_last
_TEXT	ENDS
PUBLIC	_data$GSCopy$
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT ?decipher@AES_CBC@@UAEXPAXI@Z
_TEXT	SEGMENT
_data$GSCopy$ = -36					; size = 4
$T39153 = -32						; size = 16
__$ArrayPad$ = -4					; size = 4
_data$ = 8						; size = 4
_iSize$ = 12						; size = 4
?decipher@AES_CBC@@UAEXPAXI@Z PROC			; AES_CBC::decipher, COMDAT
; _this$ = ecx

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	83 ec 24	 sub	 esp, 36			; 00000024H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 20	 mov	 DWORD PTR __$ArrayPad$[esp+36], eax

; 204  : 		temp = _mm_xor_si128(InvCipher(_mm_load_si128((__m128i*)&cData[n])), vector);

  00014	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00017	53		 push	 ebx
  00018	8b 5d 0c	 mov	 ebx, DWORD PTR _iSize$[ebp]
  0001b	56		 push	 esi
  0001c	8b f1		 mov	 esi, ecx
  0001e	8b 8e a0 00 00
	00		 mov	 ecx, DWORD PTR [esi+160]
  00024	03 c9		 add	 ecx, ecx
  00026	57		 push	 edi
  00027	03 c9		 add	 ecx, ecx
  00029	33 ff		 xor	 edi, edi
  0002b	89 44 24 0c	 mov	 DWORD PTR _data$GSCopy$[esp+48], eax
  0002f	3b d9		 cmp	 ebx, ecx
  00031	72 58		 jb	 SHORT $LN13@decipher@2

; 191  : 	__m128i				temp;
; 192  : 
; 193  : 	unsigned	char*	cData		= (unsigned	char*)data;
; 194  : 	unsigned	int		n			= 0;
; 195  : 
; 196  : 	if((iSize >= szBlock * 4) && (aesni == true)){

  00033	80 be a2 01 00
	00 01		 cmp	 BYTE PTR [esi+418], 1
  0003a	75 4f		 jne	 SHORT $LN13@decipher@2

; 197  : 		while(n < iSize){

  0003c	85 db		 test	 ebx, ebx
  0003e	0f 86 a1 00 00
	00		 jbe	 $LN1@decipher@2
$LN4@decipher@2:

; 198  : 			vector = InvCipher_CBC4((__m128i*)&cData[n], vector);

  00044	8b 54 24 0c	 mov	 edx, DWORD PTR _data$GSCopy$[esp+48]
  00048	66 0f 6f 86 b0
	01 00 00	 movdqa	 xmm0, XMMWORD PTR [esi+432]
  00050	8d 44 24 10	 lea	 eax, DWORD PTR $T39153[esp+48]
  00054	03 d7		 add	 edx, edi
  00056	50		 push	 eax
  00057	8b ce		 mov	 ecx, esi
  00059	e8 00 00 00 00	 call	 ?InvCipher_CBC4@AES@@IAE?AT__m128i@@PAT2@T2@@Z ; AES::InvCipher_CBC4

; 199  : 			n	+=	szBlock * 4;

  0005e	8b 8e a0 00 00
	00		 mov	 ecx, DWORD PTR [esi+160]
  00064	66 0f 6f 00	 movdqa	 xmm0, XMMWORD PTR [eax]
  00068	8d 3c 8f	 lea	 edi, DWORD PTR [edi+ecx*4]
  0006b	66 0f 7f 86 b0
	01 00 00	 movdqa	 XMMWORD PTR [esi+432], xmm0
  00073	3b fb		 cmp	 edi, ebx
  00075	72 cd		 jb	 SHORT $LN4@decipher@2

; 208  : 	}
; 209  : 
; 210  : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	8b 4c 24 20	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+36]
  0007e	33 cc		 xor	 ecx, esp
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
$LN13@decipher@2:

; 200  : 		}
; 201  : 	}
; 202  : 
; 203  : 	while(n < iSize){

  0008b	85 db		 test	 ebx, ebx
  0008d	76 56		 jbe	 SHORT $LN1@decipher@2
$LN2@decipher@2:

; 204  : 		temp = _mm_xor_si128(InvCipher(_mm_load_si128((__m128i*)&cData[n])), vector);

  0008f	80 be a2 01 00
	00 00		 cmp	 BYTE PTR [esi+418], 0
  00096	8b 54 24 0c	 mov	 edx, DWORD PTR _data$GSCopy$[esp+48]
  0009a	66 0f 6f 04 3a	 movdqa	 xmm0, XMMWORD PTR [edx+edi]
  0009f	8a 8e a1 01 00
	00		 mov	 cl, BYTE PTR [esi+417]
  000a5	8d 96 b0 00 00
	00		 lea	 edx, DWORD PTR [esi+176]
  000ab	75 07		 jne	 SHORT $LN9@decipher@2
  000ad	e8 00 00 00 00	 call	 @AES_SSE_InvCipher@24
  000b2	eb 05		 jmp	 SHORT $LN8@decipher@2
$LN9@decipher@2:
  000b4	e8 00 00 00 00	 call	 @AES_NI_InvCipher@24
$LN8@decipher@2:
  000b9	66 0f 6f 8e b0
	01 00 00	 movdqa	 xmm1, XMMWORD PTR [esi+432]

; 205  : 		vector	= _mm_load_si128((__m128i*)&cData[n]);

  000c1	8b 44 24 0c	 mov	 eax, DWORD PTR _data$GSCopy$[esp+48]
  000c5	66 0f ef c1	 pxor	 xmm0, xmm1
  000c9	66 0f 6f 0c 38	 movdqa	 xmm1, XMMWORD PTR [eax+edi]
  000ce	66 0f 7f 8e b0
	01 00 00	 movdqa	 XMMWORD PTR [esi+432], xmm1

; 206  : 		_mm_store_si128((__m128i*)&cData[n], temp);

  000d6	66 0f 7f 04 38	 movdqa	 XMMWORD PTR [eax+edi], xmm0

; 207  : 		n	+=	szBlock;

  000db	03 be a0 00 00
	00		 add	 edi, DWORD PTR [esi+160]
  000e1	3b fb		 cmp	 edi, ebx
  000e3	72 aa		 jb	 SHORT $LN2@decipher@2
$LN1@decipher@2:

; 208  : 	}
; 209  : 
; 210  : }

  000e5	8b 4c 24 2c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+48]
  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	5b		 pop	 ebx
  000ec	33 cc		 xor	 ecx, esp
  000ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 08 00	 ret	 8
?decipher@AES_CBC@@UAEXPAXI@Z ENDP			; AES_CBC::decipher
_TEXT	ENDS
PUBLIC	_data$GSCopy$
; Function compile flags: /Ogtpy
;	COMDAT ?encipher_last@AES_CBC@@UAEHPAXI@Z
_TEXT	SEGMENT
_data$GSCopy$ = -4					; size = 4
_data$ = 8						; size = 4
_iSize$ = 12						; size = 4
?encipher_last@AES_CBC@@UAEHPAXI@Z PROC			; AES_CBC::encipher_last, COMDAT
; _this$ = ecx

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	51		 push	 ecx

; 137  : 	__m128i				temp;
; 138  : 	__m128i				_vector		= vector;
; 139  : 
; 140  : 	unsigned	char*	cData		= (unsigned	char*)data;
; 141  : 	unsigned	int		n			= 0;
; 142  : 
; 143  : 	unsigned	int		ptPadding;
; 144  : 	unsigned	char	cPadData;
; 145  : 	unsigned	char	cntPadData;
; 146  : 
; 147  : 	//暗号（最終ブロック直前まで）
; 148  : 	while(iSize >= szBlock){

  00007	8b 45 0c	 mov	 eax, DWORD PTR _iSize$[ebp]
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	8b f1		 mov	 esi, ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00011	66 0f 6f 8e b0
	01 00 00	 movdqa	 xmm1, XMMWORD PTR [esi+432]
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi

; 174  : 	_mm_store_si128((__m128i*)&cData[n], temp);

  0001c	89 4c 24 0c	 mov	 DWORD PTR _data$GSCopy$[esp+16], ecx
  00020	3b 86 a0 00 00
	00		 cmp	 eax, DWORD PTR [esi+160]
  00026	72 55		 jb	 SHORT $LN5@encipher_l@2
  00028	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL6@encipher_l@2:

; 149  : 		temp = Cipher(_mm_xor_si128(_mm_load_si128((__m128i*)&cData[n]), _vector));

  00030	80 be a2 01 00
	00 00		 cmp	 BYTE PTR [esi+418], 0
  00037	66 0f 6f 04 39	 movdqa	 xmm0, XMMWORD PTR [ecx+edi]
  0003c	8d 1c 39	 lea	 ebx, DWORD PTR [ecx+edi]
  0003f	8a 8e a1 01 00
	00		 mov	 cl, BYTE PTR [esi+417]
  00045	66 0f ef c1	 pxor	 xmm0, xmm1
  00049	8d 96 b0 00 00
	00		 lea	 edx, DWORD PTR [esi+176]
  0004f	75 07		 jne	 SHORT $LN12@encipher_l@2
  00051	e8 00 00 00 00	 call	 @AES_SSE_Cipher@24
  00056	eb 05		 jmp	 SHORT $LN11@encipher_l@2
$LN12@encipher_l@2:
  00058	e8 00 00 00 00	 call	 @AES_NI_Cipher@24
$LN11@encipher_l@2:

; 150  : 		_mm_store_si128((__m128i*)&cData[n], temp);
; 151  : 		_vector = temp;
; 152  : 		n		+= szBlock;
; 153  : 		iSize	-= szBlock;

  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _iSize$[ebp]
  00060	66 0f 7f 03	 movdqa	 XMMWORD PTR [ebx], xmm0
  00064	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  0006a	2b c8		 sub	 ecx, eax
  0006c	03 f8		 add	 edi, eax
  0006e	89 4d 0c	 mov	 DWORD PTR _iSize$[ebp], ecx
  00071	3b c8		 cmp	 ecx, eax
  00073	8b 4c 24 0c	 mov	 ecx, DWORD PTR _data$GSCopy$[esp+16]
  00077	66 0f 6f c8	 movdqa	 xmm1, xmm0
  0007b	73 b3		 jae	 SHORT $LL6@encipher_l@2
$LN5@encipher_l@2:

; 154  : 	}
; 155  : 
; 156  : 	//Padding処理(PKCS#7)を実施
; 157  : 	ptPadding	= n + ((n%szBlock)?-1:szBlock-1);

  0007d	8b 9e a0 00 00
	00		 mov	 ebx, DWORD PTR [esi+160]
  00083	33 d2		 xor	 edx, edx
  00085	8b c7		 mov	 eax, edi
  00087	f7 f3		 div	 ebx
  00089	85 d2		 test	 edx, edx
  0008b	74 05		 je	 SHORT $LN9@encipher_l@2
  0008d	83 c8 ff	 or	 eax, -1
  00090	eb 03		 jmp	 SHORT $LN10@encipher_l@2
$LN9@encipher_l@2:
  00092	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
$LN10@encipher_l@2:

; 158  : 	cPadData	= szBlock - iSize;

  00095	2a 5d 0c	 sub	 bl, BYTE PTR _iSize$[ebp]
  00098	03 c7		 add	 eax, edi

; 159  : 	cntPadData	= cPadData;

  0009a	8a d3		 mov	 dl, bl
  0009c	03 c1		 add	 eax, ecx
  0009e	8b ff		 npad	 2
$LL4@encipher_l@2:

; 160  : 	do{
; 161  : 		cData[ptPadding] = cPadData;

  000a0	88 18		 mov	 BYTE PTR [eax], bl

; 162  : 		ptPadding--;

  000a2	48		 dec	 eax

; 163  : 		cntPadData--;

  000a3	80 c2 ff	 add	 dl, 255			; 000000ffH

; 164  : 	} while(cntPadData>0);

  000a6	75 f8		 jne	 SHORT $LL4@encipher_l@2

; 165  : 
; 166  : 	//暗号（最終）
; 167  : 	if(iSize == szBlock){

  000a8	8b 55 0c	 mov	 edx, DWORD PTR _iSize$[ebp]
  000ab	3b 96 a0 00 00
	00		 cmp	 edx, DWORD PTR [esi+160]
  000b1	75 3f		 jne	 SHORT $LN1@encipher_l@2

; 168  : 		temp = Cipher(_mm_xor_si128(_mm_load_si128((__m128i*)&cData[n]), _vector));

  000b3	80 be a2 01 00
	00 00		 cmp	 BYTE PTR [esi+418], 0
  000ba	66 0f 6f 04 39	 movdqa	 xmm0, XMMWORD PTR [ecx+edi]
  000bf	8a 8e a1 01 00
	00		 mov	 cl, BYTE PTR [esi+417]
  000c5	66 0f ef c1	 pxor	 xmm0, xmm1
  000c9	8d 96 b0 00 00
	00		 lea	 edx, DWORD PTR [esi+176]
  000cf	75 07		 jne	 SHORT $LN16@encipher_l@2
  000d1	e8 00 00 00 00	 call	 @AES_SSE_Cipher@24
  000d6	eb 05		 jmp	 SHORT $LN15@encipher_l@2
$LN16@encipher_l@2:
  000d8	e8 00 00 00 00	 call	 @AES_NI_Cipher@24
$LN15@encipher_l@2:

; 169  : 		_mm_store_si128((__m128i*)&cData[n], temp);

  000dd	8b 44 24 0c	 mov	 eax, DWORD PTR _data$GSCopy$[esp+16]
  000e1	66 0f 7f 04 38	 movdqa	 XMMWORD PTR [eax+edi], xmm0

; 170  : 		_vector = temp;
; 171  : 		n		+= szBlock;

  000e6	03 be a0 00 00
	00		 add	 edi, DWORD PTR [esi+160]
  000ec	66 0f 6f c8	 movdqa	 xmm1, xmm0
  000f0	8b c8		 mov	 ecx, eax
$LN1@encipher_l@2:

; 172  : 	}
; 173  : 	temp = Cipher(_mm_xor_si128(_mm_load_si128((__m128i*)&cData[n]), _vector));

  000f2	66 0f 6f 04 0f	 movdqa	 xmm0, XMMWORD PTR [edi+ecx]
  000f7	03 f9		 add	 edi, ecx
  000f9	80 be a2 01 00
	00 00		 cmp	 BYTE PTR [esi+418], 0
  00100	8a 8e a1 01 00
	00		 mov	 cl, BYTE PTR [esi+417]
  00106	66 0f ef c1	 pxor	 xmm0, xmm1
  0010a	8d 96 b0 00 00
	00		 lea	 edx, DWORD PTR [esi+176]
  00110	75 07		 jne	 SHORT $LN20@encipher_l@2
  00112	e8 00 00 00 00	 call	 @AES_SSE_Cipher@24
  00117	eb 05		 jmp	 SHORT $LN19@encipher_l@2
$LN20@encipher_l@2:
  00119	e8 00 00 00 00	 call	 @AES_NI_Cipher@24
$LN19@encipher_l@2:

; 174  : 	_mm_store_si128((__m128i*)&cData[n], temp);

  0011e	66 0f 7f 07	 movdqa	 XMMWORD PTR [edi], xmm0

; 175  : 	vector = temp;			//元のメンバー変数に入れる。
; 176  : //	n		+= szBlock;		//これはいらん。
; 177  : 
; 178  : 	return(cPadData);
; 179  : }

  00122	5f		 pop	 edi
  00123	66 0f 7f 86 b0
	01 00 00	 movdqa	 XMMWORD PTR [esi+432], xmm0
  0012b	5e		 pop	 esi
  0012c	0f b6 c3	 movzx	 eax, bl
  0012f	5b		 pop	 ebx
  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c2 08 00	 ret	 8
?encipher_last@AES_CBC@@UAEHPAXI@Z ENDP			; AES_CBC::encipher_last
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?encipher@AES_CBC@@UAEXPAXI@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
_iSize$ = 12						; size = 4
?encipher@AES_CBC@@UAEXPAXI@Z PROC			; AES_CBC::encipher, COMDAT
; _this$ = ecx

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	51		 push	 ecx
  00007	53		 push	 ebx
  00008	8b 5d 08	 mov	 ebx, DWORD PTR _data$[ebp]
  0000b	56		 push	 esi
  0000c	57		 push	 edi

; 111  : 	__m128i				temp;
; 112  : 	__m128i				_vector		= vector;
; 113  : 
; 114  : 	unsigned	char*	cData		= (unsigned	char*)data;
; 115  : 	unsigned	int		n			= 0;

  0000d	33 ff		 xor	 edi, edi
  0000f	8b f1		 mov	 esi, ecx
  00011	66 0f 6f 8e b0
	01 00 00	 movdqa	 xmm1, XMMWORD PTR [esi+432]

; 116  : 
; 117  : 	while(n < iSize){

  00019	39 7d 0c	 cmp	 DWORD PTR _iSize$[ebp], edi
  0001c	76 40		 jbe	 SHORT $LN11@encipher@2
  0001e	8b ff		 npad	 2
$LL2@encipher@2:

; 118  : 		temp = Cipher(_mm_xor_si128(_mm_load_si128((__m128i*)&cData[n]), _vector));

  00020	80 be a2 01 00
	00 00		 cmp	 BYTE PTR [esi+418], 0
  00027	66 0f 6f 04 3b	 movdqa	 xmm0, XMMWORD PTR [ebx+edi]
  0002c	8a 8e a1 01 00
	00		 mov	 cl, BYTE PTR [esi+417]
  00032	66 0f ef c1	 pxor	 xmm0, xmm1
  00036	8d 96 b0 00 00
	00		 lea	 edx, DWORD PTR [esi+176]
  0003c	75 07		 jne	 SHORT $LN6@encipher@2
  0003e	e8 00 00 00 00	 call	 @AES_SSE_Cipher@24
  00043	eb 05		 jmp	 SHORT $LN5@encipher@2
$LN6@encipher@2:
  00045	e8 00 00 00 00	 call	 @AES_NI_Cipher@24
$LN5@encipher@2:

; 119  : 		_mm_store_si128((__m128i*)&cData[n], temp);

  0004a	66 0f 7f 04 3b	 movdqa	 XMMWORD PTR [ebx+edi], xmm0

; 120  : 		_vector = temp;
; 121  : 		n	+=	szBlock;

  0004f	03 be a0 00 00
	00		 add	 edi, DWORD PTR [esi+160]
  00055	66 0f 6f c8	 movdqa	 xmm1, xmm0
  00059	3b 7d 0c	 cmp	 edi, DWORD PTR _iSize$[ebp]
  0005c	72 c2		 jb	 SHORT $LL2@encipher@2
$LN11@encipher@2:

; 122  : 	}
; 123  : 	vector = _vector;
; 124  : 
; 125  : }

  0005e	5f		 pop	 edi
  0005f	66 0f 7f 8e b0
	01 00 00	 movdqa	 XMMWORD PTR [esi+432], xmm1
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c2 08 00	 ret	 8
?encipher@AES_CBC@@UAEXPAXI@Z ENDP			; AES_CBC::encipher
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?decrypt@AES_CBC@@UAEXPAX@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?decrypt@AES_CBC@@UAEXPAX@Z PROC			; AES_CBC::decrypt, COMDAT
; _this$ = ecx

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx

; 78   : 	__m128i	temp = _mm_xor_si128(InvCipher(_mm_load_si128((__m128i*)data)), vector);

  0000c	80 be a2 01 00
	00 00		 cmp	 BYTE PTR [esi+418], 0
  00013	8a 8e a1 01 00
	00		 mov	 cl, BYTE PTR [esi+417]
  00019	57		 push	 edi
  0001a	8b 7d 08	 mov	 edi, DWORD PTR _data$[ebp]
  0001d	66 0f 6f 07	 movdqa	 xmm0, XMMWORD PTR [edi]
  00021	8d 96 b0 00 00
	00		 lea	 edx, DWORD PTR [esi+176]
  00027	75 07		 jne	 SHORT $LN4@decrypt
  00029	e8 00 00 00 00	 call	 @AES_SSE_InvCipher@24
  0002e	eb 05		 jmp	 SHORT $LN3@decrypt
$LN4@decrypt:
  00030	e8 00 00 00 00	 call	 @AES_NI_InvCipher@24
$LN3@decrypt:
  00035	66 0f 6f 8e b0
	01 00 00	 movdqa	 xmm1, XMMWORD PTR [esi+432]
  0003d	66 0f ef c1	 pxor	 xmm0, xmm1

; 79   : 
; 80   : 	vector	= _mm_load_si128((__m128i*)data);

  00041	66 0f 6f 0f	 movdqa	 xmm1, XMMWORD PTR [edi]
  00045	66 0f 7f 8e b0
	01 00 00	 movdqa	 XMMWORD PTR [esi+432], xmm1

; 81   : 	_mm_store_si128((__m128i*)data, temp);

  0004d	66 0f 7f 07	 movdqa	 XMMWORD PTR [edi], xmm0

; 82   : 
; 83   : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?decrypt@AES_CBC@@UAEXPAX@Z ENDP			; AES_CBC::decrypt
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?encrypt@AES_CBC@@UAEXPAX@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?encrypt@AES_CBC@@UAEXPAX@Z PROC			; AES_CBC::encrypt, COMDAT
; _this$ = ecx

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx

; 62   : 	__m128i	temp = Cipher(_mm_xor_si128(_mm_load_si128((__m128i*)data), vector));

  0000c	80 be a2 01 00
	00 00		 cmp	 BYTE PTR [esi+418], 0
  00013	66 0f 6f 8e b0
	01 00 00	 movdqa	 xmm1, XMMWORD PTR [esi+432]
  0001b	8a 8e a1 01 00
	00		 mov	 cl, BYTE PTR [esi+417]
  00021	57		 push	 edi
  00022	8b 7d 08	 mov	 edi, DWORD PTR _data$[ebp]
  00025	66 0f 6f 07	 movdqa	 xmm0, XMMWORD PTR [edi]
  00029	66 0f ef c1	 pxor	 xmm0, xmm1
  0002d	8d 96 b0 00 00
	00		 lea	 edx, DWORD PTR [esi+176]
  00033	75 19		 jne	 SHORT $LN4@encrypt
  00035	e8 00 00 00 00	 call	 @AES_SSE_Cipher@24

; 63   : 
; 64   : 	vector = temp;

  0003a	66 0f 7f 86 b0
	01 00 00	 movdqa	 XMMWORD PTR [esi+432], xmm0

; 65   : 	_mm_store_si128((__m128i*)data, temp);

  00042	66 0f 7f 07	 movdqa	 XMMWORD PTR [edi], xmm0

; 66   : 
; 67   : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4

; 62   : 	__m128i	temp = Cipher(_mm_xor_si128(_mm_load_si128((__m128i*)data), vector));

$LN4@encrypt:
  0004e	e8 00 00 00 00	 call	 @AES_NI_Cipher@24

; 63   : 
; 64   : 	vector = temp;

  00053	66 0f 7f 86 b0
	01 00 00	 movdqa	 XMMWORD PTR [esi+432], xmm0

; 65   : 	_mm_store_si128((__m128i*)data, temp);

  0005b	66 0f 7f 07	 movdqa	 XMMWORD PTR [edi], xmm0

; 66   : 
; 67   : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?encrypt@AES_CBC@@UAEXPAX@Z ENDP			; AES_CBC::encrypt
_TEXT	ENDS
PUBLIC	?initIV@AES_CBC@@QAEXXZ				; AES_CBC::initIV
; Function compile flags: /Ogtpy
;	COMDAT ?initIV@AES_CBC@@QAEXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?initIV@AES_CBC@@QAEXXZ PROC				; AES_CBC::initIV, COMDAT

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]

; 50   : 	vector = _mm_loadu_si128((__m128i *)IV.strValue.c_str());

  00009	83 b8 1c 02 00
	00 10		 cmp	 DWORD PTR [eax+540], 16	; 00000010H
  00010	72 18		 jb	 SHORT $LN7@initIV@3
  00012	8b 88 08 02 00
	00		 mov	 ecx, DWORD PTR [eax+520]
  00018	f3 0f 6f 01	 movdqu	 xmm0, XMMWORD PTR [ecx]
  0001c	66 0f 7f 80 b0
	01 00 00	 movdqa	 XMMWORD PTR [eax+432], xmm0

; 51   : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4

; 50   : 	vector = _mm_loadu_si128((__m128i *)IV.strValue.c_str());

$LN7@initIV@3:
  0002a	f3 0f 6f 80 08
	02 00 00	 movdqu	 xmm0, XMMWORD PTR [eax+520]
  00032	8d 88 08 02 00
	00		 lea	 ecx, DWORD PTR [eax+520]
  00038	66 0f 7f 80 b0
	01 00 00	 movdqa	 XMMWORD PTR [eax+432], xmm0

; 51   : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?initIV@AES_CBC@@QAEXXZ ENDP				; AES_CBC::initIV
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\aes_cbc.h
;	COMDAT ?init@AES_CBC@@UAEXXZ
_TEXT	SEGMENT
?init@AES_CBC@@UAEXXZ PROC				; AES_CBC::init, COMDAT
; _this$ = ecx

; 46   : 			void	init(){initIV();};			//初期化

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	8b c1		 mov	 eax, ecx
  00008	83 b8 1c 02 00
	00 10		 cmp	 DWORD PTR [eax+540], 16	; 00000010H
  0000f	72 16		 jb	 SHORT $LN9@init@3
  00011	8b 88 08 02 00
	00		 mov	 ecx, DWORD PTR [eax+520]
  00017	f3 0f 6f 01	 movdqu	 xmm0, XMMWORD PTR [ecx]
  0001b	66 0f 7f 80 b0
	01 00 00	 movdqa	 XMMWORD PTR [eax+432], xmm0
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN9@init@3:
  00027	f3 0f 6f 80 08
	02 00 00	 movdqu	 xmm0, XMMWORD PTR [eax+520]
  0002f	8d 88 08 02 00
	00		 lea	 ecx, DWORD PTR [eax+520]
  00035	66 0f 7f 80 b0
	01 00 00	 movdqa	 XMMWORD PTR [eax+432], xmm0
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?init@AES_CBC@@UAEXXZ ENDP				; AES_CBC::init
PUBLIC	??1AES_CBC@@QAE@XZ				; AES_CBC::~AES_CBC
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\aes_cbc.cpp
;	COMDAT ??1AES_CBC@@QAE@XZ
_TEXT	SEGMENT
??1AES_CBC@@QAE@XZ PROC					; AES_CBC::~AES_CBC, COMDAT
; _this$ = esi

; 26   : {

  00000	53		 push	 ebx
  00001	57		 push	 edi

; 27   : }

  00002	8d be c0 01 00
	00		 lea	 edi, DWORD PTR [esi+448]
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7AES_CBC@@6B@
  0000e	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7OctetString@@6B@
  00014	83 7f 5c 10	 cmp	 DWORD PTR [edi+92], 16	; 00000010H
  00018	72 0c		 jb	 SHORT $LN21@AES_CBC
  0001a	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	83 c4 04	 add	 esp, 4
$LN21@AES_CBC:
  00026	33 db		 xor	 ebx, ebx
  00028	c7 47 5c 0f 00
	00 00		 mov	 DWORD PTR [edi+92], 15	; 0000000fH
  0002f	89 5f 58	 mov	 DWORD PTR [edi+88], ebx
  00032	88 5f 48	 mov	 BYTE PTR [edi+72], bl
  00035	e8 00 00 00 00	 call	 ??1ASN1@@QAE@XZ		; ASN1::~ASN1
  0003a	8d 7e 44	 lea	 edi, DWORD PTR [esi+68]
  0003d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7AlgorithmIdentifier@@6B@
  00043	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7ObjectIdentifier@@6B@
  00049	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  0004c	3b c3		 cmp	 eax, ebx
  0004e	74 09		 je	 SHORT $LN46@AES_CBC
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4
$LN46@AES_CBC:
  00059	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  0005c	51		 push	 ecx
  0005d	89 5f 50	 mov	 DWORD PTR [edi+80], ebx
  00060	89 5f 54	 mov	 DWORD PTR [edi+84], ebx
  00063	89 5f 58	 mov	 DWORD PTR [edi+88], ebx
  00066	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0006b	83 c4 04	 add	 esp, 4
  0006e	e8 00 00 00 00	 call	 ??1ASN1@@QAE@XZ		; ASN1::~ASN1
  00073	8b fe		 mov	 edi, esi
  00075	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Sequence@@6B@
  0007b	e8 00 00 00 00	 call	 ??1ASN1@@QAE@XZ		; ASN1::~ASN1
  00080	5f		 pop	 edi
  00081	5b		 pop	 ebx
  00082	c3		 ret	 0
??1AES_CBC@@QAE@XZ ENDP					; AES_CBC::~AES_CBC
PUBLIC	__$ArrayPad$
PUBLIC	?Set_AES@AES_CBC@@QAEXT__m128i@@@Z		; AES_CBC::Set_AES
; Function compile flags: /Ogtpy
;	COMDAT ?Set_AES@AES_CBC@@QAEXT__m128i@@@Z
_TEXT	SEGMENT
$T92314 = -40						; size = 4
$T92803 = -40						; size = 4
tv416 = -36						; size = 4
__xmm_IV$ = -32						; size = 16
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
?Set_AES@AES_CBC@@QAEXT__m128i@@@Z PROC			; AES_CBC::Set_AES, COMDAT
; __xmm_IV$ = xmm0

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	83 ec 34	 sub	 esp, 52			; 00000034H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 30	 mov	 DWORD PTR __$ArrayPad$[esp+52], eax
  00014	53		 push	 ebx
  00015	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00018	56		 push	 esi
  00019	57		 push	 edi

; 94   : 	//ASN.1の定義
; 95   : 	Set();

  0001a	8d 7b 28	 lea	 edi, DWORD PTR [ebx+40]
  0001d	8b c7		 mov	 eax, edi
  0001f	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR __xmm_IV$[esp+64], xmm0
  00025	89 7c 24 1c	 mov	 DWORD PTR tv416[esp+64], edi
  00029	e8 00 00 00 00	 call	 ?clear@?$vector@PAVASN1@@V?$allocator@PAVASN1@@@std@@@std@@QAEXXZ ; std::vector<ASN1 *,std::allocator<ASN1 *> >::clear
  0002e	8d 4c 24 18	 lea	 ecx, DWORD PTR $T92314[esp+64]
  00032	8d 43 44	 lea	 eax, DWORD PTR [ebx+68]
  00035	51		 push	 ecx
  00036	89 44 24 1c	 mov	 DWORD PTR $T92314[esp+68], eax
  0003a	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVASN1@@V?$allocator@PAVASN1@@@std@@@std@@QAEXABQAVASN1@@@Z ; std::vector<ASN1 *,std::allocator<ASN1 *> >::push_back

; 96   : 	vector = _xmm_IV;	//	SetIV()と同じ意味。

  0003f	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR __xmm_IV$[esp+64]

; 97   : 	IV.Set(_xmm_IV.m128i_i8,sizeof(_xmm_IV));

  00045	8d b3 04 02 00
	00		 lea	 esi, DWORD PTR [ebx+516]
  0004b	66 0f 7f 83 b0
	01 00 00	 movdqa	 XMMWORD PTR [ebx+432], xmm0
  00053	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00056	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  00059	83 f8 10	 cmp	 eax, 16			; 00000010H
  0005c	72 04		 jb	 SHORT $LN56@Set_AES
  0005e	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00060	eb 02		 jmp	 SHORT $LN57@Set_AES
$LN56@Set_AES:
  00062	8b cf		 mov	 ecx, edi
$LN57@Set_AES:
  00064	8d 54 24 20	 lea	 edx, DWORD PTR __xmm_IV$[esp+64]
  00068	3b d1		 cmp	 edx, ecx
  0006a	72 32		 jb	 SHORT $LN46@Set_AES
  0006c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0006f	72 04		 jb	 SHORT $LN60@Set_AES
  00071	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00073	eb 02		 jmp	 SHORT $LN61@Set_AES
$LN60@Set_AES:
  00075	8b cf		 mov	 ecx, edi
$LN61@Set_AES:
  00077	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0007a	03 d1		 add	 edx, ecx
  0007c	8d 4c 24 20	 lea	 ecx, DWORD PTR __xmm_IV$[esp+64]
  00080	3b d1		 cmp	 edx, ecx
  00082	76 1a		 jbe	 SHORT $LN46@Set_AES
  00084	83 f8 10	 cmp	 eax, 16			; 00000010H
  00087	72 02		 jb	 SHORT $LN64@Set_AES
  00089	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN64@Set_AES:
  0008b	6a 10		 push	 16			; 00000010H
  0008d	8d 54 24 24	 lea	 edx, DWORD PTR __xmm_IV$[esp+68]
  00091	2b d7		 sub	 edx, edi
  00093	52		 push	 edx
  00094	56		 push	 esi
  00095	8b ce		 mov	 ecx, esi
  00097	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0009c	eb 44		 jmp	 SHORT $LN134@Set_AES
$LN46@Set_AES:
  0009e	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a1	73 0d		 jae	 SHORT $LN70@Set_AES
  000a3	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000a6	50		 push	 eax
  000a7	6a 10		 push	 16			; 00000010H
  000a9	8b ce		 mov	 ecx, esi
  000ab	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
$LN70@Set_AES:
  000b0	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  000b3	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000b6	72 04		 jb	 SHORT $LN118@Set_AES
  000b8	8b 07		 mov	 eax, DWORD PTR [edi]
  000ba	eb 02		 jmp	 SHORT $LN119@Set_AES
$LN118@Set_AES:
  000bc	8b c7		 mov	 eax, edi
$LN119@Set_AES:
  000be	6a 10		 push	 16			; 00000010H
  000c0	8d 54 24 24	 lea	 edx, DWORD PTR __xmm_IV$[esp+68]
  000c4	52		 push	 edx
  000c5	51		 push	 ecx
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _memcpy_s
  000cc	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000d1	83 c4 10	 add	 esp, 16			; 00000010H
  000d4	89 46 14	 mov	 DWORD PTR [esi+20], eax
  000d7	39 46 18	 cmp	 DWORD PTR [esi+24], eax
  000da	72 02		 jb	 SHORT $LN132@Set_AES
  000dc	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN132@Set_AES:
  000de	c6 47 10 00	 mov	 BYTE PTR [edi+16], 0
$LN134@Set_AES:

; 98   : 	Set_Construct(&IV);

  000e2	8b 7c 24 1c	 mov	 edi, DWORD PTR tv416[esp+64]
  000e6	8d 44 24 18	 lea	 eax, DWORD PTR $T92803[esp+64]
  000ea	81 c3 c0 01 00
	00		 add	 ebx, 448		; 000001c0H
  000f0	50		 push	 eax
  000f1	89 5c 24 1c	 mov	 DWORD PTR $T92803[esp+68], ebx
  000f5	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVASN1@@V?$allocator@PAVASN1@@@std@@@std@@QAEXABQAVASN1@@@Z ; std::vector<ASN1 *,std::allocator<ASN1 *> >::push_back

; 99   : }

  000fa	8b 4c 24 3c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+64]
  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx
  00101	33 cc		 xor	 ecx, esp
  00103	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c2 04 00	 ret	 4
?Set_AES@AES_CBC@@QAEXT__m128i@@@Z ENDP			; AES_CBC::Set_AES
PUBLIC	??0AES_CBC@@QAE@QBD@Z				; AES_CBC::AES_CBC
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??0AES_CBC@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AES_CBC@@QAE@QBD@Z$0
__ehfuncinfo$??0AES_CBC@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0AES_CBC@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\aes_cbc.cpp
xdata$x	ENDS
;	COMDAT ??0AES_CBC@@QAE@QBD@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__strName$ = 12						; size = 4
??0AES_CBC@@QAE@QBD@Z PROC				; AES_CBC::AES_CBC, COMDAT

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0AES_CBC@@QAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00028	8b 45 0c	 mov	 eax, DWORD PTR __strName$[ebp]
  0002b	50		 push	 eax
  0002c	56		 push	 esi
  0002d	e8 00 00 00 00	 call	 ??0AlgorithmIdentifier@@QAE@QBD@Z ; AlgorithmIdentifier::AlgorithmIdentifier
  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7AES@@6B@
  00038	c7 86 a0 00 00
	00 10 00 00 00	 mov	 DWORD PTR [esi+160], 16	; 00000010H
  00042	53		 push	 ebx
  00043	51		 push	 ecx
  00044	52		 push	 edx
  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	0f a2		 cpuid
  0004c	f7 c1 00 00 00
	02		 test	 ecx, 33554432		; 02000000H
  00052	75 16		 jne	 SHORT $ChkSIMD_AESNI$96617
  00054	f7 c2 00 00 00
	04		 test	 edx, 67108864		; 04000000H
  0005a	75 07		 jne	 SHORT $ChkSIMD_SSE2$96618
  0005c	b8 00 00 00 00	 mov	 eax, 0
  00061	eb 0c		 jmp	 SHORT $ChkSIMD_END$96619
$ChkSIMD_SSE2$96618:
  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	eb 05		 jmp	 SHORT $ChkSIMD_END$96619
$ChkSIMD_AESNI$96617:
  0006a	b8 02 00 00 00	 mov	 eax, 2
$ChkSIMD_END$96619:
  0006f	5a		 pop	 edx
  00070	59		 pop	 ecx
  00071	5b		 pop	 ebx
  00072	83 f8 02	 cmp	 eax, 2
  00075	0f 94 c1	 sete	 cl
  00078	88 8e a2 01 00
	00		 mov	 BYTE PTR [esi+418], cl
  0007e	33 db		 xor	 ebx, ebx
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DHPBPBEA@Octet?5String?$AA@
  00085	8d be c0 01 00
	00		 lea	 edi, DWORD PTR [esi+448]
  0008b	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0008e	57		 push	 edi
  0008f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7AES_CBC@@6B@
  00095	e8 00 00 00 00	 call	 ??0ASN1@@QAE@QBD@Z	; ASN1::ASN1
  0009a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7OctetString@@6B@
  000a0	c7 47 5c 0f 00
	00 00		 mov	 DWORD PTR [edi+92], 15	; 0000000fH
  000a7	89 5f 58	 mov	 DWORD PTR [edi+88], ebx
  000aa	88 5f 48	 mov	 BYTE PTR [edi+72], bl

; 15   : 	mode	= CBC;

  000ad	c7 86 a8 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+168], 1

; 16   : }

  000b7	8b c6		 mov	 eax, esi
  000b9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000bc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c3	59		 pop	 ecx
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0AES_CBC@@QAE@QBD@Z$0:
  00000	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1AES@@QAE@XZ		; AES::~AES
__ehhandler$??0AES_CBC@@QAE@QBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0AES_CBC@@QAE@QBD@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0AES_CBC@@QAE@QBD@Z ENDP				; AES_CBC::AES_CBC
END

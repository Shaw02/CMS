; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\?n????j\My Project\CMS\CMS\ASN1\Algorithm\SHA-1.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?calc@SHA1@@UAEXPAX@Z				; SHA1::calc
PUBLIC	?getHash@SHA1@@UAEXPAX@Z			; SHA1::getHash
PUBLIC	?init@SHA1@@UAEXXZ				; SHA1::init
PUBLIC	??_R4SHA1@@6B@					; SHA1::`RTTI Complete Object Locator'
PUBLIC	??_R3SHA1@@8					; SHA1::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SHA1@@8					; SHA1::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SHA@@8				; SHA::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3SHA@@8					; SHA::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SHA@@8					; SHA::`RTTI Base Class Array'
PUBLIC	??_R0?AVSHA@@@8					; SHA `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@SHA1@@8				; SHA1::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVSHA1@@@8				; SHA1 `RTTI Type Descriptor'
PUBLIC	?oid@SHA1@@2PAIA				; SHA1::oid
PUBLIC	??_7SHA1@@6B@					; SHA1::`vftable'
;	COMDAT ??_7SHA1@@6B@
CONST	SEGMENT
??_7SHA1@@6B@ DD FLAT:??_R4SHA1@@6B@			; SHA1::`vftable'
	DD	FLAT:?encodeBER@Sequence@@UAEXXZ
	DD	FLAT:?Get_BERcode@ASN1@@UAEPBDXZ
	DD	FLAT:?Get_BERsize@ASN1@@UAEIXZ
	DD	FLAT:?init@SHA1@@UAEXXZ
	DD	FLAT:?final@Digest@@UAEXPAXI@Z
	DD	FLAT:?getHash@SHA1@@UAEXPAX@Z
	DD	FLAT:?calc@SHA1@@UAEXPAX@Z
CONST	ENDS
;	COMDAT ??_R4SHA1@@6B@
rdata$r	SEGMENT
??_R4SHA1@@6B@ DD 00H					; SHA1::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSHA1@@@8
	DD	FLAT:??_R3SHA1@@8
rdata$r	ENDS
;	COMDAT ??_R3SHA1@@8
rdata$r	SEGMENT
??_R3SHA1@@8 DD	00H					; SHA1::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	06H
	DD	FLAT:??_R2SHA1@@8
rdata$r	ENDS
;	COMDAT ??_R2SHA1@@8
rdata$r	SEGMENT
??_R2SHA1@@8 DD	FLAT:??_R1A@?0A@EA@SHA1@@8		; SHA1::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SHA@@8
	DD	FLAT:??_R1A@?0A@EA@Digest@@8
	DD	FLAT:??_R1A@?0A@EA@AlgorithmIdentifier@@8
	DD	FLAT:??_R1A@?0A@EA@Sequence@@8
	DD	FLAT:??_R1A@?0A@EA@ASN1@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SHA@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SHA@@8 DD FLAT:??_R0?AVSHA@@@8		; SHA::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SHA@@8
rdata$r	ENDS
;	COMDAT ??_R3SHA@@8
rdata$r	SEGMENT
??_R3SHA@@8 DD	00H					; SHA::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2SHA@@8
rdata$r	ENDS
;	COMDAT ??_R2SHA@@8
rdata$r	SEGMENT
??_R2SHA@@8 DD	FLAT:??_R1A@?0A@EA@SHA@@8		; SHA::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Digest@@8
	DD	FLAT:??_R1A@?0A@EA@AlgorithmIdentifier@@8
	DD	FLAT:??_R1A@?0A@EA@Sequence@@8
	DD	FLAT:??_R1A@?0A@EA@ASN1@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSHA@@@8
_DATA	SEGMENT
??_R0?AVSHA@@@8 DD FLAT:??_7type_info@@6B@		; SHA `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSHA@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@SHA1@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SHA1@@8 DD FLAT:??_R0?AVSHA1@@@8		; SHA1::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SHA1@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSHA1@@@8
_DATA	SEGMENT
??_R0?AVSHA1@@@8 DD FLAT:??_7type_info@@6B@		; SHA1 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSHA1@@', 00H
?oid@SHA1@@2PAIA DD 01H					; SHA1::oid
	DD	03H
	DD	0eH
	DD	03H
	DD	02H
	DD	01aH
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\sha-1.cpp
;	COMDAT ?getHash@SHA1@@UAEXPAX@Z
_TEXT	SEGMENT
_result$ = 8						; size = 4
?getHash@SHA1@@UAEXPAX@Z PROC				; SHA1::getHash, COMDAT
; _this$ = ecx

; 190  : 				int*	ir	= (int *)result;
; 191  : 	unsigned	int		i	= 0;
; 192  : 	unsigned	int		n;
; 193  : 
; 194  : 	while(i < (sizeof(H)/sizeof(int))){
; 195  : 		//1Byteずつ処理していたら、メモリアクセスが多くなってCPU処理にペナルティが発生する。
; 196  : 		n		= H[i];

  00000	8b 81 b0 00 00
	00		 mov	 eax, DWORD PTR [ecx+176]
  00006	56		 push	 esi

; 197  : 		ir[i]	= ((n>>24) & 0xFF) | ((n>>8) & 0xFF00) | ((n & 0xFF00)<<8) | ((n & 0xFF)<<24);

  00007	8b f0		 mov	 esi, eax
  00009	81 e6 00 00 ff
	00		 and	 esi, 16711680		; 00ff0000H
  0000f	8b d0		 mov	 edx, eax
  00011	c1 ea 10	 shr	 edx, 16			; 00000010H
  00014	0b f2		 or	 esi, edx
  00016	c1 ee 08	 shr	 esi, 8
  00019	8b d0		 mov	 edx, eax
  0001b	57		 push	 edi
  0001c	c1 e0 10	 shl	 eax, 16			; 00000010H
  0001f	81 e2 00 ff 00
	00		 and	 edx, 65280		; 0000ff00H
  00025	0b d0		 or	 edx, eax
  00027	c1 e2 08	 shl	 edx, 8
  0002a	0b f2		 or	 esi, edx
  0002c	8b 54 24 0c	 mov	 edx, DWORD PTR _result$[esp+4]
  00030	89 32		 mov	 DWORD PTR [edx], esi
  00032	8b 81 b4 00 00
	00		 mov	 eax, DWORD PTR [ecx+180]
  00038	8b f0		 mov	 esi, eax
  0003a	81 e6 00 00 ff
	00		 and	 esi, 16711680		; 00ff0000H
  00040	8b f8		 mov	 edi, eax
  00042	c1 ef 10	 shr	 edi, 16			; 00000010H
  00045	0b f7		 or	 esi, edi
  00047	c1 ee 08	 shr	 esi, 8
  0004a	8b f8		 mov	 edi, eax
  0004c	81 e7 00 ff 00
	00		 and	 edi, 65280		; 0000ff00H
  00052	c1 e0 10	 shl	 eax, 16			; 00000010H
  00055	0b f8		 or	 edi, eax
  00057	c1 e7 08	 shl	 edi, 8
  0005a	0b f7		 or	 esi, edi
  0005c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0005f	8b 81 b8 00 00
	00		 mov	 eax, DWORD PTR [ecx+184]
  00065	8b f0		 mov	 esi, eax
  00067	81 e6 00 00 ff
	00		 and	 esi, 16711680		; 00ff0000H
  0006d	8b f8		 mov	 edi, eax
  0006f	c1 ef 10	 shr	 edi, 16			; 00000010H
  00072	0b f7		 or	 esi, edi
  00074	c1 ee 08	 shr	 esi, 8
  00077	8b f8		 mov	 edi, eax
  00079	81 e7 00 ff 00
	00		 and	 edi, 65280		; 0000ff00H
  0007f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00082	0b f8		 or	 edi, eax
  00084	c1 e7 08	 shl	 edi, 8
  00087	0b f7		 or	 esi, edi
  00089	89 72 08	 mov	 DWORD PTR [edx+8], esi
  0008c	8b 81 bc 00 00
	00		 mov	 eax, DWORD PTR [ecx+188]
  00092	8b f0		 mov	 esi, eax
  00094	81 e6 00 00 ff
	00		 and	 esi, 16711680		; 00ff0000H
  0009a	8b f8		 mov	 edi, eax
  0009c	c1 ef 10	 shr	 edi, 16			; 00000010H
  0009f	0b f7		 or	 esi, edi
  000a1	8b f8		 mov	 edi, eax
  000a3	c1 ee 08	 shr	 esi, 8
  000a6	81 e7 00 ff 00
	00		 and	 edi, 65280		; 0000ff00H
  000ac	c1 e0 10	 shl	 eax, 16			; 00000010H
  000af	0b f8		 or	 edi, eax
  000b1	c1 e7 08	 shl	 edi, 8
  000b4	0b f7		 or	 esi, edi
  000b6	89 72 0c	 mov	 DWORD PTR [edx+12], esi
  000b9	8b 81 c0 00 00
	00		 mov	 eax, DWORD PTR [ecx+192]
  000bf	8b c8		 mov	 ecx, eax
  000c1	8b f0		 mov	 esi, eax
  000c3	c1 ee 10	 shr	 esi, 16			; 00000010H
  000c6	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  000cc	0b ce		 or	 ecx, esi
  000ce	8b f0		 mov	 esi, eax
  000d0	81 e6 00 ff 00
	00		 and	 esi, 65280		; 0000ff00H
  000d6	c1 e0 10	 shl	 eax, 16			; 00000010H
  000d9	0b f0		 or	 esi, eax
  000db	c1 e6 08	 shl	 esi, 8
  000de	c1 e9 08	 shr	 ecx, 8
  000e1	0b ce		 or	 ecx, esi
  000e3	5f		 pop	 edi
  000e4	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  000e7	5e		 pop	 esi

; 198  : 		i++;
; 199  : 	}
; 200  : }

  000e8	c2 04 00	 ret	 4
?getHash@SHA1@@UAEXPAX@Z ENDP				; SHA1::getHash
_TEXT	ENDS
PUBLIC	_this$GSCopy$
; Function compile flags: /Ogtpy
;	COMDAT ?calc@SHA1@@UAEXPAX@Z
_TEXT	SEGMENT
_t$ = -373						; size = 1
tv685 = -372						; size = 4
tv425 = -372						; size = 4
_X$ = -368						; size = 20
tv166 = -328						; size = 4
_this$GSCopy$ = -324					; size = 4
_w$ = -320						; size = 320
_data$ = 8						; size = 4
?calc@SHA1@@UAEXPAX@Z PROC				; SHA1::calc, COMDAT
; _this$ = ecx

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	81 ec 84 01 00
	00		 sub	 esp, 388		; 00000184H
  0000c	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  0000f	53		 push	 ebx
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b f9		 mov	 edi, ecx

; 75   : 
; 76   : 	unsigned int*	iData = (unsigned int*)data;
; 77   : 	unsigned char	t=0;
; 78   : 
; 79   : 	__m128i	_m[4];
; 80   : 
; 81   : 	__declspec(align(8))	unsigned int	w[80];
; 82   : 	__declspec(align(16))	unsigned int	X[5];
; 83   : 							unsigned int	T;
; 84   : 
; 85   : #define	a	X[0]
; 86   : #define	b	X[1]
; 87   : #define	c	X[2]
; 88   : #define	d	X[3]
; 89   : #define	e	X[4]
; 90   : 	
; 91   : 	//----------------------------
; 92   : 	//入力データの拡張
; 93   : 	do{
; 94   : 		T = iData[t];

  00014	8d 4c 24 50	 lea	 ecx, DWORD PTR _w$[esp+400]

; 95   : 		w[t] = ((T>>24)&0xFF | ((T>>16)&0xFF)<<8 | ((T>>8)&0xFF)<<16 | (T&0xFF)<<24);
; 96   : 		t ++;
; 97   : 	} while(t<16);

  00018	8b c1		 mov	 eax, ecx
  0001a	2b d0		 sub	 edx, eax
  0001c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H

; 159  : 
; 160  : 	do{
; 161  : 		T = ROTL(5,a) + Parity(b,c,d) + e + 0xca62c1d6 + w[t];

  00021	89 7c 24 4c	 mov	 DWORD PTR _this$GSCopy$[esp+400], edi
  00025	89 44 24 1c	 mov	 DWORD PTR tv425[esp+400], eax
  00029	88 44 24 1b	 mov	 BYTE PTR _t$[esp+400], al
  0002d	8d 49 00	 npad	 3
$LL18@calc@2:
  00030	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00033	8b f0		 mov	 esi, eax
  00035	81 e6 00 00 ff
	00		 and	 esi, 16711680		; 00ff0000H
  0003b	8b d8		 mov	 ebx, eax
  0003d	c1 eb 10	 shr	 ebx, 16			; 00000010H
  00040	0b f3		 or	 esi, ebx
  00042	8b d8		 mov	 ebx, eax
  00044	81 e3 00 ff 00
	00		 and	 ebx, 65280		; 0000ff00H
  0004a	c1 e0 10	 shl	 eax, 16			; 00000010H
  0004d	0b d8		 or	 ebx, eax
  0004f	c1 ee 08	 shr	 esi, 8
  00052	c1 e3 08	 shl	 ebx, 8
  00055	0b f3		 or	 esi, ebx
  00057	89 31		 mov	 DWORD PTR [ecx], esi
  00059	83 c1 04	 add	 ecx, 4
  0005c	83 6c 24 1c 01	 sub	 DWORD PTR tv425[esp+400], 1
  00061	75 cd		 jne	 SHORT $LL18@calc@2

; 95   : 		w[t] = ((T>>24)&0xFF | ((T>>16)&0xFF)<<8 | ((T>>8)&0xFF)<<16 | (T&0xFF)<<24);
; 96   : 		t ++;
; 97   : 	} while(t<16);

  00063	8a 4c 24 1b	 mov	 cl, BYTE PTR _t$[esp+400]
  00067	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL15@calc@2:

; 98   : 
; 99   : 	do{
; 100  : 		_m[0] = _mm_loadl_epi64((__m128i*)&w[t-3]);

  00070	0f b6 c1	 movzx	 eax, cl
  00073	f3 0f 7e 44 84
	44		 movq	 xmm0, QWORD PTR _w$[esp+eax*4+388]

; 101  : 		_m[1] = _mm_loadl_epi64((__m128i*)&w[t-8]);

  00079	f3 0f 7e 54 84
	30		 movq	 xmm2, QWORD PTR _w$[esp+eax*4+368]

; 102  : 		_m[2] = _mm_loadl_epi64((__m128i*)&w[t-14]);

  0007f	f3 0f 7e 4c 84
	18		 movq	 xmm1, QWORD PTR _w$[esp+eax*4+344]

; 103  : 		_m[3] = _mm_loadl_epi64((__m128i*)&w[t-16]);

  00085	f3 0f 7e 5c 84
	10		 movq	 xmm3, QWORD PTR _w$[esp+eax*4+336]

; 104  : 
; 105  : 		_mm_storel_epi64((__m128i*)&w[t], _mm_ROTLD(1, _mm_xor_si128(_mm_xor_si128(_m[0],_m[1]), _mm_xor_si128(_m[2],_m[3]))));

  0008b	66 0f ef cb	 pxor	 xmm1, xmm3
  0008f	66 0f ef c2	 pxor	 xmm0, xmm2
  00093	66 0f ef c1	 pxor	 xmm0, xmm1
  00097	66 0f 6f c8	 movdqa	 xmm1, xmm0

; 106  : 		t += 2;

  0009b	80 c1 02	 add	 cl, 2
  0009e	66 0f 72 f1 01	 pslld	 xmm1, 1
  000a3	66 0f 72 d0 1f	 psrld	 xmm0, 31		; 0000001fH
  000a8	66 0f eb c8	 por	 xmm1, xmm0
  000ac	66 0f d6 4c 84
	50		 movq	 QWORD PTR _w$[esp+eax*4+400], xmm1

; 107  : 	} while(t<80);

  000b2	80 f9 50	 cmp	 cl, 80			; 00000050H
  000b5	72 b9		 jb	 SHORT $LL15@calc@2

; 108  : 
; 109  : 
; 110  : 
; 111  : 	//----------------------------
; 112  : 	//ハッシュ計算
; 113  : 
; 114  : //	メモリに入るので、逆に遅くなる。
; 115  : //	memcpy(X,H,sizeof(H));
; 116  : 
; 117  : //	こうすると、まずはレジスターに入る。
; 118  : 	a = H[0];
; 119  : 	b = H[1];
; 120  : 	c = H[2];
; 121  : 	d = H[3];
; 122  : 	e = H[4];

  000b7	8b 97 c0 00 00
	00		 mov	 edx, DWORD PTR [edi+192]
  000bd	8b 8f b0 00 00
	00		 mov	 ecx, DWORD PTR [edi+176]
  000c3	8b 87 b4 00 00
	00		 mov	 eax, DWORD PTR [edi+180]
  000c9	8b b7 bc 00 00
	00		 mov	 esi, DWORD PTR [edi+188]
  000cf	89 54 24 30	 mov	 DWORD PTR _X$[esp+416], edx
  000d3	8d 54 24 50	 lea	 edx, DWORD PTR _w$[esp+400]
  000d7	89 54 24 1c	 mov	 DWORD PTR tv685[esp+400], edx
  000db	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  000e0	89 4c 24 20	 mov	 DWORD PTR _X$[esp+400], ecx
  000e4	8b 8f b8 00 00
	00		 mov	 ecx, DWORD PTR [edi+184]
  000ea	89 54 24 48	 mov	 DWORD PTR tv166[esp+400], edx

; 123  : 
; 124  : 	t=0;
; 125  : 	do{
; 126  : 		T = ROTL(5,a) + Ch(b,c,d) + e + 0x5a827999 + w[t];
; 127  : //		SIMD化すると、メモリに入るので、逆に遅い模様。
; 128  : //		_mm_storeu_si128((__m128i*)&b, _mm_loadu_si128((__m128i*)&a));
; 129  : //		c = ROTL(30,c);
; 130  : 
; 131  : //		メモリに入れないで、汎用レジスターで計算してくれる。
; 132  : 		e = d;
; 133  : 		d = c;
; 134  : 		c = ROTL(30,b);
; 135  : 		b = a;
; 136  : 		a = T;
; 137  : 		t++;
; 138  : 	} while(t<20);

  000ee	88 54 24 1b	 mov	 BYTE PTR _t$[esp+400], dl
$LN12@calc@2:
  000f2	8b 54 24 20	 mov	 edx, DWORD PTR _X$[esp+400]
  000f6	8b f8		 mov	 edi, eax
  000f8	f7 d7		 not	 edi
  000fa	23 fe		 and	 edi, esi
  000fc	8b d9		 mov	 ebx, ecx
  000fe	23 d8		 and	 ebx, eax
  00100	33 fb		 xor	 edi, ebx
  00102	c1 c2 05	 rol	 edx, 5
  00105	03 d7		 add	 edx, edi
  00107	8b 7c 24 1c	 mov	 edi, DWORD PTR tv685[esp+400]
  0010b	03 17		 add	 edx, DWORD PTR [edi]
  0010d	8b 7c 24 30	 mov	 edi, DWORD PTR _X$[esp+416]
  00111	83 44 24 1c 04	 add	 DWORD PTR tv685[esp+400], 4
  00116	8d bc 3a 99 79
	82 5a		 lea	 edi, DWORD PTR [edx+edi+1518500249]
  0011d	c1 c8 02	 ror	 eax, 2
  00120	83 6c 24 48 01	 sub	 DWORD PTR tv166[esp+400], 1
  00125	8b d6		 mov	 edx, esi
  00127	8b f1		 mov	 esi, ecx
  00129	8b c8		 mov	 ecx, eax
  0012b	8b 44 24 20	 mov	 eax, DWORD PTR _X$[esp+400]
  0012f	89 54 24 30	 mov	 DWORD PTR _X$[esp+416], edx
  00133	89 7c 24 20	 mov	 DWORD PTR _X$[esp+400], edi
  00137	75 b9		 jne	 SHORT $LN12@calc@2
  00139	8a 5c 24 1b	 mov	 bl, BYTE PTR _t$[esp+400]
  0013d	8d 49 00	 npad	 3
$LL9@calc@2:

; 139  : 
; 140  : 	do{
; 141  : 		T = ROTL(5,a) + Parity(b,c,d) + e + 0x6ed9eba1 + w[t];

  00140	0f b6 db	 movzx	 ebx, bl
  00143	c1 c7 05	 rol	 edi, 5
  00146	03 7c 9c 50	 add	 edi, DWORD PTR _w$[esp+ebx*4+400]
  0014a	8b de		 mov	 ebx, esi
  0014c	33 d9		 xor	 ebx, ecx
  0014e	33 d8		 xor	 ebx, eax
  00150	03 fa		 add	 edi, edx
  00152	8d bc 3b a1 eb
	d9 6e		 lea	 edi, DWORD PTR [ebx+edi+1859775393]

; 143  : 		d = c;
; 144  : 		c = ROTL(30,b);
; 145  : 		b = a;
; 146  : 		a = T;
; 147  : 		t++;

  00159	8a 5c 24 1b	 mov	 bl, BYTE PTR _t$[esp+400]
  0015d	c1 c8 02	 ror	 eax, 2
  00160	8b d6		 mov	 edx, esi
  00162	fe c3		 inc	 bl
  00164	8b f1		 mov	 esi, ecx
  00166	8b c8		 mov	 ecx, eax
  00168	8b 44 24 20	 mov	 eax, DWORD PTR _X$[esp+400]
  0016c	89 7c 24 20	 mov	 DWORD PTR _X$[esp+400], edi
  00170	88 5c 24 1b	 mov	 BYTE PTR _t$[esp+400], bl

; 148  : 	} while(t<40);

  00174	80 fb 28	 cmp	 bl, 40			; 00000028H
  00177	72 c7		 jb	 SHORT $LL9@calc@2

; 142  : 		e = d;

  00179	89 54 24 30	 mov	 DWORD PTR _X$[esp+416], edx
  0017d	8d 49 00	 npad	 3
$LL6@calc@2:

; 149  : 
; 150  : 	do{
; 151  : 		T = ROTL(5,a) + Maj(b,c,d) + e + 0x8f1bbcdc + w[t];

  00180	8b d1		 mov	 edx, ecx
  00182	33 d0		 xor	 edx, eax
  00184	23 d6		 and	 edx, esi
  00186	8b d9		 mov	 ebx, ecx
  00188	23 d8		 and	 ebx, eax
  0018a	33 d3		 xor	 edx, ebx
  0018c	0f b6 5c 24 1b	 movzx	 ebx, BYTE PTR _t$[esp+400]
  00191	03 54 9c 50	 add	 edx, DWORD PTR _w$[esp+ebx*4+400]
  00195	c1 c7 05	 rol	 edi, 5
  00198	03 7c 24 30	 add	 edi, DWORD PTR _X$[esp+416]

; 152  : 		e = d;
; 153  : 		d = c;
; 154  : 		c = ROTL(30,b);

  0019c	c1 c8 02	 ror	 eax, 2
  0019f	8d bc 3a dc bc
	1b 8f		 lea	 edi, DWORD PTR [edx+edi-1894007588]

; 155  : 		b = a;
; 156  : 		a = T;
; 157  : 		t++;

  001a6	8a 54 24 1b	 mov	 dl, BYTE PTR _t$[esp+400]
  001aa	89 74 24 30	 mov	 DWORD PTR _X$[esp+416], esi
  001ae	fe c2		 inc	 dl
  001b0	8b f1		 mov	 esi, ecx
  001b2	8b c8		 mov	 ecx, eax
  001b4	8b 44 24 20	 mov	 eax, DWORD PTR _X$[esp+400]
  001b8	89 7c 24 20	 mov	 DWORD PTR _X$[esp+400], edi
  001bc	88 54 24 1b	 mov	 BYTE PTR _t$[esp+400], dl

; 158  : 	} while(t<60);

  001c0	80 fa 3c	 cmp	 dl, 60			; 0000003cH
  001c3	72 bb		 jb	 SHORT $LL6@calc@2
$LL3@calc@2:

; 159  : 
; 160  : 	do{
; 161  : 		T = ROTL(5,a) + Parity(b,c,d) + e + 0xca62c1d6 + w[t];

  001c5	0f b6 d2	 movzx	 edx, dl
  001c8	8b 54 94 50	 mov	 edx, DWORD PTR _w$[esp+edx*4+400]
  001cc	8b de		 mov	 ebx, esi
  001ce	33 d9		 xor	 ebx, ecx
  001d0	c1 c7 05	 rol	 edi, 5
  001d3	03 7c 24 30	 add	 edi, DWORD PTR _X$[esp+416]
  001d7	33 d8		 xor	 ebx, eax
  001d9	03 d3		 add	 edx, ebx
  001db	8d bc 3a d6 c1
	62 ca		 lea	 edi, DWORD PTR [edx+edi-899497514]

; 162  : 		e = d;
; 163  : 		d = c;
; 164  : 		c = ROTL(30,b);
; 165  : 		b = a;
; 166  : 		a = T;
; 167  : 		t++;

  001e2	8a 54 24 1b	 mov	 dl, BYTE PTR _t$[esp+400]
  001e6	c1 c8 02	 ror	 eax, 2
  001e9	8b de		 mov	 ebx, esi
  001eb	fe c2		 inc	 dl
  001ed	8b f1		 mov	 esi, ecx
  001ef	8b c8		 mov	 ecx, eax
  001f1	8b 44 24 20	 mov	 eax, DWORD PTR _X$[esp+400]
  001f5	89 5c 24 30	 mov	 DWORD PTR _X$[esp+416], ebx
  001f9	89 7c 24 20	 mov	 DWORD PTR _X$[esp+400], edi
  001fd	88 54 24 1b	 mov	 BYTE PTR _t$[esp+400], dl

; 168  : 	} while(t<80);

  00201	80 fa 50	 cmp	 dl, 80			; 00000050H
  00204	72 bf		 jb	 SHORT $LL3@calc@2
  00206	89 44 24 24	 mov	 DWORD PTR _X$[esp+404], eax

; 169  : 
; 170  : 	//でも、加算はSIMD化しておく。
; 171  : 	_mm_storeu_si128((__m128i*)&H ,_mm_add_epi32(_mm_loadu_si128((__m128i*)&H), _mm_load_si128((__m128i*)&X)));

  0020a	8b 44 24 4c	 mov	 eax, DWORD PTR _this$GSCopy$[esp+400]
  0020e	f3 0f 6f 80 b0
	00 00 00	 movdqu	 xmm0, XMMWORD PTR [eax+176]
  00216	89 74 24 2c	 mov	 DWORD PTR _X$[esp+412], esi
  0021a	89 4c 24 28	 mov	 DWORD PTR _X$[esp+408], ecx
  0021e	66 0f 6f 4c 24
	20		 movdqa	 xmm1, XMMWORD PTR _X$[esp+400]

; 172  : 
; 173  : //	H[0] += a;
; 174  : //	H[1] += b;
; 175  : //	H[2] += c;
; 176  : //	H[3] += d;
; 177  : 	H[4] += e;
; 178  : 
; 179  : }

  00224	5f		 pop	 edi
  00225	66 0f fe c1	 paddd	 xmm0, xmm1
  00229	f3 0f 7f 80 b0
	00 00 00	 movdqu	 XMMWORD PTR [eax+176], xmm0
  00231	01 98 c0 00 00
	00		 add	 DWORD PTR [eax+192], ebx
  00237	5e		 pop	 esi
  00238	5b		 pop	 ebx
  00239	8b e5		 mov	 esp, ebp
  0023b	5d		 pop	 ebp
  0023c	c2 04 00	 ret	 4
?calc@SHA1@@UAEXPAX@Z ENDP				; SHA1::calc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?init@SHA1@@UAEXXZ
_TEXT	SEGMENT
?init@SHA1@@UAEXXZ PROC					; SHA1::init, COMDAT
; _this$ = ecx

; 57   : 	iCountBlock = 0;

  00000	c7 81 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+160], 0

; 58   : 	H[0] = 0x67452301;

  0000a	c7 81 b0 00 00
	00 01 23 45 67	 mov	 DWORD PTR [ecx+176], 1732584193 ; 67452301H

; 59   : 	H[1] = 0xefcdab89;

  00014	c7 81 b4 00 00
	00 89 ab cd ef	 mov	 DWORD PTR [ecx+180], -271733879 ; efcdab89H

; 60   : 	H[2] = 0x98badcfe;

  0001e	c7 81 b8 00 00
	00 fe dc ba 98	 mov	 DWORD PTR [ecx+184], -1732584194 ; 98badcfeH

; 61   : 	H[3] = 0x10325476;

  00028	c7 81 bc 00 00
	00 76 54 32 10	 mov	 DWORD PTR [ecx+188], 271733878 ; 10325476H

; 62   : 	H[4] = 0xc3d2e1f0;

  00032	c7 81 c0 00 00
	00 f0 e1 d2 c3	 mov	 DWORD PTR [ecx+192], -1009589776 ; c3d2e1f0H

; 63   : 
; 64   : }

  0003c	c3		 ret	 0
?init@SHA1@@UAEXXZ ENDP					; SHA1::init
PUBLIC	??1SHA1@@QAE@XZ					; SHA1::~SHA1
; Function compile flags: /Ogtpy
;	COMDAT ??1SHA1@@QAE@XZ
_TEXT	SEGMENT
??1SHA1@@QAE@XZ PROC					; SHA1::~SHA1, COMDAT

; 29   : {

  00000	56		 push	 esi

; 30   : }

  00001	be 00 00 00 00	 mov	 esi, OFFSET ?cSHA1@PKCS7@@2VSHA1@@A ; PKCS7::cSHA1
  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?cSHA1@PKCS7@@2VSHA1@@A, OFFSET ??_7SHA1@@6B@
  00010	e8 00 00 00 00	 call	 ??1SHA@@QAE@XZ		; SHA::~SHA
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??1SHA1@@QAE@XZ ENDP					; SHA1::~SHA1
PUBLIC	?Set_SHA1@SHA1@@QAEXXZ				; SHA1::Set_SHA1
; Function compile flags: /Ogtpy
;	COMDAT ?Set_SHA1@SHA1@@QAEXXZ
_TEXT	SEGMENT
$T90553 = -4						; size = 4
?Set_SHA1@SHA1@@QAEXXZ PROC				; SHA1::Set_SHA1, COMDAT

; 40   : {

  00000	51		 push	 ecx
  00001	57		 push	 edi

; 41   : 	szHash = SHA1_HashSize;
; 42   : 
; 43   : 	//ASN.1の定義
; 44   : 	Set();

  00002	b8 28 00 00 00	 mov	 eax, OFFSET ?cSHA1@PKCS7@@2VSHA1@@A+40
  00007	c7 05 a8 00 00
	00 14 00 00 00	 mov	 DWORD PTR ?cSHA1@PKCS7@@2VSHA1@@A+168, 20 ; 00000014H
  00011	e8 00 00 00 00	 call	 ?clear@?$vector@PAVASN1@@V?$allocator@PAVASN1@@@std@@@std@@QAEXXZ ; std::vector<ASN1 *,std::allocator<ASN1 *> >::clear
  00016	8d 44 24 04	 lea	 eax, DWORD PTR $T90553[esp+8]
  0001a	50		 push	 eax
  0001b	bf 28 00 00 00	 mov	 edi, OFFSET ?cSHA1@PKCS7@@2VSHA1@@A+40
  00020	c7 44 24 08 44
	00 00 00	 mov	 DWORD PTR $T90553[esp+12], OFFSET ?cSHA1@PKCS7@@2VSHA1@@A+68
  00028	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVASN1@@V?$allocator@PAVASN1@@@std@@@std@@QAEXABQAVASN1@@@Z ; std::vector<ASN1 *,std::allocator<ASN1 *> >::push_back
  0002d	5f		 pop	 edi

; 45   : //	Set_Construct(&null);
; 46   : }

  0002e	59		 pop	 ecx
  0002f	c3		 ret	 0
?Set_SHA1@SHA1@@QAEXXZ ENDP				; SHA1::Set_SHA1
PUBLIC	??0SHA1@@QAE@QBD@Z				; SHA1::SHA1
;	COMDAT xdata$x
; File i:\渡部篤史\my project\cms\cms\asn1\asn1.cpp
xdata$x	SEGMENT
__unwindtable$??0SHA1@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SHA1@@QAE@QBD@Z$0
__ehfuncinfo$??0SHA1@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SHA1@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File i:\渡部篤史\my project\cms\cms\asn1\algorithm\sha-1.cpp
xdata$x	ENDS
;	COMDAT ??0SHA1@@QAE@QBD@Z
_TEXT	SEGMENT
$T96075 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0SHA1@@QAE@QBD@Z PROC					; SHA1::SHA1, COMDAT

; 16   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0SHA1@@QAE@QBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 08	 sub	 esp, 8
  00011	57		 push	 edi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c4		 xor	 eax, esp
  00019	50		 push	 eax
  0001a	8d 44 24 10	 lea	 eax, DWORD PTR __$EHRec$[esp+28]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_05HJMENKNE@SHA?91?$AA@
  00029	68 00 00 00 00	 push	 OFFSET ?cSHA1@PKCS7@@2VSHA1@@A ; PKCS7::cSHA1
  0002e	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _this$[esp+36], OFFSET ?cSHA1@PKCS7@@2VSHA1@@A ; PKCS7::cSHA1
  00036	e8 00 00 00 00	 call	 ??0SHA@@QAE@QBD@Z	; SHA::SHA

; 17   : 	Set_oid(oid,sizeof(oid)/sizeof(int));

  0003b	6a 06		 push	 6
  0003d	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+40], 0
  00045	68 00 00 00 00	 push	 OFFSET ?oid@SHA1@@2PAIA	; SHA1::oid
  0004a	b8 44 00 00 00	 mov	 eax, OFFSET ?cSHA1@PKCS7@@2VSHA1@@A+68
  0004f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?cSHA1@PKCS7@@2VSHA1@@A, OFFSET ??_7SHA1@@6B@
  00059	e8 00 00 00 00	 call	 ?Set@ObjectIdentifier@@QAEXQAII@Z ; ObjectIdentifier::Set

; 18   : 	Set_SHA1();

  0005e	b8 28 00 00 00	 mov	 eax, OFFSET ?cSHA1@PKCS7@@2VSHA1@@A+40
  00063	c7 05 a8 00 00
	00 14 00 00 00	 mov	 DWORD PTR ?cSHA1@PKCS7@@2VSHA1@@A+168, 20 ; 00000014H
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVASN1@@V?$allocator@PAVASN1@@@std@@@std@@QAEXXZ ; std::vector<ASN1 *,std::allocator<ASN1 *> >::clear
  00072	8d 44 24 08	 lea	 eax, DWORD PTR $T96075[esp+28]
  00076	50		 push	 eax
  00077	bf 28 00 00 00	 mov	 edi, OFFSET ?cSHA1@PKCS7@@2VSHA1@@A+40
  0007c	c7 44 24 0c 44
	00 00 00	 mov	 DWORD PTR $T96075[esp+32], OFFSET ?cSHA1@PKCS7@@2VSHA1@@A+68
  00084	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVASN1@@V?$allocator@PAVASN1@@@std@@@std@@QAEXABQAVASN1@@@Z ; std::vector<ASN1 *,std::allocator<ASN1 *> >::push_back

; 19   : }

  00089	b8 00 00 00 00	 mov	 eax, OFFSET ?cSHA1@PKCS7@@2VSHA1@@A ; PKCS7::cSHA1
  0008e	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  00092	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00099	59		 pop	 ecx
  0009a	5f		 pop	 edi
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
  0009e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SHA1@@QAE@QBD@Z$0:
  00000	8b 75 f0	 mov	 esi, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1SHA@@QAE@XZ		; SHA::~SHA
__ehhandler$??0SHA1@@QAE@QBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 f4	 lea	 eax, DWORD PTR [edx-12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SHA1@@QAE@QBD@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SHA1@@QAE@QBD@Z ENDP					; SHA1::SHA1
END

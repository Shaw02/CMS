; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\?n????j\My Project\CMS\CMS\ASN1\Algorithm\DES_EDE3.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?decrypt@DES_EDE3@@UAEXPAX@Z			; DES_EDE3::decrypt
PUBLIC	?encrypt@DES_EDE3@@UAEXPAX@Z			; DES_EDE3::encrypt
PUBLIC	?Set_Key@DES_EDE3@@UAEXPAX@Z			; DES_EDE3::Set_Key
PUBLIC	??_R4DES_EDE3@@6B@				; DES_EDE3::`RTTI Complete Object Locator'
PUBLIC	??_R3DES_EDE3@@8				; DES_EDE3::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DES_EDE3@@8				; DES_EDE3::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DES_EDE3@@8			; DES_EDE3::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVDES_EDE3@@@8				; DES_EDE3 `RTTI Type Descriptor'
PUBLIC	??_7DES_EDE3@@6B@				; DES_EDE3::`vftable'
;	COMDAT ??_7DES_EDE3@@6B@
CONST	SEGMENT
??_7DES_EDE3@@6B@ DD FLAT:??_R4DES_EDE3@@6B@		; DES_EDE3::`vftable'
	DD	FLAT:?encodeBER@Sequence@@UAEXXZ
	DD	FLAT:?Get_BERcode@ASN1@@UAEPBDXZ
	DD	FLAT:?Get_BERsize@ASN1@@UAEIXZ
	DD	FLAT:?Set_Key@DES_EDE3@@UAEXPAX@Z
	DD	FLAT:?Clear_Key@DES@@UAEXXZ
	DD	FLAT:?init@Encryption@@UAEXXZ
	DD	FLAT:?encrypt@DES_EDE3@@UAEXPAX@Z
	DD	FLAT:?decrypt@DES_EDE3@@UAEXPAX@Z
	DD	FLAT:?encrypt_ecb@DES@@UAEXPAX@Z
	DD	FLAT:?decrypt_ecb@DES@@UAEXPAX@Z
	DD	FLAT:?SetIV@Encryption@@UAEXPAX@Z
	DD	FLAT:?encipher@Encryption@@UAEXPAXI@Z
	DD	FLAT:?decipher@Encryption@@UAEXPAXI@Z
	DD	FLAT:?encipher_last@Encryption@@UAEHPAXI@Z
	DD	FLAT:?decipher_last@Encryption@@UAEHPAXI@Z
	DD	FLAT:?KeyWrap@Encryption@@UAEHPAXI@Z
	DD	FLAT:?KeyUnWrap@Encryption@@UAEHPAXI@Z
	DD	FLAT:?GetKey@Encryption@@UAEPAXXZ
	DD	FLAT:?GetEncrptedKey@Encryption@@UAEPAXXZ
CONST	ENDS
;	COMDAT ??_R4DES_EDE3@@6B@
rdata$r	SEGMENT
??_R4DES_EDE3@@6B@ DD 00H				; DES_EDE3::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDES_EDE3@@@8
	DD	FLAT:??_R3DES_EDE3@@8
rdata$r	ENDS
;	COMDAT ??_R3DES_EDE3@@8
rdata$r	SEGMENT
??_R3DES_EDE3@@8 DD 00H					; DES_EDE3::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	06H
	DD	FLAT:??_R2DES_EDE3@@8
rdata$r	ENDS
;	COMDAT ??_R2DES_EDE3@@8
rdata$r	SEGMENT
??_R2DES_EDE3@@8 DD FLAT:??_R1A@?0A@EA@DES_EDE3@@8	; DES_EDE3::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DES@@8
	DD	FLAT:??_R1A@?0A@EA@Encryption@@8
	DD	FLAT:??_R1A@?0A@EA@AlgorithmIdentifier@@8
	DD	FLAT:??_R1A@?0A@EA@Sequence@@8
	DD	FLAT:??_R1A@?0A@EA@ASN1@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@DES_EDE3@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DES_EDE3@@8 DD FLAT:??_R0?AVDES_EDE3@@@8	; DES_EDE3::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DES_EDE3@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDES_EDE3@@@8
_DATA	SEGMENT
??_R0?AVDES_EDE3@@@8 DD FLAT:??_7type_info@@6B@		; DES_EDE3 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDES_EDE3@@', 00H
; Function compile flags: /Ogtpy
; File i:\ìnïîìƒéj\my project\cms\cms\asn1\algorithm\des_ede3.cpp
;	COMDAT ?Set_Key@DES_EDE3@@UAEXPAX@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
?Set_Key@DES_EDE3@@UAEXPAX@Z PROC			; DES_EDE3::Set_Key, COMDAT
; _this$ = ecx

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi

; 38   : 	unsigned __int64* cKey =	(unsigned __int64 *)key;
; 39   : 	
; 40   : 	KeyExpansion(&cKey[0], k);

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _key$[ebp]
  0000d	8d 86 b0 00 00
	00		 lea	 eax, DWORD PTR [esi+176]
  00013	50		 push	 eax
  00014	8b c7		 mov	 eax, edi
  00016	e8 00 00 00 00	 call	 ?KeyExpansion@DES@@QAEXPAXQA_K@Z ; DES::KeyExpansion

; 41   : 	KeyExpansion(&cKey[1], k2);

  0001b	8d 8e 30 01 00
	00		 lea	 ecx, DWORD PTR [esi+304]
  00021	51		 push	 ecx
  00022	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00025	e8 00 00 00 00	 call	 ?KeyExpansion@DES@@QAEXPAXQA_K@Z ; DES::KeyExpansion

; 42   : 	KeyExpansion(&cKey[2], k3);

  0002a	81 c6 b0 01 00
	00		 add	 esi, 432		; 000001b0H
  00030	56		 push	 esi
  00031	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  00034	e8 00 00 00 00	 call	 ?KeyExpansion@DES@@QAEXPAXQA_K@Z ; DES::KeyExpansion

; 43   : 
; 44   : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?Set_Key@DES_EDE3@@UAEXPAX@Z ENDP			; DES_EDE3::Set_Key
PUBLIC	?InvCipher3@DES_EDE3@@QAE_K_K@Z			; DES_EDE3::InvCipher3
; Function compile flags: /Ogtpy
;	COMDAT ?InvCipher3@DES_EDE3@@QAE_K_K@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_iData$ = 12						; size = 8
?InvCipher3@DES_EDE3@@QAE_K_K@Z PROC			; DES_EDE3::InvCipher3, COMDAT

; 111  : 
; 112  : 	union{
; 113  : 		struct{
; 114  : 			unsigned	int	R;
; 115  : 			unsigned	int	L;
; 116  : 		}	i;
; 117  : 		unsigned	__int64	l;
; 118  : 	}	Data;
; 119  : 
; 120  : 	unsigned	int	i = DES_Round;
; 121  : 
; 122  : 	//--------------
; 123  : 	//IP
; 124  : 	Data.l	= IP(iData);

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _iData$[esp]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR _iData$[esp-4]
  00008	53		 push	 ebx
  00009	55		 push	 ebp
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  00013	e8 00 00 00 00	 call	 ?IP@DES@@QAE_K_K@Z	; DES::IP
  00018	8b 7c 24 14	 mov	 edi, DWORD PTR _this$[esp+12]
  0001c	8b e8		 mov	 ebp, eax
  0001e	8b da		 mov	 ebx, edx
  00020	81 c7 30 02 00
	00		 add	 edi, 560		; 00000230H
$LL6@InvCipher3:

; 125  : 
; 126  : 	//--------------
; 127  : 	//[D] Round
; 128  : 	while(i>0){
; 129  : 		i--;
; 130  : 		Data.i.L =	Data.i.L ^ f(Data.i.R, k3[i]);

  00026	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  00029	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  0002c	83 ef 08	 sub	 edi, 8
  0002f	52		 push	 edx
  00030	50		 push	 eax
  00031	8b cd		 mov	 ecx, ebp
  00033	4e		 dec	 esi
  00034	e8 00 00 00 00	 call	 ?f@DES@@QAEII_K@Z	; DES::f

; 131  : 		i--;
; 132  : 		Data.i.R =	Data.i.R ^ f(Data.i.L, k3[i]);

  00039	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  0003c	8b 57 f8	 mov	 edx, DWORD PTR [edi-8]
  0003f	83 ef 08	 sub	 edi, 8
  00042	51		 push	 ecx
  00043	33 d8		 xor	 ebx, eax
  00045	52		 push	 edx
  00046	8b cb		 mov	 ecx, ebx
  00048	4e		 dec	 esi
  00049	e8 00 00 00 00	 call	 ?f@DES@@QAEII_K@Z	; DES::f
  0004e	33 e8		 xor	 ebp, eax
  00050	85 f6		 test	 esi, esi
  00052	77 d2		 ja	 SHORT $LL6@InvCipher3

; 133  : 	}
; 134  : 
; 135  : 	//--------------
; 136  : 	//[E] Round
; 137  : 	while(i < DES_Round){

  00054	83 fe 10	 cmp	 esi, 16			; 00000010H
  00057	73 39		 jae	 SHORT $LN11@InvCipher3
  00059	8b 44 24 14	 mov	 eax, DWORD PTR _this$[esp+12]
  0005d	8d bc f0 30 01
	00 00		 lea	 edi, DWORD PTR [eax+esi*8+304]
$LL4@InvCipher3:

; 138  : 		Data.i.R =	Data.i.R ^ f(Data.i.L, k2[i]);

  00064	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00067	8b 17		 mov	 edx, DWORD PTR [edi]
  00069	51		 push	 ecx
  0006a	52		 push	 edx
  0006b	8b cb		 mov	 ecx, ebx
  0006d	e8 00 00 00 00	 call	 ?f@DES@@QAEII_K@Z	; DES::f

; 139  : 		i++;
; 140  : 		Data.i.L =	Data.i.L ^ f(Data.i.R, k2[i]);

  00072	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00075	33 e8		 xor	 ebp, eax
  00077	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0007a	83 c7 08	 add	 edi, 8
  0007d	50		 push	 eax
  0007e	51		 push	 ecx
  0007f	8b cd		 mov	 ecx, ebp
  00081	46		 inc	 esi
  00082	e8 00 00 00 00	 call	 ?f@DES@@QAEII_K@Z	; DES::f

; 141  : 		i++;

  00087	46		 inc	 esi
  00088	33 d8		 xor	 ebx, eax
  0008a	83 c7 08	 add	 edi, 8
  0008d	83 fe 10	 cmp	 esi, 16			; 00000010H
  00090	72 d2		 jb	 SHORT $LL4@InvCipher3
$LN11@InvCipher3:

; 142  : 	}
; 143  : 
; 144  : 	//--------------
; 145  : 	//[D] Round
; 146  : 	while(i>0){

  00092	85 f6		 test	 esi, esi
  00094	76 38		 jbe	 SHORT $LN1@InvCipher3
  00096	8b 54 24 14	 mov	 edx, DWORD PTR _this$[esp+12]
  0009a	8d bc f2 b0 00
	00 00		 lea	 edi, DWORD PTR [edx+esi*8+176]
$LL2@InvCipher3:

; 147  : 		i--;
; 148  : 		Data.i.L =	Data.i.L ^ f(Data.i.R, k[i]);

  000a1	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  000a4	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  000a7	83 ef 08	 sub	 edi, 8
  000aa	50		 push	 eax
  000ab	51		 push	 ecx
  000ac	8b cd		 mov	 ecx, ebp
  000ae	4e		 dec	 esi
  000af	e8 00 00 00 00	 call	 ?f@DES@@QAEII_K@Z	; DES::f

; 149  : 		i--;
; 150  : 		Data.i.R =	Data.i.R ^ f(Data.i.L, k[i]);

  000b4	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  000b7	83 ef 08	 sub	 edi, 8
  000ba	33 d8		 xor	 ebx, eax
  000bc	8b 07		 mov	 eax, DWORD PTR [edi]
  000be	52		 push	 edx
  000bf	50		 push	 eax
  000c0	8b cb		 mov	 ecx, ebx
  000c2	4e		 dec	 esi
  000c3	e8 00 00 00 00	 call	 ?f@DES@@QAEII_K@Z	; DES::f
  000c8	33 e8		 xor	 ebp, eax
  000ca	85 f6		 test	 esi, esi
  000cc	77 d3		 ja	 SHORT $LL2@InvCipher3
$LN1@InvCipher3:

; 151  : 	}
; 152  : 
; 153  : 	//--------------
; 154  : 	//IP-1
; 155  : 	return(invIP(Data.l));	

  000ce	53		 push	 ebx
  000cf	55		 push	 ebp
  000d0	e8 00 00 00 00	 call	 ?invIP@DES@@QAE_K_K@Z	; DES::invIP

; 156  : }

  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5d		 pop	 ebp
  000d8	5b		 pop	 ebx
  000d9	c2 0c 00	 ret	 12			; 0000000cH
?InvCipher3@DES_EDE3@@QAE_K_K@Z ENDP			; DES_EDE3::InvCipher3
_TEXT	ENDS
PUBLIC	?Cipher3@DES_EDE3@@QAE_K_K@Z			; DES_EDE3::Cipher3
; Function compile flags: /Ogtpy
;	COMDAT ?Cipher3@DES_EDE3@@QAE_K_K@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_iData$ = 12						; size = 8
?Cipher3@DES_EDE3@@QAE_K_K@Z PROC			; DES_EDE3::Cipher3, COMDAT

; 55   : 	union{
; 56   : 		struct{
; 57   : 			unsigned	int	R;	//â∫à 
; 58   : 			unsigned	int	L;	//è„à 
; 59   : 		}	i;
; 60   : 		unsigned	__int64	l;
; 61   : 	}	Data;
; 62   : 
; 63   : 	unsigned	int	i = 0;
; 64   : 
; 65   : 	//--------------
; 66   : 	//IP
; 67   : 	Data.l	= IP(iData);

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _iData$[esp]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR _iData$[esp-4]
  00008	53		 push	 ebx
  00009	55		 push	 ebp
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	33 f6		 xor	 esi, esi
  00010	e8 00 00 00 00	 call	 ?IP@DES@@QAE_K_K@Z	; DES::IP
  00015	8b 7c 24 14	 mov	 edi, DWORD PTR _this$[esp+12]
  00019	8b e8		 mov	 ebp, eax
  0001b	8b da		 mov	 ebx, edx
  0001d	81 c7 b0 00 00
	00		 add	 edi, 176		; 000000b0H
$LL6@Cipher3:

; 68   : 
; 69   : 	//--------------
; 70   : 	//[E] Round
; 71   : 	while(i < DES_Round){
; 72   : 		Data.i.L =	Data.i.L ^ f(Data.i.R, k[i]);

  00023	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00026	8b 07		 mov	 eax, DWORD PTR [edi]
  00028	52		 push	 edx
  00029	50		 push	 eax
  0002a	8b cd		 mov	 ecx, ebp
  0002c	e8 00 00 00 00	 call	 ?f@DES@@QAEII_K@Z	; DES::f

; 73   : 		i++;
; 74   : 		Data.i.R =	Data.i.R ^ f(Data.i.L, k[i]);

  00031	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00034	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00037	83 c7 08	 add	 edi, 8
  0003a	51		 push	 ecx
  0003b	33 d8		 xor	 ebx, eax
  0003d	52		 push	 edx
  0003e	8b cb		 mov	 ecx, ebx
  00040	46		 inc	 esi
  00041	e8 00 00 00 00	 call	 ?f@DES@@QAEII_K@Z	; DES::f

; 75   : 		i++;

  00046	46		 inc	 esi
  00047	33 e8		 xor	 ebp, eax
  00049	83 c7 08	 add	 edi, 8
  0004c	83 fe 10	 cmp	 esi, 16			; 00000010H
  0004f	72 d2		 jb	 SHORT $LL6@Cipher3

; 76   : 	}
; 77   : 
; 78   : 	//--------------
; 79   : 	//[D] Round
; 80   : 	while(i>0){

  00051	85 f6		 test	 esi, esi
  00053	76 39		 jbe	 SHORT $LN11@Cipher3
  00055	8b 44 24 14	 mov	 eax, DWORD PTR _this$[esp+12]
  00059	8d bc f0 30 01
	00 00		 lea	 edi, DWORD PTR [eax+esi*8+304]
$LL4@Cipher3:

; 81   : 		i--;
; 82   : 		Data.i.R =	Data.i.R ^ f(Data.i.L, k2[i]);

  00060	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  00063	8b 57 f8	 mov	 edx, DWORD PTR [edi-8]
  00066	83 ef 08	 sub	 edi, 8
  00069	51		 push	 ecx
  0006a	52		 push	 edx
  0006b	8b cb		 mov	 ecx, ebx
  0006d	4e		 dec	 esi
  0006e	e8 00 00 00 00	 call	 ?f@DES@@QAEII_K@Z	; DES::f

; 83   : 		i--;
; 84   : 		Data.i.L =	Data.i.L ^ f(Data.i.R, k2[i]);

  00073	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  00076	33 e8		 xor	 ebp, eax
  00078	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  0007b	83 ef 08	 sub	 edi, 8
  0007e	50		 push	 eax
  0007f	51		 push	 ecx
  00080	8b cd		 mov	 ecx, ebp
  00082	4e		 dec	 esi
  00083	e8 00 00 00 00	 call	 ?f@DES@@QAEII_K@Z	; DES::f
  00088	33 d8		 xor	 ebx, eax
  0008a	85 f6		 test	 esi, esi
  0008c	77 d2		 ja	 SHORT $LL4@Cipher3
$LN11@Cipher3:

; 85   : 	}
; 86   : 
; 87   : 	//--------------
; 88   : 	//[E] Round
; 89   : 	while(i < DES_Round){

  0008e	83 fe 10	 cmp	 esi, 16			; 00000010H
  00091	73 3a		 jae	 SHORT $LN1@Cipher3
  00093	8b 54 24 14	 mov	 edx, DWORD PTR _this$[esp+12]
  00097	8d bc f2 b0 01
	00 00		 lea	 edi, DWORD PTR [edx+esi*8+432]
  0009e	8b ff		 npad	 2
$LL2@Cipher3:

; 90   : 		Data.i.L =	Data.i.L ^ f(Data.i.R, k3[i]);

  000a0	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000a3	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000a5	50		 push	 eax
  000a6	51		 push	 ecx
  000a7	8b cd		 mov	 ecx, ebp
  000a9	e8 00 00 00 00	 call	 ?f@DES@@QAEII_K@Z	; DES::f

; 91   : 		i++;
; 92   : 		Data.i.R =	Data.i.R ^ f(Data.i.L, k3[i]);

  000ae	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  000b1	83 c7 08	 add	 edi, 8
  000b4	33 d8		 xor	 ebx, eax
  000b6	8b 07		 mov	 eax, DWORD PTR [edi]
  000b8	52		 push	 edx
  000b9	50		 push	 eax
  000ba	8b cb		 mov	 ecx, ebx
  000bc	46		 inc	 esi
  000bd	e8 00 00 00 00	 call	 ?f@DES@@QAEII_K@Z	; DES::f

; 93   : 		i++;

  000c2	46		 inc	 esi
  000c3	33 e8		 xor	 ebp, eax
  000c5	83 c7 08	 add	 edi, 8
  000c8	83 fe 10	 cmp	 esi, 16			; 00000010H
  000cb	72 d3		 jb	 SHORT $LL2@Cipher3
$LN1@Cipher3:

; 94   : 	}
; 95   : 
; 96   : 	//--------------
; 97   : 	//IP-1
; 98   : 	return(invIP(Data.l));

  000cd	53		 push	 ebx
  000ce	55		 push	 ebp
  000cf	e8 00 00 00 00	 call	 ?invIP@DES@@QAE_K_K@Z	; DES::invIP

; 99   : 	
; 100  : }

  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	5d		 pop	 ebp
  000d7	5b		 pop	 ebx
  000d8	c2 0c 00	 ret	 12			; 0000000cH
?Cipher3@DES_EDE3@@QAE_K_K@Z ENDP			; DES_EDE3::Cipher3
; Function compile flags: /Ogtpy
;	COMDAT ?decrypt@DES_EDE3@@UAEXPAX@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?decrypt@DES_EDE3@@UAEXPAX@Z PROC			; DES_EDE3::decrypt, COMDAT
; _this$ = ecx

; 180  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	56		 push	 esi

; 181  : 	unsigned __int64*	iData	= (unsigned __int64*)data;
; 182  : 
; 183  : 	*iData	= InvCipher3(*iData);

  00008	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]
  0000b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000e	8b 16		 mov	 edx, DWORD PTR [esi]
  00010	50		 push	 eax
  00011	52		 push	 edx
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?InvCipher3@DES_EDE3@@QAE_K_K@Z ; DES_EDE3::InvCipher3
  00018	89 06		 mov	 DWORD PTR [esi], eax
  0001a	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 184  : }

  0001d	5e		 pop	 esi
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
?decrypt@DES_EDE3@@UAEXPAX@Z ENDP			; DES_EDE3::decrypt
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?encrypt@DES_EDE3@@UAEXPAX@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?encrypt@DES_EDE3@@UAEXPAX@Z PROC			; DES_EDE3::encrypt, COMDAT
; _this$ = ecx

; 166  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	56		 push	 esi

; 167  : 	unsigned __int64*	iData	= (unsigned __int64*)data;
; 168  : 
; 169  : 	*iData	= Cipher3(*iData);

  00008	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]
  0000b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000e	8b 16		 mov	 edx, DWORD PTR [esi]
  00010	50		 push	 eax
  00011	52		 push	 edx
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?Cipher3@DES_EDE3@@QAE_K_K@Z ; DES_EDE3::Cipher3
  00018	89 06		 mov	 DWORD PTR [esi], eax
  0001a	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 170  : }

  0001d	5e		 pop	 esi
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
?encrypt@DES_EDE3@@UAEXPAX@Z ENDP			; DES_EDE3::encrypt
PUBLIC	??1DES_EDE3@@QAE@XZ				; DES_EDE3::~DES_EDE3
; Function compile flags: /Ogtpy
;	COMDAT ??1DES_EDE3@@QAE@XZ
_TEXT	SEGMENT
??1DES_EDE3@@QAE@XZ PROC				; DES_EDE3::~DES_EDE3, COMDAT
; _this$ = esi

; 26   : {

  00000	57		 push	 edi

; 27   : }

  00001	8d 7e 44	 lea	 edi, DWORD PTR [esi+68]
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7AlgorithmIdentifier@@6B@
  0000a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7ObjectIdentifier@@6B@
  00010	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  00013	85 c0		 test	 eax, eax
  00015	74 09		 je	 SHORT $LN18@DES_EDE3
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN18@DES_EDE3:
  00020	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  00023	50		 push	 eax
  00024	c7 47 50 00 00
	00 00		 mov	 DWORD PTR [edi+80], 0
  0002b	c7 47 54 00 00
	00 00		 mov	 DWORD PTR [edi+84], 0
  00032	c7 47 58 00 00
	00 00		 mov	 DWORD PTR [edi+88], 0
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 04	 add	 esp, 4
  00041	e8 00 00 00 00	 call	 ??1ASN1@@QAE@XZ		; ASN1::~ASN1
  00046	8b fe		 mov	 edi, esi
  00048	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Sequence@@6B@
  0004e	e8 00 00 00 00	 call	 ??1ASN1@@QAE@XZ		; ASN1::~ASN1
  00053	5f		 pop	 edi
  00054	c3		 ret	 0
??1DES_EDE3@@QAE@XZ ENDP				; DES_EDE3::~DES_EDE3
PUBLIC	??0DES_EDE3@@QAE@QBD@Z				; DES_EDE3::DES_EDE3
; Function compile flags: /Ogtpy
;	COMDAT ??0DES_EDE3@@QAE@QBD@Z
_TEXT	SEGMENT
??0DES_EDE3@@QAE@QBD@Z PROC				; DES_EDE3::DES_EDE3, COMDAT
; _this$ = esi

; 14   : {

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MLDFENGJ@DES?9EDE3?9CBC?$AA@
  00005	56		 push	 esi
  00006	e8 00 00 00 00	 call	 ??0AlgorithmIdentifier@@QAE@QBD@Z ; AlgorithmIdentifier::AlgorithmIdentifier
  0000b	c7 86 a0 00 00
	00 08 00 00 00	 mov	 DWORD PTR [esi+160], 8
  00015	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7DES_EDE3@@6B@

; 15   : 	szKey	= DES_KeySize * 3;

  0001b	c7 86 a4 00 00
	00 18 00 00 00	 mov	 DWORD PTR [esi+164], 24	; 00000018H

; 16   : }

  00025	8b c6		 mov	 eax, esi
  00027	c3		 ret	 0
??0DES_EDE3@@QAE@QBD@Z ENDP				; DES_EDE3::DES_EDE3
END

#include "StdAfx.h"
#include "ASN1.h"

//==============================================================
//		コンストラクタ
//--------------------------------------------------------------
//	●引数
//				無し
//	●返値
//				無し
//==============================================================
ASN1::ASN1(const char _strName[]):
	strName(_strName),
	szAddValue(0),
	mode(_EXPLICIT)
{
}
//==============================================================
//		デストラクタ
//--------------------------------------------------------------
//	●引数
//				無し
//	●返値
//				無し
//==============================================================
ASN1::~ASN1(void)
{
	Clear_Construct();
}
//==============================================================
//		ASN.1オブジェクトの追加
//--------------------------------------------------------------
//	●引数
//			ASN1* asn1		追加するASN.1オブジェクト
//	●返値
//			無し
//==============================================================
void	ASN1::Set_Construct(ASN1* asn1)
{
	Constructed.push_back(asn1);
}

//==============================================================
//		ASN.1オブジェクトの全削除
//--------------------------------------------------------------
//	●引数
//			無し
//	●返値
//			無し
//==============================================================
void	ASN1::Clear_Construct()
{

	for(vector<ASN1*>::iterator	it=Constructed.begin(), e=Constructed.end(); it!=e; it++){
		//■■■ To Do:	各クラスをポインタにする
	}

	Constructed.clear();
}

//==============================================================
//		外部データサイズの設定
//--------------------------------------------------------------
//	●引数
//			size_t	iSize	外部データのサイズ
//	●返値
//			無し
//==============================================================
void	ASN1::Set_ExternalDataSize(size_t iSize)
{
	szAddValue = iSize;
}
//==============================================================
//		エラー処理
//--------------------------------------------------------------
//	●引数
//				unsigned int iEer	エラーコード
//	●返値
//				無し
//==============================================================
void	ASN1::error(unsigned int iEer)
{
	static	const	char*	const	msg_err[2]={
		"Context include ASN.1 and Binary.",					//0x00: Contextに、ASN.1とBIN両方がある。
		"Part of the constructed data include external data."	//0x01: 構造化データの途中に、外部データがある。
	};
	errPrint("ASN.1 BER Encode Error :", msg_err[iEer]);
}

//==============================================================
//			【ＢＥＲエンコード】タグ＆サイズ
//--------------------------------------------------------------
//	●引数
//		unsigned	char	cClass	クラス
//					bool	fStruct	構造化フラグ
//		unsigned	int		iTag	タグNo.
//					size_t	iSize	データサイズ
//	●返値
//			無し
//==============================================================
void	ASN1::encodeBER_TAG(unsigned char cClass, bool fStruct,unsigned int iTag, size_t iSize)
{
	const	unsigned	char	cTag = ((fStruct&0x01)<<5) | (cClass<<6);

	if(mode != _IMPLICIT){
		if(iTag <= 30){
			strBER.assign(1,cTag | iTag);
		} else {
			strBER.assign(1,cTag | 31);
			encodeBER_variable(iTag);
		}
		encodeBER_size(iSize);
	}
}
//==============================================================
//			【ＢＥＲエンコード】サイズ
//--------------------------------------------------------------
//	●引数
//		size_t	iSize		値	（※64bit値までのみ対応）
//	●返値
//			無し
//==============================================================
void	ASN1::encodeBER_size(size_t iSize)
{
	if(iSize < 128){			//0〜127
		strBER.append(1,iSize & 0x7F);
	} else {
		string	_code;
		size_t	i = 0;
		while(iSize > 0){
			_code.append(1, (char)(iSize & 0xFF));
			iSize >>= 8;
			i++;
		}
		strBER.append(1, (char)(0x80 + i));
		while(i > 0){
			i--;
			strBER.append(1,_code[i]);
		}
	}
}
//==============================================================
//			【ＢＥＲエンコード】整数値
//--------------------------------------------------------------
//	●引数
//		int		_i		値	（※32bit値までのみ対応）
//	●返値
//			無し
//==============================================================
void	ASN1::encodeBER_int(__int64 _i)
{
	if(_i == 0){
		strBER.append(1,0);
	} else {
		string	_code;
		size_t	i = 0;
		while((_i != 0) && (_i != -1)){
			_code.append(1, (char)(_i & 0xFF));
			_i >>= 8;
			i++;
		}
		while(i > 0){
			i--;
			strBER.append(1,_code[i]);
		}
	}
}
//==============================================================
//			【ＢＥＲエンコード】可変長値
//--------------------------------------------------------------
//	●引数
//		unsigned int	_i		値	（※32bit値までのみ対応）
//	●返値
//			無し
//==============================================================
void	ASN1::encodeBER_variable(unsigned int _i)
{
				size_t	count=0;		//読み込み回数カウント用
				char	cData[9];

	//----------------------------------
	//■可変長エンコード
	do{
		cData[count] = _i & 0x7F;
		_i>>=7;
		count++;
	} while((count<9) && (_i > 0));

	//■可変長出力
	do{
		count--;
		strBER.append(1,cData[count] | ((count==0)? 0 : 0x80));
	} while(count > 0);
}
//==============================================================
//			【ＢＥＲエンコード】メンバー ANS.1オブジェクト
//--------------------------------------------------------------
//	●引数
//		unsigned char	cClass		クラス
//		unsigned int	iTag		タグ
//	●返値
//				無し
//==============================================================
void	ASN1::encodeBER_Constructed(unsigned char cClass, unsigned int iTag)
{
	unsigned	int		i=0;
	string				strSEQ;

	while(i < Constructed.size()){
		Constructed[i]->encodeBER();
		szAddValue += Constructed[i]->Get_ExternalDataSize();	//追加データが有るか？
		strSEQ.append(Constructed[i]->Get_BERcode(), Constructed[i]->Get_BERsize());
		i++;
		if(i < Constructed.size()){
			if(szAddValue != 0){
				error(1);
			}
		}
	}
	encodeBER_TAG(cClass, true, iTag, strSEQ.size() + szAddValue);
	strBER += strSEQ;
}
//==============================================================
//			【ＢＥＲエンコード】
//--------------------------------------------------------------
//	●引数
//				無し
//	●返値
//				無し
//==============================================================
void	ASN1::encodeBER()
{
	encodeBER_TAG(BER_Class_General, false, BER_TAG_NULL, 0);
}
//==============================================================
//			《ＢＥＲエンコード》符号化後の整数値のサイズを取得
//--------------------------------------------------------------
//	●引数
//						__int64	_i		整数値
//	●返値
//						size_t			BER符号化された整数値のサイズ
//==============================================================
size_t ASN1::Get_szInt_for_BER(__int64 _i){

	size_t	iResult = 7;

	union{
		__int64	i64;
		char	c[8];
	} _num;

	_num.i64 = _i;

	while(iResult>0){
		if(_num.c[iResult] != 0){
			break;
		}
		iResult--;
	}
	return(iResult+1);
}
//==============================================================
//			《ＢＥＲエンコード》符号化後のサイズ値のサイズを取得
//--------------------------------------------------------------
//	●引数
//			unsigned	int	iSize	サイズ値
//	●返値
//						size_t		BER符号化されたサイズ値のサイズ
//==============================================================
size_t ASN1::Get_szSize_for_BER(size_t iSize){

	size_t	szSize;

	if(iSize < (1<<7)){			//〜127
		szSize = 1;
	} else if(iSize < (1<<8)) {	//〜255
		szSize = 2;
	} else if(iSize < (1<<16)) {	//〜65535,	
		szSize = 3;
	} else if(iSize < (1<<24)) {
		szSize = 4;
	} else {
		szSize = 5;
	}

	return(szSize);
}
//==============================================================
//		BERコードの取得
//--------------------------------------------------------------
//	●引数
//							無し
//	●返値
//		const	char*		BERコード
//==============================================================
const	char*	ASN1::Get_BERcode(void){
	return(strBER.c_str());
};
//==============================================================
//		BERコードのサイズ取得
//--------------------------------------------------------------
//	●引数
//							無し
//	●返値
//				size_t		BERコードのサイズ
//==============================================================
size_t	ASN1::Get_BERsize(void){
	return(strBER.size());
};
